$$$$ COLL     NOTICE  GF238795  15/01/26    21:15:01     8355
                                             DATE     15/01/26

    Operateur COLLABORATEUR                   Voir aussi : ASSI
    --------------

Section : Langage Base

FRAN==========================================================
L'opérateur COLL(aborateur) fournit des fonctionnalités de communication et
d'échanges d'objets entre différents collaborateurs de Cast3m (copies) pour
pouvoir réaliser des calculs à mémoire distribuée.
L'opérateur utilise actuellement la libraire openMPI pour transmettre les
messages. La fonctionnalité voulue est sélectionnée en précisant un mot clef
qui peut être :
        -DEBUT
        -FIN
        -RANG
        -NOMBRE
        -ENVOYER
        -RECEVOIR

--------------------------------------------------------------------------------
 1) Initialisation des communications : DEBUT
--------------------------------------------------------------------------------
   --------------------------
        Syntaxe :
   --------------------------
      COLL 'DEBUT';

   --------------------------
        Arguments et résultats :
   --------------------------
      N/A

   -------------------------
        Description :
   --------------------------
      La directive COLL 'DEBUT' initialise l'environnement de communication MPI.
      Elle initialise aussi les piles de communication gardant l'historique des
      communications entre les collaborateurs.

      Cette directive doit être appelée avant toute utilisation des autres
      fonctionnalités des collaborateurs. Un appel à une autre fonctionnalité
      avant un appel à COLL 'DEBUT' provoque une sortie en erreur de l'opérateur
      COLL.
      Elle appelle la fonction mpi_Init_Thread et la documentation d'OpenMPI
      recommande de l'appeler le plus tôt possible. De plus, MPI limite son
      appel à une fois par exécution de Cast3m.

--------------------------------------------------------------------------------
 2) Fermeture des communications : FIN
--------------------------------------------------------------------------------
   --------------------------
        Syntaxe :
   --------------------------
      COLL 'FIN';

   --------------------------
        Arguments et résultats :
   --------------------------
      N/A

   --------------------------
        Description :
   --------------------------
      Cette directive ferme l'environnement de communication MPI. Elle libère
      ensuite les piles de communication. Elle doit être appelée avant de
      quitter cast3m et une fois toutes les communications terminées.

      La directive COLL 'FIN' réalise un appel à la fonction mpi_Finalize et
      ne peut être appelée qu'une fois par exécution. Ceci est une limitation
      de MPI.

      Une fois COLL 'FIN' appelée, il n'est plus possible d'obtenir des
      informations sur l'environnement parallèle ou d'échanger des messages même
      après un autre appel à COLL 'DEBUT'.

      Si un collaborateur se termine sans appeler cette routine, l'environnement
      d'exécution MPI détecte une sortie non prévue. Il arrête tous les autres
      collaborateurs et renvoie une erreur.

--------------------------------------------------------------------------------
 3) Récupération du rang du collaborateur : RANG
--------------------------------------------------------------------------------
   --------------------------
        Syntaxe :
   --------------------------
      ENT1= COLL 'RANG';

   --------------------------
        Arguments et résultats :
   --------------------------
      ENT1 : entier, numéro du collaborateur

   --------------------------
        Description :
   --------------------------
      L'opérateur COLL 'RANG' permet de récupérer le numéro du collaborateur
      dans l'environnement parallèle.
      Ce numéro est compris entre 1 et (COLL 'NOMBRE').

--------------------------------------------------------------------------------
 4) Récupération du nombre de collaborateurs : NOMBRE
--------------------------------------------------------------------------------
   --------------------------
        Syntaxe :
   --------------------------
      ENT1= COLL 'NOMBRE';

   --------------------------
        Arguments et résultats :
   --------------------------
      ENT1 : entier, nombre de collaborateurs

   --------------------------
        Description :
   --------------------------
      L'opérateur COLL 'NOMBRE' permet de récupérer le nombre total de
      collaborateurs dans l'environnement parallèle.

--------------------------------------------------------------------------------
 5) Envoi d'un message : ENVOYER
--------------------------------------------------------------------------------
   --------------------------
        Syntaxe :
   --------------------------
      COLL 'ENVOYER' ENT1 OBJ1 .. OBJi .. OBJn;

   --------------------------
        Arguments et résultats :
   --------------------------
      ENT1 : Entier, numéro du collaborateur destinataire du message.
      OBJi : Objets à envoyer. Leur type doit faire partie des types supportés.

   --------------------------
        Description :
   --------------------------
      L'opérateur COLL 'ENVOYER' permet d'envoyer des objets à un collaborateur.
      Cet opérateur est bloquant. L'envoi du message ne commence que lorsque le
      destinataire est prêt à recevoir et l'exécution de l'opérateur ne se
      termine que lorsque le message est reçu.

      Les types d'objet actuellement supportés sont :
         -FLOTTANT    : flottant
         -ENTIER      : entier
         -LOGIQUE     : logique
         -MOT         : mot
         -CONFIGUR    : configuration
         -POINT       : noeud
         -MAILLAGE    : maillage
         -CHPOINT     : champ par point
         -MCHAML      : champ par élément
         -RIGIDITE    : rigidité
         -MMODEL      : modèle

   --------------------------
        Notes :
   --------------------------
      L'opérateur COLL 'ENVOYER' utilise des fonctions bloquantes de MPI
      (mpi_send, mpi_recv, mpi_probe). La communication est synchrone et peut
      empêcher un script de se terminer si l'appel à COLL 'RECEVOIR'
      correspondant n'est pas réalisé par le destinataire.

      En utilisation directe, il n'est pas possible à un collaborateur de
      s'envoyer lui-même un message. En effet, l'appel à COLL 'ENVOYER' étant
      bloquant, le collaborateur ne peut pas lancer l'appel au COLL 'RECEVOIR'
      correspondant. Cela provoque des blocages lors d'un envoi à soi-même.
      La solution est alors d'utiliser les assistants pour réaliser l'envoi du
      message. Pour cela, voir la remarque plus bas sur les communications
      asynchrones.

--------------------------------------------------------------------------------
 6) Réception d'un message : RECEVOIR
--------------------------------------------------------------------------------
   --------------------------
        Syntaxe :
   --------------------------
      OBJ1 .. OBJi .. OBJn = COLL 'RECEVOIR' ENT1;

   --------------------------
        Arguments et résultats :
   --------------------------
      ENT1 : Entier, numéro du collaborateur expéditeur du message
      OBJi : Objets reçus

   --------------------------
        Description :
   --------------------------
      L'opérateur COLL 'RECEVOIR' attend et reçoit un message d'un collaborateur
      donné et puis renvoie à l'utilisateur les objets fournis en argument du
      COLL 'ENVOYER' correspondant. Cet appel est bloquant et ne se termine
      qu'une fois le message reçu.

   --------------------------
        Notes :
   --------------------------
      Les objets sont renvoyés dans l'ordre dans lequel ils ont été donnés à
      l'envoi.  Ainsi, l'objet i lors d'un appel à COLL 'ENVOYER'  restera
      l'objet i dans la liste des objets résultats de COLL 'RECEVOIR'.

      L'opérateur COLL 'RECEVOIR' utilise des fonctions bloquantes de MPI
      (mpi_send, mpi_recv, mpi_probe). La communication est synchrone et peut
      empêcher un script de se terminer si l'appel à COLL 'ENVOYER'
      correspondant n'est pas fait.

--------------------------------------------------------------------------------
    Remarques
--------------------------------------------------------------------------------
   ----------------------------
        Détection des objets envoyés
   ----------------------------
      Afin de limiter la quantité de données envoyées, les objets déjà envoyés
      sont détectés. L'expéditeur ne ré-envoie pas les objets déjà traité et le
      destinataire ré-utilise les objets qui possède déjà en mémoire.
      Ceci est facilement vérifiable en envoyant deux fois le même objet et en
      vérifiant que les deux objets reçus ont le même pointeur Ésope.

   ----------------------------
        Communications asynchrones
   ----------------------------
      Les opérateurs COLL 'ENVOYER' et COLL 'RECEVOIR' réalisent des
      communications synchrones et utilisent des appels bloquants de MPI. Il est
      toutefois possibles de réaliser des communications asynchrones avec ces
      opérateurs.  Pour cela, il faut utiliser les assistants de Cast3m via
      l'opérateur ASSI.  Cet opérateur permet d'exécuter les lignes de commande
      Gibiane de manière asynchrone.
      L'interpréteur Gibiane passe à l'instruction suivante sans attendre la fin
      de la précédente ce qui permet de lancer la communication sur un assistant
      et de continuer tout de suite d'exécuter le reste du script.
      Un communication peut donc se faire de manière asynchrone en utilisant les
      commandes
      ASSI 1 COLL 'ENVOYER' ENT1 OBJi;
      et
      OBJi = ASSI 1 COLL 'RECEVOIR' ENT2;

      Les résultats de COLL 'RECEVOIR' ne peuvent pas être utilisé tant que
      l'opérateur ne s'est pas terminé, c'est à dire tant qu'ils n'ont pas été
      correctement reçus.

      De cette manière, un collaborateur peut réaliser une communication vers
      lui-même en lançant l'envoi sur un assistant. L'exécution du script pourra
      continuer jusqu'à ce que COLL 'RECEVOIR' soit appelé.

   ----------------------------
   Communication globale
   ----------------------------
      Les opérateurs de communication réalisent des communications point à
      point.  Il est possible de réaliser facilement une communication globale
      en utilisant l'option TOUS de l'opérateur ASSI.

      Il faut remplir une liste de destinataire et lancer la commande
      ASSI TOUS COLL 'ENVOYER' DESTI OBJ TABOBJ;

      La table DESTI est une table d'entier de sous-type ESCLAVE contenant les
      numéro des collaborateurs destinataires. (voir exemple 2)

      Si OBJ est un objet simple, il sera envoyé à tous les destinataires de la
      liste DESTI. Si TABOBJ est une table de sous-type ESCLAVE, elle est
      remplacée par l'élément correspondant de la table. Ainsi, l'objet TABOBJ.i
      sera envoyé au destinataire DESTI.i.

      De la même manière, il est possible de recevoir un message d'une liste
      d'expéditeur en utilisant
      TABRESU = ASSI TOUS COLL 'RECEVOIR' DESTI;

   ----------------------------
   Objets configuration
   ----------------------------
      Lors de leur première apparition dans un message, les noeuds sont
      initialisés avec les coordonnées de la configuration actuelle de
      l'expéditeur.

      Une fois créé chez le destinataire, un noeud n'est pas modifié même si ses
      coordonnées ont changé chez l'expéditeur. Pour transmettre des nouvelles
      coordonnés de noeuds, il faut envoyer un objet CONFIGUR contenant les
      coordonnées à jour des noeuds et appliquer l'objet chez le destinataire
      par l'opérateur FORM (voir exemple 1).

      Les configurations envoyées sont réduites à uniquement à la liste des
      noeuds nécessaires. Seule les coordonnées des noeuds présents dans des
      objets échangés sont envoyées. Les objets CONFIGUR reçus sont complétés
      avec les coordonnées des autres noeuds en mémoire du destinataire.

      Si le nombre de dimensions est différent entre les deux collaborateurs,
      les composantes supplémentaires des coordonnées sont tronquées et les
      composantes manquantes sont mises à zéro. Par exemple, si un collaborateur
      en dimension 2 envoie le noeud (12,42) à un collaborateur en dimension 3,
      le noeud créé aura les coordonnées (12,42,0). Si un collaborateur en
      dimension 3 envoie le noeud (21,24,6) à un collaborateur en dimension 2,
      le noeud crée aura les coordonnées (21,24).

--------------------------------------------------------------------------------
    Exemples
--------------------------------------------------------------------------------
   ----------------------------
   Envoi d'un maillage et
   application d'une
   configuration
   ----------------------------
                COLL DEBUT;
                NPROCE = COLL RANG;
                SI(NPROCE EGA 1);
         MA1 = SURF ...;
                        COLL ENVOYER 2 MA1;
         DEPLA PLUS MA1 (1 1);
         CFG1 = FORM;
         COLL ENVOYER 2 CFG1;
                SINON;
                        REMA1 = COLL RECEVOIR 1;
         RECFG1 = COLL RECEVOIR 1;
         FORM RECFG1;
                FINSI;
      COLL FIN;
      FIN;

   ----------------------------
        Envoi global et détection
   d'objets déjà envoyés
   ----------------------------
                COLL DEBUT;
                NPROCE = COLL RANG;
                TOTPROC = COLL NOMBRE;
                SI(NPROCE EGA 1);
         DESTI = TABLE 'ESCLAVE';
         REPETER IDOM (TOTPROC);
            DESTI.&IDOM=&IDOM;
         FIN IDOM;
         MA1 = SURF ...;
         MA2 = SURF ...;
         PART1 = PART TOTPROC MA1;
         ASSI TOUS COLL ENVOYER DESTI PART1 MA2;
         COLL ENVOYER 2 PART1.2;
                FINSI;
      REMA1 REMA2 = COLL RECEVOIR 1;
                SI(NPROCE EGA 2);
         REMA3 = COLL RECEVOIR 1;
         LIST REMA1;
         LIST REMA3;
*  Chez le collaborateur 2, REMA3 est le même objet que REMA1, le lister
*  permet de vérifier qu'ils ont le même pointeur
                FINSI;
      COLL FIN;
      FIN;

ANGL==========================================================
The COLL(aborateur) operator provides communication and objects exchange
functionalities between different Cast3m collaborators (copies of Cast3m) in
order to enable shared memory computation. For the moment, the operator uses the
openMPI library to send the messages. The functionality is defined by giving to
the operator a keyword which can be:
        -DEBUT (begin)
        -FIN (end)
        -RANG (rank)
        -NOMBRE (number)
        -ENVOYER (send)
        -RECEVOIR (receive)

--------------------------------------------------------------------------------
 1) Initialization of the communications: DEBUT
--------------------------------------------------------------------------------
   --------------------------
        Syntax:
   --------------------------
      COLL 'DEBUT';

   --------------------------
        Arguments and results:
   --------------------------
      N/A

   -------------------------
        Description:
   --------------------------
      The directive COLL 'DEBUT' initializes the MPI communication environment.
      Then, it initializes the internal communication piles keeping the history
      of the messages exchange between collaborators.

      This directive must be called before any other call to the COLL operator.
      A call to an other functionality before COLL 'DEBUT' will result in an
      error.

      It calls the function mpi_init_Thread and the openMPI documentation
      strongly advices to call this function as soon as possible. Furthermore,
      MPI limits to one the number of call to mpi_init_Thread.

--------------------------------------------------------------------------------
 2) Communication ending: FIN
--------------------------------------------------------------------------------
   --------------------------
        Syntax:
   --------------------------
      COLL 'FIN';

   --------------------------
        Arguments and results:
   --------------------------
      N/A

   --------------------------
        Description:
   --------------------------
      This directive closes the MPI environment. It frees the communication
      piles. It must be called before quitting Cast3m and only when all the
      communications are finished.

      The directive COLL 'FIN' calls the function mpi_Finalize and can only be
      called once by run. This is a MPI limitation.

      Once COLL 'FIN' called, it is not possible to get informations about the
      communication environment or to send messages.

      If a collaborator quits before calling COLL 'FIN', the MPI environment
      detects an unexpected end. It stops all the collaborators and returns an
      error.

--------------------------------------------------------------------------------
 3) Collaborator rank retrieval: RANG
--------------------------------------------------------------------------------
   --------------------------
        Syntax:
   --------------------------
      ENT1= COLL 'RANG';

   --------------------------
        Arguments and results:
   --------------------------
      ENT1: integer, rank of the collaborator

   --------------------------
        Description:
   --------------------------
      The operator COLL 'RANG' retrieves the rank of the collaborator inside the
      MPI environment. This number is included between 1 and (COLL'NOMBRE').

--------------------------------------------------------------------------------
 4) Number of collaborators retrieval: NOMBRE
--------------------------------------------------------------------------------
   --------------------------
        Syntax:
   --------------------------
      ENT1= COLL 'NOMBRE';

   --------------------------
        Arguments and results:
   --------------------------
      ENT1: integer, number of collaborators.

   --------------------------
        Description:
   --------------------------
      The COLL 'NOMBRE' operator returns the total number of collaborators
      inside the parallel environment.

--------------------------------------------------------------------------------
 5) Message sending: ENVOYER
--------------------------------------------------------------------------------
   --------------------------
        Syntax:
   --------------------------
      COLL 'ENVOYER' ENT1 OBJ1 .. OBJi .. OBJn;

   --------------------------
        Arguments and results:
   --------------------------
      ENT1: Integer, rank of the collaborator recipient.
      OBJi: Objects to send. Their type must be part of the supported types.

   --------------------------
        Description:
   --------------------------
      The COLL operator sends objects to a collaborator. This operator acts in
      blocking mode. The message sending begins only when the recipient is ready
      to receive and the operator quits only when the message is received.
      At this time, the supported object types are:
        -FLOTTANT   : float
        -ENTIER     : integer
        -LOGIQUE    : logical
        -MOT        : word
        -CONFIGUR   : configuration
        -POINT      : node
        -MAILLAGE   : mesh
        -CHPOINT    : field by point
        -MCHAML     : field by element
        -RIGIDITE   : stiffness matrix
        -MMODEL     : model

   --------------------------
        Notes:
   --------------------------
      The COLL 'ENVOYER' operator uses MPI blocking functions (mpi_send,
      mpi_recv, mpi_probe). The communication is synchronous and can prevent a
      script to end if the corresponding call to COLL 'RECEVOIR' is not made.

      It is not possible to directly use COLL to self sending. Indeed, the call
      to COLL 'ENVOYER' being blocking, the collaborator can not call the
      corresponding COLL 'RECEVOIR'. This causes deadlocks. The solution is
      to use Cast3m assistant (see ASSI operator) in order to send the message
      with an assistant. To do so, see the remark below about asynchronous
      sending.

--------------------------------------------------------------------------------
 6) Message receiving: RECEVOIR
--------------------------------------------------------------------------------
   --------------------------
        Syntax:
   --------------------------
      OBJ1 .. OBJi .. OBJn = COLL 'RECEVOIR' ENT1;

   --------------------------
        Arguments and results:
   --------------------------
      ENT1: Integer, rank of the collaborator sending the message
      OBJi: Received objects

   --------------------------
        Description:
   --------------------------
      The COLL 'RECEVOIR' operator waits for a message from a given collaborator
      and receives it. Then, it returns to the user the objects given in
      arguments to the corresponding COLL 'ENVOYER'. This call is blocking and
      ends only when the message is received.

   --------------------------
        Notes:
   --------------------------
      The objects are returned in the same order as they were given to the send
      operator.
      So, the object i in the arguments of COLL 'ENVOYER' will stay the object i
      in the result of the COLL 'RECEVOIR'.

      The COLL 'RECEVOIR' operator uses MPI blocking functions (mpi_send,
      mpi_recv, mpi_probe). The communication is synchornous and can prevent a
      script to end if the corresponding call to COLL 'ENVOYER' is not made.


      It is not possible to directly use COLL to self sending. Indeed, the call
      to COLL 'RECEVOIR' being blocking, the collaborator can not call the
      corresponding COLL 'ENVOYER'. This causes deadlocks. The solution is to
      use Cast3m assistant (see ASSI operator) in order to send the message with
      an assistant. To do so, see the further remark about asynchronous sending.

--------------------------------------------------------------------------------
    Remarks
--------------------------------------------------------------------------------
   ----------------------------
        Detection of sent objects
   ----------------------------
      To limit the amount of sent data, previously sent objects are detected.
      The sender does not send again the objects already treated in a previous
      message and already in the receiver memory.
      The can be easily verified by sending twice the same object and checking
      that the received objects have the same Esope pointer.

   ----------------------------
        Asynchronous communications
   ----------------------------
      The COLL 'ENVOYER' and COLL 'RECEVOIR' operators are communicating in
      blocking mode but it is possible to realize an asynchronous communication
      with these operators. To do so, one must use the Cast3m assistants and the
      ASSI operator. This operator allows to execute the Gibiane command lines
      in an asynchronous way.
      The Gibiane interpreter executes every command lines without waiting the
      end of the previous one which allows to launch the communication with an
      assistant and continue to execute the rest of the script.
      A communication can be done in an asynchronous way by using the commands
      ASSI 1 COLL 'ENVOYER' ENT1 OBJi;
      and
      OBJi = ASSI 1 COLL 'RECEVOIR' ENT2;

      The results of COLL 'RECEVOIR' can not be used until the operator has
      ended, i.e. until the objects are correctly received.

      This way, a collaborator can realize a communication with itself by
      calling the sending operator with an assistant. The script execution will
      continue until COLL 'RECEVOIR' will be called.

   ----------------------------
   Collective communication
   ----------------------------
      The communication operators realize point to point communication. It is
      possible to use the assistants to easily put in place collective
      communications with the 'TOUS' option of the ASSI operator.

      One must fill a recipients list and enter the command
      ASSI TOUS COLL 'ENVOYER' DESTI OBJ TABOBJ;

      The DESTI table is a table of integer with the ESCLAVE subtype. It
      contains the rank of the different recipients (see example 2).

      If OBJ is a simple object, it will be sent to every recipient of the list
      DESTI. If TABOBJ is an ESCLAVE subtype table , it is replaced by the
      correct element of the table. The object TABOBJ.i will be sent to the
      recipient DESTI.i.

      Similarly, it is possible to receive a message from a senders list by
      entering the command
      TABRESU = ASSI TOUS COLL 'RECEVOIR' DESTI;

   ----------------------------
   Configuration type object
   ----------------------------
      At their first appearance in a message, the nodes are initialized their
      coordinates in the current configuration of the sender.

      Once they have been created, the node is not modified even if its
      coordinates have changed in the sender configuration.
      To update with new nodes coordinates, one must send a CONFIGUR object
      containing the updated coordinates and apply it to the recipient with the
      FORM operator (see example 1).

      The sent configurations are reduced to the necessary nodes. Only the
      coordinates of the nodes present in the exchanged objects are sent. The
      CONFIGUR objects are completed with the current coordinates of the other
      nodes present in the memory of the recipient.

      If the numbers of dimensions of the collaborators are different, the
      additional components are truncated and the missing ones are set to zero.
      For example, if a collaborator in dimension 2 sends the node of
      coordinates (12, 42) to a collaborator in dimension 3, the created node
      will have the coordinates (12,42,0). If a collaborator in dimension 3
      sends the node (21,24,6) to a collaborator in dimension 3, the created
      node will have the coordinates (21,24).

--------------------------------------------------------------------------------
    Examples
--------------------------------------------------------------------------------
   ----------------------------
   Mesh sending and
   configuration application
   ----------------------------
                COLL DEBUT;
                NPROCE = COLL RANG;
                SI(NPROCE EGA 1);
         MA1 = SURF ...;
                        COLL ENVOYER 2 MA1;
         DEPLA PLUS MA1 (1 1);
         CFG1 = FORM;
         COLL ENVOYER 2 CFG1;
                SINON;
                        REMA1 = COLL RECEVOIR 1;
         RECFG1 = COLL RECEVOIR 1;
         FORM RECFG1;
                FINSI;
      COLL FIN;
      FIN;

   ----------------------------
   Collective sending and
   previously sent objects
   detection
   ----------------------------
                COLL DEBUT;
                NPROCE = COLL RANG;
                TOTPROC = COLL NOMBRE;
                SI(NPROCE EGA 1);
         DESTI = TABLE 'ESCLAVE';
         REPETER IDOM (TOTPROC);
            DESTI.&IDOM=&IDOM;
         FIN IDOM;
         MA1 = SURF ...;
         MA2 = SURF ...;
         PART1 = PART TOTPROC MA1;
         ASSI TOUS COLL ENVOYER DESTI PART1 MA2;
         COLL ENVOYER 2 PART1.2;
                FINSI;
      REMA1 REMA2 = COLL RECEVOIR 1;
                SI(NPROCE EGA 2);
         REMA3 = COLL RECEVOIR 1;
         LIST REMA1;
         LIST REMA3;
* For the collaborator 2, REMA3 and REMA1 are the same object. One can check
* that they have the same Esope pointer by listing them
                FINSI;
      COLL FIN;
      FIN;
$$$$

