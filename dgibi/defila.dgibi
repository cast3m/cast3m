* fichier : defila.dgibi
************************************************************************
* Section : Fluides Transitoire
************************************************************************
*
'OPTI' 'ECHO' 1 ;
*
'SAUTER' 2 'LIGNE' ;
'MESSAGE' ' Execution de defila.dgibi' ;
'SAUTER' 2 'LIGNE' ;
*
graph = faux ;
complet = faux ;
interact = faux ;
*
************************************************************************
* NOM         : DEFILA
* DESCRIPTION : Ecoulement sous une surface libre soumise à une pression
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 21/06/2010, version initiale
* HISTORIQUE : v1, 21/06/2010, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
 'OPTION' 'DIME' 2 'MODE' 'PLAN' 'ISOV' 'SURF' 'ELEM' 'QUA4' ;
* 'OPTION' 'DIME' 3 'MODE' 'TRID' 'ISOV' 'SURF' 'ELEM' 'CUB8' ;
'SI' ('NON' interact) ;
   'OPTI' 'TRACER' 'PS' ;
'SINON' ;
   'OPTI' 'TRACER' 'X' ;
'FINSI' ;
debug = faux ;
dbggra1 = faux ;
dbggra2 = faux ;
*
*fic = 'CHAINE' '/test4/gounand/kong/defilad2h3q60r2it24.sauv' ;
*'MESSAGE' ('CHAINE' 'Loading ' fic '...') ;
*'OPTI' 'RESTITUER' fic ;
*'RESTITUER' ;
*
************************************************************************
*
*
*   PROCEDURES
*
*
************************************************************************
'DEBPROC' attente ;
'ARGUMENT' s*'FLOTTANT' ;
'SI' interact ;
   'REPETER' i ('+' ('ENTIER' ('*' 100000 s)) 1) ;
   'FIN' i ;
'FINSI' ;
'FINPROC' ;
*BEGINPROCEDUR affvar
************************************************************************
* NOM         : AFFVAR
* DESCRIPTION : Affiche des variables
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
*
*
'DEBPROC' AFFVAR ;
'REPETER' bcl ;
   'ARGUMENT' x/'FLOTTANT' ;
   'SI' ('EXISTE' x) ;
      'ARGUMENT' lx*'MOT' ;
      'MESSAGE' ('CHAINE' lx '=' x) ;
   'SINON' ;
      'QUITTER' bcl ;
   'FINSI' ;
'FIN' bcl ;
'FINPROC' ;
*
* End of procedure file AFFVAR
*
*ENDPROCEDUR affvar
*BEGINPROCEDUR append
************************************************************************
* NOM         : APPEND
* DESCRIPTION : Rajoute :
*               - un entier à un listentier
*               - un réel   à un listreel
*               - un objet (liste, evolution, matrice ou chpoint)
*                 à un indice de table ('MOT' ou 'ENTIER')
*                    * si l'indice n'existe pas
*                    * 'ET' si l'indice existe
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 10/09/2004, version initiale
* HISTORIQUE : v1, 10/09/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' APPEND ;
'ARGUMENT' tab/'TABLE' ;
'SI' ('EXISTE' tab) ;
   'ARGUMENT' itab/'MOT' ;
   'SI' ('NON' ('EXISTE' itab)) ;
      'ARGUMENT' itab*'ENTIER' ;
   'FINSI' ;
   lobj = FAUX ;
   'SI' ('NON' lobj) ;
      'ARGUMENT' lr/'LISTREEL' ;
      'SI' ('EXISTE' lr) ;
         obj = lr ; lobj = VRAI ;
      'FINSI' ;
   'FINSI' ;
   'SI' ('NON' lobj) ;
      'ARGUMENT' le/'LISTENTI' ;
      'SI' ('EXISTE' le) ;
         obj = le ; lobj = VRAI ;
      'FINSI' ;
   'FINSI' ;
   'SI' ('NON' lobj) ;
      'ARGUMENT' lev/'EVOLUTION' ;
      'SI' ('EXISTE' lev) ;
         obj = lev ; lobj = VRAI ;
      'FINSI' ;
   'FINSI' ;
   'SI' ('NON' lobj) ;
      'ARGUMENT' lm/'MAILLAGE' ;
      'SI' ('EXISTE' lm) ;
         obj = lm ; lobj = VRAI ;
      'FINSI' ;
   'FINSI' ;
   'SI' ('NON' lobj) ;
      'ARGUMENT' chpo/'CHPOINT' ;
      'SI' ('EXISTE' chpo) ;
         obj = chpo ; lobj = VRAI ;
      'FINSI' ;
   'FINSI' ;
   'SI' ('NON' lobj) ;
      'ARGUMENT' rig/'RIGIDITE' ;
      'SI' ('EXISTE' rig) ;
         obj = rig ; lobj = VRAI ;
      'FINSI' ;
   'FINSI' ;
   'SI' ('NON' lobj) ;
      'ARGUMENT' matk/'MATRIK' ;
      'SI' ('EXISTE' matk) ;
         obj = matk ; lobj = VRAI ;
      'FINSI' ;
   'FINSI' ;
   'SI' ('NON' lobj) ;
      cherr = 'CHAINE'
       'Il faut fournir un objet liste, evolution, matrice ou chpoint.'
        ;
      'ERREUR' cherr ;
   'FINSI' ;
   'SI' ('EXISTE' tab itab) ;
      'SI' ('EGA' ('TYPE' obj) 'CHPOINT') ;
         tab . itab = '+' (tab . itab) obj ;
      'SINON' ;
         tab . itab = 'ET' (tab . itab) obj ;
      'FINSI' ;
   'SINON' ;
      tab . itab = obj ;
   'FINSI' ;
   'RESPRO' tab ;
'FINSI' ;
'ARGUMENT' lenti/'LISTENTI' ;
'ARGUMENT' lreel/'LISTREEL' ;
'SI' ('EXISTE' lenti) ;
   'ARGUMENT' enti*'ENTIER' ;
   lenti = 'ET' lenti ('LECT' enti) ;
   'RESPRO' lenti ;
'FINSI' ;
'SI' ('EXISTE' lreel) ;
   'ARGUMENT' reel*'FLOTTANT' ;
   lreel = 'ET' lreel ('PROG' reel) ;
   'RESPRO' lreel ;
'FINSI' ;
*
* End of procedure file APPEND
*
'FINPROC' ;
*ENDPROCEDUR append
*BEGINPROCEDUR calimet
************************************************************************
* NOM         : CALIMET
* DESCRIPTION :
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, ??/??/2007, version initiale
* HISTORIQUE : v1, ??/??/2007, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' CALIMET ;
'ARGUMENT' _mt*'MAILLAGE' ;
'ARGUMENT' gdisc*'MOT' ;
'ARGUMENT' methgau*'MOT' ;
*methgau = 'GAU7' ;
tmot = 'TABLE' ;
tnom = 'TABLE' ;
idim = 'VALEUR' 'DIME' ;
vdim  = DEADUTIL 'DIMM' _mt ;
idx = 0 ;
cim = 'CHAINE' 'IMET' ;
cg  = 'CHAINE' 'G' ;
'REPETER' iidim idim ;
   'REPETER' jidim idim ;
      'SI' ('>EG' &jidim &iidim) ;
         idx = '+' idx 1 ;
         tmot . idx = 'CHAINE' cim &iidim &jidim ;
* Convention Castem opposee à convention NLIN
         tnom . idx = 'CHAINE' cg &jidim &iidim ;
      'FINSI' ;
   'FIN' jidim ;
'FIN' iidim ;
*
lvid = 'LECT' ;
dtm = 'DIME' tmot ;
tchpo = 'TABLE' 'ESCLAVE' ;
idx = 0 ;
'REPETER' itm dtm ;
   mcm = tmot . &itm ;
   numop  = 1 ;
   numder = vdim ;
   numvar = 1 ;
   numdat = 0 ;
   numcof = 1 ;
   A = ININLIN numop numvar numdat numcof numder ;
   A . 'VAR' . 1 . 'NOMDDL' = 'MOTS' 'DUMM' ;
   A . 'VAR' . 1 . 'DISC'   = 'CSTE' ;
   A . 'VAR' . 1 . 'VALEUR' = 1. ;
   A . 'COF' . 1 . 'COMPOR' = mcm ;
   A . 'COF' . 1 . 'LDAT' = lvid ;
   A . 1 . 1 . 0 = 'LECT' 1 ;
   numdat = 0 ;
   numcof = 0 ;
   B = ININLIN numop numvar numdat numcof numder ;
   B . 'VAR' . 1 . 'NOMDDL' = 'MOTS' 'DUMM' ;
   B . 'VAR' . 1 . 'DISC'   = 'CSTE' ;
   B . 'VAR' . 1 . 'VALEUR' = 1. ;
   B . 1 . 1 . 0 = lvid ;
   cpo = NLIN gdisc _mt A B 'ERF1' methgau ;
   cpo = 'NOMC' (tnom . &itm) cpo ;
   idx = '+' idx 1 ;
   tchpo . idx = cpo ;
'FIN' itm ;
imet = 'ET' tchpo ;
'RESPRO' imet ;
*
* End of procedure file CALIMET
*
'FINPROC' ;
*ENDPROCEDUR calimet
*BEGINPROCEDUR defdd
************************************************************************
* NOM         : DEFDD
* DESCRIPTION :
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, ??/??/2007, version initiale
* HISTORIQUE : v1, ??/??/2007, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' DEFDD ;
*'ARGUMENT' _cmt*'MAILLAGE' ;
*'ARGUMENT' cmt*'MAILLAGE' ;
*'ARGUMENT' sur*'MAILLAGE' ;
'ARGUMENT' tdisc*'TABLE' ;
'ARGUMENT' idir/'ENTIER' ;
'SI' ('NON' ('EXISTE' idir)) ;
   idir = 0 ;
'FINSI' ;
*
NOMDEP = @STBL (TDISC . 'XN' . 'NOMINC') ;
*
vdim = 'VALEUR' 'DIME' ;
DISCG  = TDISC . 'GEOM' . 'DISC' ;
_hau = tdisc . 'hau' . 'QUAF' ;
hau = tdisc . 'hau' . discg ;
   vnor  = GNOR _hau tdisc 'NPRI' discg 'FPRI' 1. 'NDUA' 'XN' ;
*   'SI' ('EGA' vdim 3) ;
*      vnor = '*' vnor -1. ;
*   'FINSI' ;
   vnorn = '/' vnor ('**' ('PSCAL' vnor vnor nomdep nomdep) 0.5 ) ;
*   trvec hau vnorn 'Vnorn' ;
*  Correction de vnorn aux extrémités
   phau = 'CHANGER' 'POI1' hau ;
   'SI' ('EGA' idir 0) ;
      'SI' ('EGA' vdim 2) ;
         mcorr = ('POIN' hau 'INITIAL')
             'ET' ('POIN' hau 'FINAL') ;
      'SINON' ;
         bhau = tdisc . 'bhau' . discg ;
*         mcorr = 'CONTOUR' sur ;
*---------------pour 3D
         mcorr = bhau ;
*         'TRACER' (hau 'ET' ('COULEUR' bhau roug)) ;
      'FINSI' ;
   'SINON' ;
      mcorr = hau ;
   'FINSI' ;
   pmcorr = 'CHANGER' 'POI1' mcorr ;
   phaur = 'DIFF' phau pmcorr ;
   vnorn1 = 'REDU' vnorn phaur ;
   vvn = 'PROG' vdim * 0. ;
   'REMPLACER' vvn vdim 1. ;
*   vnorn2 = 'MANUEL' 'CHPO' mcorr 2 'UX' 0. 'UY' 1. ;
*   'LISTE' nomdep ;
*   'LISTE' vvn ;
   vnorn2 = 'MANUEL' 'CHPO' mcorr nomdep vvn ;
   vnorn = vnorn1 '+' vnorn2 ;
*   trvec hau vnorn 'Vnorn2' ;
'RESPRO' vnorn ;
'FINPROC' ;
*
* End of procedure file DEFDD
*
*ENDPROCEDUR defdd
*BEGINPROCEDUR defdfors
************************************************************************
* NOM         : DEFDFORS
* DESCRIPTION :
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, ??/??/2007, version initiale
* HISTORIQUE : v1, ??/??/2007, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' DEFDFORS ;
'ARGUMENT' rmax/'FLOTTANT' ;
'ARGUMENT' lnclk/'LOGIQUE' ;
*
'SI' ('NON' ('EXISTE' lnclk)) ;
   lnclk = FAUX ;
'FINSI' ;
      gmabs = gmass2 _hau tdisc 'NPRI' discv 'NDUA' discv ;
   'SI' tbfor ;
      fblob
      desfb fvolb =
         REDUS hau
         fblonn
         desfd fpvolnn ;
      fblol
      desfl fvoll =
         KRESS gmabs
         fblob
      desfb fvolb ;
   'SINON' ;
      fblob
      fgrab fsurb fforb
      desfb fvolb =
         REDUS hau
         fblonn
         fgrann fsurnn ffornn
         desfd fpvolnn ;
      fblol
      fgral fsurl fforl
      desfl fvoll =
         KRESS gmabs
         fblob
         fgrab fsurb fforb
      desfb fvolb ;
   'FINSI' ;
   ihau = 'INVERSE' hau ;
      i=0 ;
      tabev = 'TABLE' ;
      tabt  = 'TABLE' ;
      i = '+' i 1 ;
      tabev . i = 'EVOL' 'CHPO' fblol 'SCAL' ihau ;
      tabt  . i = 'CHAINE' 'Fint' ;
      'SI' ('NON' tbfor) ;
         i = '+' i 1 ;
         tabev . i = 'EVOL' 'CHPO' fgral 'SCAL' ihau ;
         tabt  . i = 'CHAINE' 'RhoG' ;
         i = '+' i 1 ;
         tabev . i = 'EVOL' 'CHPO' fsurl 'SCAL' ihau ;
         tabt  . i = 'CHAINE' 'Tsurf' ;
         i = '+' i 1 ;
         tabev . i = 'EVOL' 'CHPO' fforl 'SCAL' ihau ;
         tabt  . i = 'CHAINE' 'SouP' ;
      'FINSI' ;
      i = '+' i 1 ;
      tabev . i = 'EVOL' 'CHPO' desfl 'SCAL' ihau ;
      tabt  . i = 'CHAINE' 'DES' ;
      i = '+' i 1 ;
      tabev . i = 'EVOL' 'CHPO' fvoll 'SCAL' ihau ;
      tabt  . i = 'CHAINE' 'Incomp.' ;
      tix = 's' ; tiy = 'FY' ; tit = 'CHAINE' tiy '(' tix ')' ;
      'SI' ('EXISTE' rmax) ;
         binf = '-' lav rmax ;
         bsup = '+' lav rmax ;
         dessevol (@STBL tabev) tabt tit tix tiy
            ('PROG' binf bsup) lnclk ;
      'SINON' ;
         dessevol (@STBL tabev) tabt tit tix tiy
            lnclk ;
      'FINSI' ;
*'RESPRO' ..... ;
*
* End of procedure file DEFDFORS
*
'FINPROC' ;
*ENDPROCEDUR defdfors
*BEGINPROCEDUR defmail
************************************************************************
* NOM         : DEFMAIL
* DESCRIPTION :
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 27/01/2011, version initiale
* HISTORIQUE : v1, 27/01/2011, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' DEFMAIL ;
'ARGUMENT' rsou*'FLOTTANT' ;
'ARGUMENT' lav*'FLOTTANT' ;
'ARGUMENT' lap*'FLOTTANT' ;
'ARGUMENT' prof*'FLOTTANT' ;
'ARGUMENT' raff*'ENTIER' ;
*
tdisc = JETMOD ;
vdim = 'VALEUR' 'DIME' ;
raf2 = '*' 2 raff ;
raf4 = '*' 4 raff ;
raf8 = '*' 8 raff ;
raf16 = '*' 16 raff ;
raf32 = '*' 32 raff ;
*
dr = '/' rsou raff ;
dav = '/' lav raff ;
dap = '/' lap raff ;
drp = '/' prof raff ;
*
mlav = '*' lav -1. ;
mrsou = '*' rsou -1. ;
mprof = '*' prof -1. ;
'SI' ('EGA' vdim 2) ;
   pA = mlav mprof ; pB = mrsou mprof ; pC = 0. mprof ;
   pD = rsou mprof ; pE = lap mprof ;
*pJ = mlav 0. ; pII = mrsou 0. ; pH =  0. -0.5 ;
   pJ = mlav 0. ; pII = mrsou 0. ; pH =  0. 0. ;
   pG = rsou 0. ; pF = lap 0. ;
*
   lAB = 'DROIT' pA pB 'DINI' dav 'DFIN' dr ;
   lBC = 'DROIT' pB pC 'DINI' dr 'DFIN' dr ;
   lCD = 'DROIT' pC pD 'DINI' dr 'DFIN' dr ;
   lDE = 'DROIT' pD pE 'DINI' dr 'DFIN' dap ;
   lEF = 'DROIT' pE pF 'DINI' drp 'DFIN' dr ;
   lFG = 'DROIT' pF pG 'DINI' dap 'DFIN' dr ;
   lGH = 'DROIT' pG pH 'DINI' dr 'DFIN' dr ;
   lHII = 'DROIT' pH pII 'DINI' dr 'DFIN' dr ;
   lIIJ = 'DROIT' pII pJ 'DINI' dr 'DFIN' dav ;
   lJA = 'DROIT' pJ pA 'DINI' dr 'DFIN' drp ;
*
   bas = lAB 'ET' lBC 'ET' lCD 'ET' lDE ;
   dro = lEF ;
   hau = LFG 'ET' lGH 'ET' lHII 'ET' lIIJ ;
   gau = lJA ;
   mtw = 'DALLER' bas dro hau gau ;
   cmtw = 'CONTOUR' mtw ;
*'TRACER' mtw ;
*
   _bas _dro _hau _gau _cmtw _mtw =
   QUAFME bas dro hau gau cmtw mtw ;
   'ELIMINATION'
   (_bas 'ET' _dro 'ET' _hau 'ET' _gau
         'ET' _cmtw 'ET' _mtw)
         (1.D-5 '*' rsou) ;
'FINSI' ;
'SI' ('EGA' vdim 3) ;
   pA = mlav 0. mprof ; pB = mrsou 0. mprof ; pC = 0. 0. mprof ;
   pD = rsou 0. mprof ; pE = lap 0. mprof ;
*pJ = mlav 0. ; pII = mrsou 0. ; pH =  0. -0.5 ;
   pJ = mlav 0. 0. ; pII = mrsou 0. 0. ; pH =  0. 0. 0. ;
   pG = rsou 0. 0. ; pF = lap 0. 0. ;
*
   lAB = 'DROIT' pA pB 'DINI' dav 'DFIN' dr ;
   lBC = 'DROIT' pB pC 'DINI' dr 'DFIN' dr ;
   lCD = 'DROIT' pC pD 'DINI' dr 'DFIN' dr ;
   lDE = 'DROIT' pD pE 'DINI' dr 'DFIN' dap ;
   lEF = 'DROIT' pE pF 'DINI' drp 'DFIN' dr ;
   lFG = 'DROIT' pF pG 'DINI' dap 'DFIN' dr ;
   lGH = 'DROIT' pG pH 'DINI' dr 'DFIN' dr ;
   lHII = 'DROIT' pH pII 'DINI' dr 'DFIN' dr ;
   lIIJ = 'DROIT' pII pJ 'DINI' dr 'DFIN' dav ;
   lJA = 'DROIT' pJ pA 'DINI' dr 'DFIN' drp ;
*
   bas2 = lAB 'ET' lBC 'ET' lCD 'ET' lDE ;
   dro2 = lEF ;
   hau2 = LFG 'ET' lGH 'ET' lHII 'ET' lIIJ ;
   gau2 = lJA ;
   fro  = 'DALLER' bas2 dro2 hau2 gau2 ;
   dhau = 'INVERSE' hau2 ;
*   cmtw2 = 'CONTOUR' mtw2 ;
*
   vtran = 0. lav 0. ;
*   vtran = 0. ('*' rsou 2.) 0. ;
   pH2   = 'PLUS' pH (0. rsou 0.) ;
   pH3   = 'PLUS' pH vtran ;
   lgen1 = 'DROIT' pH  pH2 'DINI' dr 'DFIN' dr  ;
   lgen2 = 'DROIT' pH2 pH3 'DINI' dr 'DFIN' dav ;
   lgen  = lgen1 'ET' lgen2 ;
*   lgen  = 'DROIT' 1 pH pH3 ;
*
   rea = 'PLUS' fro vtran ;
   bas = 'GENERATRICE' bas2 lgen ;
   dro = 'GENERATRICE' dro2 lgen ;
   hau = 'GENERATRICE' hau2 lgen ;
   gau = 'GENERATRICE' gau2 lgen ;
   mtw = 'VOLUME' fro 'GENE' lgen ;
   cmtw = 'ENVELOPPE' mtw ;
   pint = 0. rsou ('/' mprof 2.) ;
   cmtw = 'ORIENTER' cmtw 'POIN' pint ;
   bhau1 = lgen 'PLUS' pJ ;
   bhau2 = lgen 'PLUS' pF ;
   bhau  = bhau1 'ET' bhau2 ;
*
*   'TRACER' mtw ;
*
   _bas _dro _hau _dhau _bhau _gau _fro _rea _cmtw _mtw =
   QUAFME bas dro hau dhau bhau gau fro rea cmtw mtw ;
   'ELIMINATION'
   (_bas 'ET' _dro 'ET' _hau 'ET' _dhau 'ET' _bhau 'ET' _gau
         'ET' _fro 'ET' _rea 'ET' _cmtw 'ET' _mtw)
         (1.D-5 '*' rsou) ;
'FINSI' ;
*
*   vnor  = GNOR _cmtw tdisc 'NPRI' discg 'FPRI' 1. 'NDUA' 'XN' ;
*   NOMDEP = @STBL (TDISC . 'XN' . 'NOMINC') ;
*   vnorn = '/' vnor ('**' ('PSCAL' vnor vnor nomdep nomdep) 0.5 ) ;
*   trvec cmtw vnorn 'Vnorn' ;
*
tdisc . 'mtw' = 'TABLE' ;
tdisc . 'mtw' .'QUAF' = _mtw ; tdisc . 'mtw' .'LINE' = mtw ;
tdisc . 'cmtw' = 'TABLE' ;
tdisc . 'cmtw' .'QUAF' = _cmtw ; tdisc . 'cmtw' .'LINE' = cmtw ;
tdisc . 'bas' = 'TABLE' ;
tdisc . 'bas' .'QUAF' = _bas ; tdisc . 'bas' .'LINE' = bas ;
tdisc . 'dro' = 'TABLE' ;
tdisc . 'dro' .'QUAF' = _dro ; tdisc . 'dro' .'LINE' = dro ;
tdisc . 'hau' = 'TABLE' ;
tdisc . 'hau' .'QUAF' = _hau ; tdisc . 'hau' .'LINE' = hau ;
tdisc . 'gau' = 'TABLE' ;
tdisc . 'gau' .'QUAF' = _gau ; tdisc . 'gau' .'LINE' = gau ;
'SI' ('EGA' vdim  3) ;
   tdisc . 'fro' = 'TABLE' ;
   tdisc . 'fro' .'QUAF' = _fro ; tdisc . 'fro' .'LINE' = fro ;
   tdisc . 'rea' = 'TABLE' ;
   tdisc . 'rea' .'QUAF' = _rea ; tdisc . 'rea' .'LINE' = rea ;
   tdisc . 'dhau' = 'TABLE' ;
   tdisc . 'dhau' .'QUAF' = _dhau ; tdisc . 'dhau' .'LINE' = dhau ;
   tdisc . 'bhau' = 'TABLE' ;
   tdisc . 'bhau' .'QUAF' = _bhau ; tdisc . 'bhau' .'LINE' = bhau ;
'FINSI' ;
*
'RESPRO' tdisc ;
*
* End of procedure file DEFMAIL
*
'FINPROC' ;
*ENDPROCEDUR defmail
*BEGINPROCEDUR defqfors
************************************************************************
* NOM         : DEFQFORS
* DESCRIPTION :
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, ??/??/2007, version initiale
* HISTORIQUE : v1, ??/??/2007, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' DEFQFORS ;
'ARGUMENT' rmax/'FLOTTANT' ;
'ARGUMENT' lnclk/'LOGIQUE' ;
*
'SI' ('NON' ('EXISTE' lnclk)) ;
   lnclk = FAUX ;
'FINSI' ;
      gmabs = gmass2 _hau tdisc 'NPRI' discv 'NDUA' discv ;
   'SI' tbfor ;
      fpreb frigb fugrb desfb
      fpgrab ftsurb fpforb
*      ftanrb
      fblonb fbloxb fbloyb =
         REDUS hau
         fpre frig fugr desfq
         fpgra ftsur fpfor
*         ftanr
         fblon fblox fbloy ;
   'SINON' ;
      fpreb frigb fugrb desfb
      fblonb fbloxb fbloyb =
         REDUS hau
         fpre frig fugr desfq
         fblon fblox fbloy ;
   'FINSI' ;
      vnor = DEFDD tdisc 0 ;
*
*  Décomposition en composante normale et tangentielle
*
   'SI' tbfor ;
      fpren fpret frign frigt fugrn fugrt desfn desft
      fgran fgrat fsurn fsurt fforn ffort
*      ftanrn ftanrt
      fblonn fblont fbloxn fbloxt fbloyn fbloyt
      = NORTANS vnor
         fpreb frigb fugrb desfb
         fpgra ftsur fpfor
*         ftanr
         fblonb fbloxb fbloyb ;
*
      fpren fpret frign frigt fugrn fugrt desfn desft
      fgran fgrat fsurn fsurt fforn ffort
*      ftanrn ftanrt
      fblonn fblont fbloxn fbloxt fbloyn fbloyt
      = KRESS gmabs
         fpren fpret frign frigt fugrn fugrt desfn desft
         fgran fgrat fsurn fsurt fforn ffort
*         ftanrn ftanrt
         fblonn fblont fbloxn fbloxt fbloyn fbloyt
         ;
   'SINON' ;
      fpren fpret frign frigt fugrn fugrt desfn desft
      fblonn fblont fbloxn fbloxt fbloyn fbloyt
      = NORTANS vnor
         fpreb frigb fugrb desfb
         fblonb fbloxb fbloyb ;
*
      fpren fpret frign frigt fugrn fugrt desfn desft
      fblonn fblont fbloxn fbloxt fbloyn fbloyt
      = KRESS gmabs
         fpren fpret frign frigt fugrn fugrt desfn desft
         fblonn fblont fbloxn fbloxt fbloyn fbloyt
         ;
   'FINSI' ;
   ihau = 'INVERSE' hau ;
      i=0 ;
      tabev = 'TABLE' ;
      tabt  = 'TABLE' ;
      i = '+' i 1 ;
      tabev . i = 'EVOL' 'CHPO' fpret 'SCAL' ihau ;
      tabt  . i = 'CHAINE' 'GradP' ;
      i = '+' i 1 ;
      tabev . i = 'EVOL' 'CHPO' frigt 'SCAL' ihau ;
      tabt  . i = 'CHAINE' 'LapnU' ;
      i = '+' i 1 ;
      tabev . i = 'EVOL' 'CHPO' fugrt 'SCAL' ihau ;
      tabt  . i = 'CHAINE' 'UgradU' ;
      i = '+' i 1 ;
      tabev . i = 'EVOL' 'CHPO' desft 'SCAL' ihau ;
      tabt  . i = 'CHAINE' 'DES' ;
      'SI' tbfor ;
         i = '+' i 1 ;
         tabev . i = 'EVOL' 'CHPO' fgrat 'SCAL' ihau ;
         tabt  . i = 'CHAINE' 'Gravi' ;
         i = '+' i 1 ;
         tabev . i = 'EVOL' 'CHPO' fsurt 'SCAL' ihau ;
         tabt  . i = 'CHAINE' 'T. Sur' ;
         i = '+' i 1 ;
         tabev . i = 'EVOL' 'CHPO' ffort 'SCAL' ihau ;
         tabt  . i = 'CHAINE' 'Sou. Pr' ;
*         i = '+' i 1 ;
*         tabev . i = 'EVOL' 'CHPO' ftanrt 'SCAL' ihau ;
*         tabt  . i = 'CHAINE' 'Sor. lib.' ;
      'FINSI' ;
      i = '+' i 1 ;
      tabev . i = 'EVOL' 'CHPO' fblont 'SCAL' ihau ;
      tabt  . i = 'CHAINE' 'BlocN' ;
      i = '+' i 1 ;
      tabev . i = 'EVOL' 'CHPO' fbloxt 'SCAL' ihau ;
      tabt  . i = 'CHAINE' 'BlocX' ;
      i = '+' i 1 ;
      tabev . i = 'EVOL' 'CHPO' fbloyt 'SCAL' ihau ;
      tabt  . i = 'CHAINE' 'BlocY' ;
      tix = 's' ; tiy = 'Ftan' ; tit = 'CHAINE' tiy '(' tix ')' ;
      'SI' ('EXISTE' rmax) ;
         binf = '-' lav rmax ;
         bsup = '+' lav rmax ;
         dessevol (@STBL tabev) tabt tit tix tiy
            ('PROG' binf bsup) lnclk ;
      'SINON' ;
         dessevol (@STBL tabev) tabt tit tix tiy
            lnclk ;
      'FINSI' ;
      i=0 ;
      tabev = 'TABLE' ;
      tabt  = 'TABLE' ;
      i = '+' i 1 ;
      tabev . i = 'EVOL' 'CHPO' fpren 'SCAL' ihau ;
      tabt  . i = 'CHAINE' 'GradP' ;
      i = '+' i 1 ;
      tabev . i = 'EVOL' 'CHPO' frign 'SCAL' ihau ;
      tabt  . i = 'CHAINE' 'LapnU' ;
      i = '+' i 1 ;
      tabev . i = 'EVOL' 'CHPO' fugrn 'SCAL' ihau ;
      tabt  . i = 'CHAINE' 'UgradU' ;
      i = '+' i 1 ;
      tabev . i = 'EVOL' 'CHPO' desfn 'SCAL' ihau ;
      tabt  . i = 'CHAINE' 'DES' ;
      'SI' tbfor ;
         i = '+' i 1 ;
         tabev . i = 'EVOL' 'CHPO' fgran 'SCAL' ihau ;
         tabt  . i = 'CHAINE' 'RhoG' ;
         i = '+' i 1 ;
         tabev . i = 'EVOL' 'CHPO' fsurn 'SCAL' ihau ;
         tabt  . i = 'CHAINE' 'Tsurf' ;
         i = '+' i 1 ;
         tabev . i = 'EVOL' 'CHPO' fforn 'SCAL' ihau ;
         tabt  . i = 'CHAINE' 'Sou. P' ;
*         i = '+' i 1 ;
*         tabev . i = 'EVOL' 'CHPO' ftanrn 'SCAL' ihau ;
*         tabt  . i = 'CHAINE' 'Sor. lib.' ;
      'FINSI' ;
      i = '+' i 1 ;
      tabev . i = 'EVOL' 'CHPO' fblonn 'SCAL' ihau ;
      tabt  . i = 'CHAINE' 'BlocN' ;
      i = '+' i 1 ;
      tabev . i = 'EVOL' 'CHPO' fbloxn 'SCAL' ihau ;
      tabt  . i = 'CHAINE' 'BlocX' ;
      i = '+' i 1 ;
      tabev . i = 'EVOL' 'CHPO' fbloyn 'SCAL' ihau ;
      tabt  . i = 'CHAINE' 'BlocY' ;
      tix = 's' ; tiy = 'Fnor' ; tit = 'CHAINE' tiy '(' tix ')' ;
      'SI' ('EXISTE' rmax) ;
         binf = '-' lav rmax ;
         bsup = '+' lav rmax ;
         dessevol (@STBL tabev) tabt tit tix tiy
            ('PROG' binf bsup) lnclk ;
      'SINON' ;
         dessevol (@STBL tabev) tabt tit tix tiy
            lnclk ;
      'FINSI' ;
*
* End of procedure file DEFQFORS
*
'FINPROC' ;
*ENDPROCEDUR defqfors
*BEGINPROCEDUR defsumm
************************************************************************
* NOM         : DEFSUMM
* DESCRIPTION :
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, ??/??/2007, version initiale
* HISTORIQUE : v1, ??/??/2007, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' DEFSUMM ;
'MESSAGE' ('CHAINE' 'Parametres physiques :') ;
'MESSAGE' ('CHAINE' '**********************') ;
*
'MESSAGE' ('CHAINE' 'Parametres adimensionnels :') ;
'MESSAGE' ('CHAINE' '***************************') ;
'MESSAGE' ('CHAINE' ' Nombre dEuler           = ' (formar Eu 3)) ;
'MESSAGE' ('CHAINE' ' Nombre de Reynolds      = ' (formar Re 3)) ;
'MESSAGE' ('CHAINE' ' Nombre de Froude*Euler  = ' (formar FrEu 3)) ;
'MESSAGE' ('CHAINE' ' Nombre de Weber         = ' (formar We 3)) ;
'MESSAGE' ('CHAINE' 'Numérique :') ;
'MESSAGE' ('CHAINE' '-----------') ;
'MESSAGE' ('CHAINE' 'raff=' raff
   ' nelem= ' ('NBEL' mtw) ' npo= ' ('NBNO' mtw)) ;
'MESSAGE' ('CHAINE' 'itcou= ' itcou ' nitermax=' nitermax) ;
'MESSAGE' ('CHAINE' 'nitn= ' nitn ' omegn=' (formar omegn 2)) ;
'MESSAGE' ('CHAINE' 'omegd=' (formar omegd 2)) ;
'MESSAGE' ('CHAINE' 'nomdir=' nomdir) ;
'MESSAGE' ('CHAINE' 'nomfic=' nomfic) ;
*
* End of procedure file DEFSUMM
*
'FINPROC' ;
*ENDPROCEDUR defsumm
*BEGINPROCEDUR defvsurf
************************************************************************
* NOM         : DEFVSURF
* DESCRIPTION :
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, ??/??/2007, version initiale
* HISTORIQUE : v1, ??/??/2007, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' DEFVSURF ;
'ARGUMENT' rmax/'FLOTTANT' ;
'ARGUMENT' lnclk/'LOGIQUE' ;
*
'SI' ('NON' ('EXISTE' lnclk)) ;
   lnclk = FAUX ;
'FINSI' ;
vdim = 'VALEUR' 'DIME' ;
'SI' ('EGA' vdim 2) ;
      ihau = 'INVERSE' hau ;
'SINON' ;
      ihau = dhau ;
'FINSI' ;
      i=0 ;
      tabev = 'TABLE' ;
      tabt  = 'TABLE' ;
      i = '+' i 1 ;
      rhau = 'EXTRAIRE' ('EVOL' 'CHPO' ('COORDONNEE' 1 hau) 'SCAL' ihau)
         'ORDO' ;
      hv = 'REDU' vit ihau ;
NOMDEP = @STBL (TDISC . 'XN' . 'NOMINC') ;
      nhv = '**' ('PSCAL' vit vit nomdep nomdep) 0.5  ;
      zhau = 'EXTRAIRE' ('EVOL' 'CHPO' nhv 'SCAL' ihau)   'ORDO' ;
      tabev . i = 'EVOL' 'MANU' rhau zhau ;
      tabt  . i = 'CHAINE' '|V| surf' ;
      tix = 's' ; tiy = '|V|' ; tit = 'CHAINE' tiy '(' tix ')' ;
      'SI' ('EXISTE' rmax) ;
         binf = '-' 0. rmax ;
         bsup = '+' 0. rmax ;
         dessevol (@STBL tabev) tabt tit tix tiy
            ('PROG' binf bsup) lnclk ;
      'SINON' ;
         dessevol (@STBL tabev) tabt tit tix tiy
            lnclk ;
      'FINSI' ;
*'SINON' ;
*   'SI' ('EXISTE' rmax) ;
*      xhau = 'COORDONNEE' 1 hau ;
*      yhau = 'COORDONNEE' 2 hau ;
*      rhau = '**' ('+' ('**' xhau 2) ('**' yhau 2)) 0.5 ;
*      phau = 'POIN' rhau 'INFERIEUR' rmax ;
*      redhau = 'ELEM' hau 'APPUYE' 'LARGEMENT' phau ;
*   'SINON' ;
*      redhau = hau ;
*   'FINSI' ;
*   'SI' lnclk ;
*      'TRACER' 'CACH' redhau 'TITR' 'Surface' 'NCLK' ;
*   'SINON' ;
*      'TRACER' 'CACH' redhau 'TITR' 'Surface' 'NCLK' ;
*   'FINSI' ;
*'FINSI' ;
*
* End of procedure file DEFVSURF
*
'FINPROC' ;
*ENDPROCEDUR defvsurf
*BEGINPROCEDUR defzsurf
************************************************************************
* NOM         : DEFZSURF
* DESCRIPTION :
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, ??/??/2007, version initiale
* HISTORIQUE : v1, ??/??/2007, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' DEFZSURF ;
'ARGUMENT' rmax/'FLOTTANT' ;
'ARGUMENT' lnclk/'LOGIQUE' ;
*
'SI' ('NON' ('EXISTE' lnclk)) ;
   lnclk = FAUX ;
'FINSI' ;
vdim = 'VALEUR' 'DIME' ;
'SI' ('EGA' vdim 2) ;
      ihau = 'INVERSE' hau ;
'SINON' ;
      ihau = dhau ;
'FINSI' ;
      i=0 ;
      tabev = 'TABLE' ;
      tabt  = 'TABLE' ;
      i = '+' i 1 ;
      rhau = 'EXTRAIRE' ('EVOL' 'CHPO' ('COORDONNEE' 1 hau) 'SCAL' ihau)
         'ORDO' ;
      zhau = 'EXTRAIRE' ('EVOL' 'CHPO' ('COORDONNEE' vdim hau)
         'SCAL' ihau)   'ORDO' ;
      tabev . i = 'EVOL' 'MANU' rhau zhau ;
      tabt  . i = 'CHAINE' 'z surf' ;
      tix = 's' ; tiy = 'z' ; tit = 'CHAINE' tiy '(' tix ')' ;
      'SI' ('EXISTE' rmax) ;
         binf = '-' 0. rmax ;
         bsup = '+' 0. rmax ;
         dessevol (@STBL tabev) tabt tit tix tiy
            ('PROG' binf bsup) lnclk ;
      'SINON' ;
         dessevol (@STBL tabev) tabt tit tix tiy
            lnclk ;
      'FINSI' ;
*'SINON' ;
*   'SI' ('EXISTE' rmax) ;
*      xhau = 'COORDONNEE' 1 hau ;
*      yhau = 'COORDONNEE' 2 hau ;
*      rhau = '**' ('+' ('**' xhau 2) ('**' yhau 2)) 0.5 ;
*      phau = 'POIN' rhau 'INFERIEUR' rmax ;
*      redhau = 'ELEM' hau 'APPUYE' 'LARGEMENT' phau ;
*   'SINON' ;
*      redhau = hau ;
*   'FINSI' ;
*   'SI' lnclk ;
*      'TRACER' 'CACH' redhau 'TITR' 'Surface' 'NCLK' ;
*   'SINON' ;
*      'TRACER' 'CACH' redhau 'TITR' 'Surface' 'NCLK' ;
*   'FINSI' ;
*'FINSI' ;
*
* End of procedure file DEFZSURF
*
'FINPROC' ;
*ENDPROCEDUR defzsurf
*BEGINPROCEDUR dessevol
************************************************************************
* NOM         : DESSEVOL
* DESCRIPTION : Dessine des évolutions : choisit automatiquement
*               les options, marqueurs, couleurs...
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 16/11/2004, version initiale
* HISTORIQUE : v1, 16/11/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' DESSEVOL ;
'ARGUMENT' evtot*'EVOLUTION' ;
'ARGUMENT' tabt*'TABLE' ;
'ARGUMENT' tit*'MOT' ;
'ARGUMENT' tix*'MOT' ;
'ARGUMENT' tiy*'MOT' ;
'ARGUMENT' lnclk/'LOGIQUE' ;
'ARGUMENT' nb/'ENTIER' ;
'ARGUMENT' lx/'LISTREEL' ;
*
'SI' ('NON' ('EXISTE' lnclk)) ;
   lnclk = FAUX ;
'FINSI' ;
*
* nb = 0 : noir et blanc
* nb = 1 : couleur
* nb = 2 : couleur + marqueurs
* nb = 3 : couleur + marqueurs + tirets
* nb = 4 : couleur + marqueurs regu
* nb = 5 : couleur + marqueurs regu + tirets
* nb = 6 : nb + marqueurs regu + tirets
* nb = 7 : nb + marqueurs
* nb = 8 : nb + marqueurs regu
*
'SI' ('NON' ('EXISTE' nb)) ;
   nb = 3 ;
'FINSI' ;
*
nt  = 'DIME' tabt ;
nev = 'DIME' evtot ;
*
* Attention, dans evtot, il y a une évolution avec des noms de points ?
*
*'SI' ('NEG' nev nt) ;
*   cherr = 'CHAINE' 'Evolution and title table : not same dim.' ;
*   'ERREUR' cherr ;
*'FINSI' ;
*
tev = 'TABLE' ;
tev . 'TITRE' = tabt ;
*
toto = 'TABLE' ;
*
*lcoul = 'MOTS' 'TURQ' 'VERT' 'JAUN' 'ROSE' 'ROUG' 'BLEU' ;
'SI' ('EGA' ('VALEUR' 'TRAC') 'PSC') ;
   lcoul = 'MOTS' 'BLEU' 'ROUG' 'VERT' 'VIOL' 'OLIV' 'ORAN'  ;
'SINON' ;
   lcoul = 'MOTS' 'TURQ' 'VERT' 'JAUN' 'ROSE' 'ROUG' 'BLEU' ;
'FINSI' ;
lmarq = 'MOTS' 'TRID' 'TRIU' 'LOSA' 'CARR' 'ETOI' 'PLUS' 'CROI'
               'TRIL' 'TRIR' ;
ltirr = 'MOTS' 'TIRR' 'TIRC' 'TIRL' 'TIRM' ;
*
lnb = 'LECT' 0 6 7 8 ;
*'SI' ('OU' ('EGA' nb 0) ('EGA' nb 6)) ;
'SI' (dans ('LECT' nb) lnb) ;
   ev2 = evtot ;
'SINON' ;
   icou = 0 ;
   'REPETER' iev nev ;
      ii = &iev ;
      evi = 'EXTRAIRE' evtot 'COUR' ii ;
      'SI' ('NEG' ('TYPE' ('EXTRAIRE' evi 'ORDO')) 'LISTMOTS') ;
         icou = '+' icou 1 ;
      'FINSI' ;
*      ii2 = '/' ('+' ii 1) 2 ;
*      ci  = EXMOMOD lcoul ii2 ;
*      ci  = EXMOMOD lcoul ii ;
      ci  = EXMOMOD lcoul icou ;
      APPEND toto 'EVOLUTION' ('COULEUR' evi ci) ;
   'FIN' iev ;
   ev2 = toto . 'EVOLUTION' ;
'FINSI' ;
*
'REPETER' iev nev ;
   ii = &iev ;
   mi = EXMOMOD lmarq ii ;
   ti = EXMOMOD ltirr ii ;
   'SI' ('OU' ('EGA' nb 2) ('EGA' nb 7)) ;
      tev . ii = 'CHAINE' 'MARQ ' mi ;
   'FINSI' ;
   'SI' ('EGA' nb 3) ;
      tev . ii = 'CHAINE' 'MARQ ' mi ' ' ti ;
   'FINSI' ;
   'SI' ('OU' ('EGA' nb 4) ('EGA' nb 8)) ;
      tev . ii = 'CHAINE' 'MARQ ' mi ' REGU' ;
   'FINSI' ;
   'SI' ('OU' ('EGA' nb 5) ('EGA' nb 6)) ;
      tev . ii = 'CHAINE' 'MARQ ' mi ' ' ti ' REGU' ;
   'FINSI' ;
'FIN' iev ;
*
'SI' ('EXISTE' lx) ;
   dim4 = 'EGA' ('DIME' lx) 4 ;
   xmin = 'EXTRAIRE' lx 1 ; xmax = 'EXTRAIRE' lx 2 ;
   'SI' dim4 ;
      ymin = 'EXTRAIRE' lx 3 ; ymax = 'EXTRAIRE' lx 4 ;
   'FINSI' ;
   'SI' dim4 ;
   'SI' lnclk ;
      'DESSIN' ev2 'TITR' tit 'TITX' tix 'TITY' tiy 'LEGE' 'MIMA' tev
      'XBOR' xmin xmax 'YBOR' ymin ymax 'NCLK' motopt ;
   'SINON' ;
      'DESSIN' ev2 'TITR' tit 'TITX' tix 'TITY' tiy 'LEGE' 'MIMA' tev
      'XBOR' xmin xmax 'YBOR' ymin ymax motopt ;
   'FINSI' ;
   'SINON' ;
   'SI' lnclk ;
      'DESSIN' ev2 'TITR' tit 'TITX' tix 'TITY' tiy 'LEGE' 'MIMA' tev
      'XBOR' xmin xmax 'NCLK' motopt ;
   'SINON' ;
      'DESSIN' ev2 'TITR' tit 'TITX' tix 'TITY' tiy 'LEGE' 'MIMA' tev
      'XBOR' xmin xmax motopt ;
   'FINSI' ;
   'FINSI' ;
'SINON' ;
   'SI' lnclk ;
      'DESSIN' ev2 'TITR' tit 'TITX' tix 'TITY' tiy 'LEGE' 'MIMA' tev
      'NCLK' motopt ;
   'SINON' ;
      'DESSIN' ev2 'TITR' tit 'TITX' tix 'TITY' tiy 'LEGE' 'MIMA' tev
      motopt ;
   'FINSI' ;
'FINSI' ;
*
* End of procedure file DESSEVOL
*
'FINPROC' ;
*ENDPROCEDUR dessevol
*BEGINPROCEDUR errrel
************************************************************************
* NOM         : ERRREL
* DESCRIPTION : Calcul d'une erreur relative
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 23/04/2003, version initiale
* HISTORIQUE : v1, 23/04/2003, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' ERRREL ;
'ARGUMENT' val*'FLOTTANT' ;
'ARGUMENT' valref*'FLOTTANT' ;
*
'SI' ('<' ('ABS' valref) 1.D-10) ;
   echref = 1.D0 ;
'SINON' ;
   echref = valref ;
'FINSI' ;
*
errabs = 'ABS' ('/' ('-' val valref) echref);
*
'RESPRO' errabs ;
*
* End of procedure file ERRREL
*
'FINPROC' ;
*ENDPROCEDUR errrel
*BEGINPROCEDUR exmomod
************************************************************************
* NOM         : EXMOMOD
* DESCRIPTION : Extraction d'un mot d'un listmots
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 23/06/2003, version initiale
* HISTORIQUE : v1, 23/06/2003, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' EXMOMOD ;
'ARGUMENT' lm*'LISTMOTS' i*'ENTIER' ;
j = 'DIME' lm ;
k = '+' (MODULO ('-' i 1) j) 1 ;
lemot = 'EXTRAIRE' lm k ;
* Usage de l'opérateur text pour éviter que lemot
* ne soit interprété comme un opérateur
'RESPRO' 'TEXTE' lemot ;
*
* End of procedure file EXMOMOD
*
'FINPROC' ;
*ENDPROCEDUR exmomod
*BEGINPROCEDUR formar
************************************************************************
* NOM         : FORMAR
* DESCRIPTION : formate un réel de facon courte
*               pratique pour les noms de
*               sauvegarde
*               Exemples :
* 'MESSAGE' ('CHAINE' (formar 2.9e5   1)) ;
* 2.9E5
* 'MESSAGE' ('CHAINE' (formar -2.9e5  1)) ;
* -2.9E5
* 'MESSAGE' ('CHAINE' (formar 2.9e-5  1)) ;
* 2.9E-5
* 'MESSAGE' ('CHAINE' (formar -2.9e-5 1)) ;
* -2.9E-5
* 'MESSAGE' ('CHAINE' (formar 2.9     1)) ;
* 2.9
* 'MESSAGE' ('CHAINE' (formar -2.9    1)) ;
* -2.9
* 'MESSAGE' ('CHAINE' (formar 0       1)) ;
* 0
* 'MESSAGE' ('CHAINE' (formar 0       1)) ;
* 0
* 'MESSAGE' ('CHAINE' (formar 2.9e5   0)) ;
* 3E5
* 'MESSAGE' ('CHAINE' (formar -2.9e5  0)) ;
* -3E5
* 'MESSAGE' ('CHAINE' (formar 2.9e-5  0)) ;
* 3E-5
* 'MESSAGE' ('CHAINE' (formar -2.9e-5 0)) ;
* -3E-5
* 'MESSAGE' ('CHAINE' (formar 2.9     0)) ;
* 3
* 'MESSAGE' ('CHAINE' (formar -2.9    0)) ;
* -3
* 'MESSAGE' ('CHAINE' (formar 0       0)) ;
* 0
* 'MESSAGE' ('CHAINE' (formar 0       0)) ;
* 0
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 18/02/2003, version initiale
* HISTORIQUE : v1, 18/02/2003, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' FORMAR ;
'ARGUMENT' fl*'FLOTTANT' ;
'ARGUMENT' vir/'ENTIER  ' ;
'SI' ('NON' ('EXISTE' vir)) ;
   vir = 1 ;
'SINON' ;
   'SI' ('<' vir 0) ;
      'ERREUR' 'fournir un entier positif' ;
   'FINSI' ;
'FINSI' ;
'SI' ('<' ('ABS' fl) 10.D-100) ;
   chfl = 'CHAINE' '0' ;
'SINON' ;
*! sans le 1.D-10, ca ne fonctionne pas
*! qd on entre pile poil une puissance de 10
   lfl = LOG10 ('ABS' fl) ;
*   lfl = '+' (LOG10 ('ABS' fl)) 1.D-10  ;
   slfl = 'SIGNE' ('ENTIER' lfl) ;
   'SI' ('EGA' slfl 1) ;
      elfl = 'ENTIER' lfl ;
   'SINON' ;
      elfl = '-' ('ENTIER' lfl) 1 ;
   'FINSI' ;
   man = '/' fl ('**' 10.D0 elfl) ;
*
* Une verrue pour des histoires de précision...
*
   'SI' ('EGA' man 10.D0 ('**' 10.D0 ('*' vir -1.D0))) ;
      man  = '/' man 10.D0 ;
      elfl = '+' elfl 1 ;
   'FINSI' ;
*
   sman = 'SIGNE' man ;
   'SI' ('EGA' sman 1) ;
      fman = 'CHAINE' '(F' ('+' vir 2) '.0' vir ')' ;
   'SINON' ;
      fman = 'CHAINE' '(F' ('+' vir 3) '.0' vir ')' ;
   'FINSI' ;
   'SI' ('NEG' vir 0) ;
      'SI' ('NEG' elfl 0) ;
         chfl = 'CHAINE' 'FORMAT' fman man 'E' elfl ;
      'SINON' ;
         chfl = 'CHAINE' 'FORMAT' fman man ;
      'FINSI' ;
   'SINON' ;
      man2 = 'ENTIER' ('+' man ('*' 0.5D0 sman)) ;
      'SI' ('NEG' elfl 0) ;
         chfl = 'CHAINE' man2 'E' elfl ;
      'SINON' ;
         chfl = 'CHAINE' man2 ;
      'FINSI' ;
   'FINSI' ;
'FINSI' ;
'RESPRO' chfl ;
*
* End of procedure file FORMAR
*
'FINPROC' ;
*ENDPROCEDUR formar
*BEGINPROCEDUR gchpo
************************************************************************
* NOM         : GCHPO
* DESCRIPTION : Une matrice de masse
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v2, 14/03/2006, mise à jour NLIN évolué
* VERSION    : v1, 13/05/2004, version initiale
* HISTORIQUE : v1, 13/05/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' GCHPO ;
'ARGUMENT'     _mt*'MAILLAGE' ;
'ARGUMENT'    nomq*'MOT     ' ;
'ARGUMENT'    coef*'FLOTTANT' ;
*
'SI' ('EGA' discq 'LINM') ;
   discq = 'CSTE' ;
'FINSI' ;
*
idim = DEADUTIL 'DIMM' _mt ;
vdim = 'VALEUR' 'DIME' ;
*
discg = TDISC . 'GEOM' . 'DISC' ;
tnomq = TDISC . nomq ;
*
ms = tnomq . 'NOMINC' . 1 ;
numop = 1 ; numder = idim ; numvar = 1 ; numdat = 0 ; numcof = 0 ;
A = ININLIN numop numvar numdat numcof numder ;
A . 'VAR' . 1 . 'NOMDDL' = 'MOTS' 'DUMM' ;
A . 'VAR' . 1 . 'DISC'   = 'CSTE' ;
A . 'VAR' . 1 . 'VALEUR' = 0. ;
*
A . 1 . 1 . 0 = 'LECT' ;
*
B = ININLIN numop numvar numdat numcof numder ;
B . 'VAR' . 1 . 'NOMDDL' = ms ;
B . 'VAR' . 1 . 'DISC'   = tnomq . 'DISC' ;
*
B . 1 . 1 . 0 = 'LECT' ;
*
mgchpos = '+' (NLIN discg _mt A B 'ERF1' 'GAU7') coef ;
*
mgchpo = 'NOMC' ms (tnomq . 'NOMINC' . 1) mgchpos ;
*
ninc = 'DIME' (tnomq . 'NOMINC') ;
'SI' ('>' ninc 1) ;
   'REPETER' iinc ('-' ninc 1) ;
      mgchpo = '+' mgchpo
         ('NOMC' ms (tnomq . 'NOMINC' . ('+' &iinc 1)) mgchpos) ;
   'FIN' iinc ;
'FINSI' ;
*
'RESPRO' mgchpo ;
'FINPROC' ;
*
* End of procedure file GCHPO
*
*ENDPROCEDUR gchpo
*BEGINPROCEDUR gdiv2
************************************************************************
* NOM         : GDIV2
* DESCRIPTION : Une matrice de masse
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v2, 14/03/2006, mise à jour NLIN évolué
* VERSION    : v1, 13/05/2004, version initiale
* HISTORIQUE : v1, 13/05/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' GDIV2 ;
'ARGUMENT'     _mt*'MAILLAGE' ;
'ARGUMENT'     _smt/'MAILLAGE' ;
'ARGUMENT' tdisc*'TABLE' ;
*
* Lectures
*
debug = FAUX ;
lmotcle = 'MOTS' 'NPRI' 'FPRI' 'CPRI' 'NDUA' 'FDUA' 'CDUA'
                 'NCOF' 'FCOF' 'CCOF' 'GBBT' 'GMBT' ;
* Il faut initialiser valt et valq, sinon on peut capturer ceux de
* la procédure appelante
valt = 'valt' ; valq = 'valq' ;
lbbt = 0 ;
*
'REPETER' imotcle ;
   'ARGUMENT' motcle/'MOT' ;
   'SI' ('NON' ('EXISTE' motcle)) ; 'QUITTER' imotcle ; 'FINSI' ;
   'SI' ('NON' ('EXISTE' lmotcle motcle)) ;
      cherr = 'CHAINE' 'Keyword ' motcle ' unknown.' ; 'ERREUR' cherr ;
   'FINSI' ;
   'SI' ('EGA' motcle 'NPRI') ; 'ARGUMENT' nomt*'MOT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'NDUA') ; 'ARGUMENT' nomq*'MOT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'NCOF') ; 'ARGUMENT' nomo*'MOT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'FPRI') ; 'ARGUMENT' valt*'LISTREEL' ; 'FINSI' ;
   'SI' ('EGA' motcle 'FDUA') ; 'ARGUMENT' valq*'FLOTTANT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'FCOF') ; 'ARGUMENT' valo*'FLOTTANT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'CPRI') ; 'ARGUMENT' valt*'CHPOINT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'CDUA') ; 'ARGUMENT' valq*'CHPOINT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'CCOF') ; 'ARGUMENT' valo*'CHPOINT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'GBBT') ; lbbt = 1 ; 'FINSI' ;
   'SI' ('EGA' motcle 'GMBT') ; lbbt = 2 ; 'FINSI' ;
'FIN' imotcle ;
*
* Tests
*
discg = TDISC . 'GEOM' . 'DISC' ;
'SI' ('EXISTE' tdisc 'methgau') ;
   methgau = tdisc . 'methgau' . 'amor' ;
'SINON' ;
   methgau = 'GAU7' ;
'FINSI' ;
tnomt = TDISC . nomt ;
lvalt = 'NEG' ('TYPE' valt) 'MOT' ;
tnomq = TDISC . nomq ;
lvalq = 'NEG' ('TYPE' valq) 'MOT' ;
*
lcof = 'EXISTE' TDISC nomo ;
'SI' lcof ; ncof = 1 ; tcof = TDISC . nomo ;
'SINON' ; ncof = 0 ;
'FINSI' ;
*
'SI' debug ;
'SI' lcof ; 'MESSAGE' 'Un coef a ete detecte' ;
'SINON' ; 'MESSAGE' 'pas de coef  detecte' ;
'FINSI' ;
'FINSI' ;
*
   vdim = 'VALEUR' 'DIME' ;
   vmod = 'VALEUR' 'MODE' ;
   idim = 0 ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'PLANDEFO')) ;
      idim = 2 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'AXIS')) ;
      idim = 2 ;
      iaxi = VRAI ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 3) ('EGA' vmod 'TRID')) ;
      idim = 3 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' vdim 1) ;
      idim = 1 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' idim 0) ;
      'ERREUR' ('CHAINE' 'vmod=' vmod ' et vdim=' vdim ' non prevu') ;
   'FINSI' ;
   'SI' iaxi ;
      dp = ('*' PI 2.D0) ;
      rmt = 'COORDONNEE' 1 _mt ;
      ncof = ncof '+' 2 ;
   'FINSI' ;
* Scalaire ou vecteur
ninct = 'DIME' (tnomt . 'NOMINC') ;
nincq = 'DIME' (tnomq . 'NOMINC') ;
'SI' ('NEG' ninct idim) ;
   cherr = 'CHAINE'
   'la primale doit etre un vecteur' ;
   'ERREUR' cherr ;
'FINSI' ;
'SI' ('NEG' nincq 1) ;
   cherr = 'CHAINE'
   'la duale doit etre un scalaire' ;
   'ERREUR' cherr ;
'FINSI' ;
*
   numop = 1 ; numder = idim ; numvar = ninct ;
   numdat = ncof ; numcof = ncof ;
   A = ININLIN numop numvar numdat numcof numder ;
*
   lvt = 'EGA' ('TYPE' valt) 'LISTREEL' ;
   'REPETER' iiinct ninct ;
      iinct = &iiinct ;
      A . 'VAR' . iinct . 'NOMDDL' = tnomt . 'NOMINC' . iinct ;
      A . 'VAR' . iinct . 'DISC'   = tnomt . 'DISC'  ;
      'SI' lvalt ;
         'SI' lvt ;
            A . 'VAR' . iinct . 'VALEUR'   = 'EXTRAIRE' valt iinct ;
         'SINON' ;
            A . 'VAR' . iinct . 'VALEUR'   = valt ;
         'FINSI' ;
      'FINSI' ;
   'FIN' iiinct ;
*
   icof = 0 ;
   'SI' lcof ;
      icof = '+' icof 1 ;
      A . 'DAT' . icof . 'NOMDDL' = tcof . 'NOMINC' . 1 ;
      A . 'DAT' . icof . 'DISC'   = tcof . 'DISC' ;
      A . 'DAT' . icof . 'VALEUR' = valo ;
      A . 'COF' . icof . 'COMPOR' = 'IDEN' ;
      A . 'COF' . icof . 'LDAT'   = 'LECT' icof ;
      ll = 'LECT' 1 ;
   'SINON' ;
      ll = 'LECT' ;
   'FINSI' ;
*
   'SI' iaxi ;
      icof = '+' icof 1 ;
      A . 'DAT' . icof . 'NOMDDL' = 'MOTS' 'SCAL' ;
      A . 'DAT' . icof . 'DISC'   = 'CSTE' ;
      A . 'DAT' . icof . 'VALEUR' = dp ;
      A . 'COF' . icof . 'COMPOR' = 'IDEN' ;
      A . 'COF' . icof . 'LDAT'   = 'LECT' icof ;
      icof = '+' icof 1 ;
      A . 'DAT' . icof . 'NOMDDL' = 'MOTS' 'SCAL' ;
      A . 'DAT' . icof . 'DISC'   = discg ;
      A . 'DAT' . icof . 'VALEUR' = rmt ;
      A . 'COF' . icof . 'COMPOR' = 'IDEN' ;
      A . 'COF' . icof . 'LDAT'   = 'LECT' icof ;
      lldpr = ll 'ET' ('LECT' ('-' icof 1) icof) ;
      lldp = ll 'ET' ('LECT' ('-' icof 1)) ;
   'FINSI' ;
*
   'SI' iaxi ;
      'REPETER' iidim idim ;
         A . 1 . &iidim . &iidim  = lldpr ;
      'FIN' iidim ;
      A . 1 . 1 . 0 = lldp ;
   'SINON' ;
      'REPETER' iidim idim ;
         A . 1 . &iidim . &iidim  = ll ;
      'FIN' iidim ;
   'FINSI' ;
*
   numvar = 1 ;
   numdat = 0 ;
   numcof = 0 ;
*
   B = ININLIN numop numvar numdat numcof numder ;
   B . 'VAR' . 1 . 'NOMDDL' = tnomq . 'NOMINC' . 1 ;
   B . 'VAR' . 1 . 'DISC'   = tnomq . 'DISC'  ;
   'SI' lvalq ;
      B . 'VAR' . 1 . 'VALEUR'   = valq ;
   'FINSI' ;
   B . 1 . 1 . 0  = 'LECT' ;
*
   'SI' ('OU' ('EGA' lbbt 0) ('EGA' lbbt 1)) ;
      'SI' ('EXISTE' _smt) ;
          mgdiv2 = 'NLIN' discg _mt _smt A B methgau ;
      'SINON' ;
          mgdiv2 = NLINP discg _mt A B methgau ;
      'FINSI' ;
      'SI' ('EGA' lbbt 1) ;
         'SI' ('EXISTE' _smt) ;
             mgdiv3 = 'NLIN' discg _mt _smt B A methgau ;
         'SINON' ;
             mgdiv3 = NLINP discg _mt B A methgau ;
         'FINSI' ;
         mgdiv2 = 'ET' mgdiv2 mgdiv3 ;
      'FINSI' ;
   'FINSI' ;
   'SI' ('EGA' lbbt 2) ;
      'SI' ('EXISTE' _smt) ;
          mgdiv2 = 'NLIN' discg _mt _smt B A methgau ;
      'SINON' ;
          mgdiv2 = NLINP discg _mt B A methgau ;
      'FINSI' ;
   'FINSI' ;
*
'RESPRO' mgdiv2 ;
'FINPROC' ;
*
* End of procedure file GDIV2
*
*ENDPROCEDUR gdiv2
*BEGINPROCEDUR getcoo
************************************************************************
* NOM         : GETCOO
* DESCRIPTION :
* Renvoie les coordonnées des points dans un champ type déplacement
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 22/04/2011, version initiale
* HISTORIQUE : v1, 22/04/2011, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
*
*
'DEBPROC' GETCOO ;
'ARGUMENT' mail*'MAILLAGE' ;
'ARGUMENT' incop*'LISTMOTS' ;
*
dim = 'VALEUR' 'DIME' ;
'REPETER' iidim dim ;
   idim= &iidim ;
   icoo = 'NOMC' ('EXTRAIRE' incop idim)
                 ('COORDONNEE' idim mail) ;
   'SI' ('EGA' idim 1) ;
      vcoo = icoo ;
   'SINON' ;
      vcoo = 'ET' vcoo icoo ;
   'FINSI' ;
'FIN' iidim ;
'RESPRO' vcoo ;
*
* End of procedure file GETCOO
*
'FINPROC' ;
*ENDPROCEDUR getcoo
*BEGINPROCEDUR gforc
************************************************************************
* NOM         : GFORC
* DESCRIPTION : Calcul de la force associée à une pression imposée
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, ??/??/2007, version initiale
* HISTORIQUE : v1, ??/??/2007, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' GFORC ;
'ARGUMENT' _surf*'MAILLAGE' ;
'ARGUMENT' tdisc*'TABLE' ;
'ARGUMENT' pfor*'CHPOINT' ;
*
vdim = 'VALEUR' 'DIME' ;
DISCG  = TDISC . 'GEOM' . 'DISC' ;
fpfor = GNOR _surf tdisc 'NPRI' discg 'CPRI' pfor 'NDUA' 'XN' ;
'RESPRO' fpfor ;
*
* End of procedure file GFORC
*
'FINPROC' ;
*ENDPROCEDUR gforc
*BEGINPROCEDUR ggravi
************************************************************************
* NOM         : GGRAVI
* DESCRIPTION : Calcul de la force associée au potentiel gravitaire
*               (\rho g z si g vertical)
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 22/04/2011
* HISTORIQUE : v1, 22/04/2011, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
*
*
'DEBPROC' GGRAVI ;
'ARGUMENT' _surf*'MAILLAGE' ;
'ARGUMENT' tdisc*'TABLE' ;
'ARGUMENT' coef*'FLOTTANT' ;
'ARGUMENT' ang*'FLOTTANT' ;
*
vdim = 'VALEUR' 'DIME' ;
pgrax  = '*' ('COORDONNEE' 1 _surf) ('*' +1. ('SIN' ang)) ;
pgraz  = '*' ('COORDONNEE' vdim _surf) ('*' -1. ('COS' ang)) ;
DISCG  = TDISC . 'GEOM' . 'DISC' ;
fpgrax = GNOR _surf tdisc 'NPRI' discg 'CPRI' pgrax 'NDUA' 'XN' ;
fpgraz = GNOR _surf tdisc 'NPRI' discg 'CPRI' pgraz 'NDUA' 'XN' ;
fpgra = '+' fpgrax fpgraz ;
fpgra = '*' fpgra ('*' -1. coef) ;
'RESPRO' fpgra ;
*
* End of procedure file GGRAVI
*
'FINPROC' ;
*ENDPROCEDUR ggravi
*BEGINPROCEDUR gkforc
************************************************************************
* NOM         : GKFORC
* DESCRIPTION : Calcul de la matrice tangente associée à la force
*               de pression imposée. Cette matrice tangente est
*               partielle car elle ne prend en compte que le gradient
*               surfacique de pression. On peut difficilement
*               faire autrement si on ne considère que la surface.
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, ??/??/2007, version initiale
* HISTORIQUE : v1, ??/??/2007, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' GKFORC ;
'ARGUMENT' _surf*'MAILLAGE' ;
'ARGUMENT' tdisc*'TABLE' ;
'ARGUMENT' pfor*'CHPOINT' ;
'ARGUMENT' ijaco/'ENTIER' ;
'SI' ('NON' ('EXISTE' ijaco)) ;
   ijaco = 0 ;
'FINSI' ;
vdim = 'VALEUR' 'DIME' ;
DISCG  = TDISC . 'GEOM' . 'DISC' ;
*fpfor = GNOR _surf tdisc 'NPRI' discg 'CPRI' pfor 'NDUA' 'XN' ;
   k1 = GNORGC _surf tdisc 'NPRI' 'XN'
                             'NCOF' discg 'CCOF' pfor
                             'NDUA' 'XN' ;
*   k1 = GNOR _surf tdisc 'NPRI' discg 'NDUA' 'XN' ;
*   k1 = '*' k1 -1. ;
*   k1 = 'CHANGER' 'INCO' k1 ('MOTS' 'SCAL')
*            ('MOTS' ('EXTRAIRE' NOMVIT vdim)) NOMVIT NOMVIT ;
   k2 = GNORKTAN _surf tdisc 'NPRI' 'XN'
        'NCOF' discg 'CCOF' pfor 'NDUA' 'XN' ;
   'SI' ('OU' ('EGA' ijaco 0) ('EGA' ijaco 3)) ;
      ktfor = k1 'ET' k2 ;
   'FINSI' ;
   'SI' ('EGA' ijaco 1) ;
      ktfor = k1 ;
   'FINSI' ;
   'SI' ('EGA' ijaco 2) ;
      ktfor = k2 ;
   'FINSI' ;
   ktfor = '*' ktfor -1. ;
'RESPRO' ktfor ;
*
* End of procedure file GKFORC
*
'FINPROC' ;
*ENDPROCEDUR gkforc
*BEGINPROCEDUR gkgravi
************************************************************************
* NOM         : GKGRAVI
* DESCRIPTION : Calcul de la matrice tangente de la force
*               associée au potentiel gravitaire (calculée par GGRAVI)
*               en fonction des déplacements des points de la surface.
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 22/04/2011
* HISTORIQUE : v1, 22/04/2011, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
*
*
'DEBPROC' GKGRAVI ;
'ARGUMENT' _surf*'MAILLAGE' ;
'ARGUMENT' tdisc*'TABLE' ;
'ARGUMENT' ijaco*'ENTIER' ;
*'SI' ('NON' ('EXISTE' ijaco)) ;
*   ijaco = 0 ;
*'FINSI' ;
'ARGUMENT' coef*'FLOTTANT' ;
'ARGUMENT' ang*'FLOTTANT' ;
*
vdim = 'VALEUR' 'DIME' ;
pgrax  = '*' ('COORDONNEE' 1 _surf) ('*' +1. ('SIN' ang)) ;
pgraz  = '*' ('COORDONNEE' vdim _surf) ('*' -1. ('COS' ang)) ;
*pgra  = '*' ('-' ('COORDONNEE' vdim _surf) H) -1. ;
*pgra  = '*' ('COORDONNEE' vdim _surf) -1. ;
DISCG  = TDISC . 'GEOM' . 'DISC' ;
NOMDEP = @STBL (TDISC . 'XN' . 'NOMINC') ;
*fpgra = GNOR _surf tdisc 'NPRI' discg 'CPRI' pgra 'NDUA' 'XN' ;
   k1x = GNOR _surf tdisc 'NPRI' discg 'NDUA' 'XN' ;
   k1x = '*' k1x ('*' +1. ('SIN' ang)) ;
   k1x = 'CHANGER' 'INCO' k1x ('MOTS' 'SCAL')
            ('MOTS' ('EXTRAIRE' NOMDEP 1)) NOMDEP NOMDEP ;
   k2x = GNORKTAN _surf tdisc 'NPRI' 'XN'
        'NCOF' discg 'CCOF' pgrax 'NDUA' 'XN' ;
   k1z = GNOR _surf tdisc 'NPRI' discg 'NDUA' 'XN' ;
   k1z = '*' k1z ('*' -1. ('COS' ang)) ;
   k1z = 'CHANGER' 'INCO' k1z ('MOTS' 'SCAL')
            ('MOTS' ('EXTRAIRE' NOMDEP vdim)) NOMDEP NOMDEP ;
   k2z = GNORKTAN _surf tdisc 'NPRI' 'XN'
        'NCOF' discg 'CCOF' pgraz 'NDUA' 'XN' ;
   'SI' ('EGA' ijaco 0) ;
      ktgra = k1x 'ET' k1z 'ET' k2x 'ET' k2z ;
   'FINSI' ;
   'SI' ('EGA' ijaco 1) ;
      ktgra = k1x 'ET' k1z ;
   'FINSI' ;
   'SI' ('EGA' ijaco 2) ;
      ktgra = k2x 'ET' k2z ;
   'FINSI' ;
   ktgra = '*' ktgra coef ;
'RESPRO' ktgra ;
*
* End of procedure file GKGRAVI
*
'FINPROC' ;
*ENDPROCEDUR gkgravi
*BEGINPROCEDUR gkvol
************************************************************************
* NOM         : GKVOL
* DESCRIPTION : Matrice tangente associée à la variation du volume
*               contenu dans une surface (calculé par GVOL)
*               en fonction des déplacements des points de la surface.
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 22/04/2011, version initiale
* HISTORIQUE : v1, 22/04/2011, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
*
*
'DEBPROC' GKVOL ;
'ARGUMENT' _surf*'MAILLAGE' ;
'ARGUMENT' tdisc*'TABLE' ;
'ARGUMENT' ijaco/'ENTIER' ;
'SI' ('NON' ('EXISTE' ijaco)) ;
   ijaco = 0 ;
'FINSI' ;
*  Vecteur position et calcul du volume
NOMVIT = @STBL (TDISC . 'XN' . 'NOMINC') ;
DISCG  = TDISC . 'GEOM' . 'DISC' ;
vdim = 'VALEUR' 'DIME' ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'AXIS')) ;
      fdim = 3 ;
   'SINON' ;
      fdim = vdim ;
   'FINSI' ;
   vpos = GETCOO _surf nomvit ;
   kvol1 = GNOR _surf tdisc 'NPRI' ('CHAINE' discg 'V')
                             'NDUA' 'XN' 'FDUA' ('PROG' vdim * 1.) ;
   kvol2 = GNORKTAN _surf tdisc 'NPRI' ('CHAINE' discg 'V')
            'NCOF' ('CHAINE' discg 'V') 'CCOF' vpos
            'NDUA' 'XN' 'FDUA' ('PROG' vdim * 1.) ;
   'SI' ('EGA' ijaco 0) ;
      kvol = '/' ('+' kvol1 kvol2) fdim ;
   'FINSI' ;
   'SI' ('EGA' ijaco 1) ;
      kvol = '/' kvol1 fdim ;
   'FINSI' ;
   'SI' ('EGA' ijaco 2) ;
      kvol = '/' kvol2 fdim ;
   'FINSI' ;
'RESPRO' kvol ;
*
* End of procedure file GKVOL
*
'FINPROC' ;
*ENDPROCEDUR gkvol
*BEGINPROCEDUR gmail
************************************************************************
* NOM         : GMAIL
* DESCRIPTION : Une matrice de masse
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v2, 14/03/2006, mise à jour NLIN évolué
* VERSION    : v1, 13/05/2004, version initiale
* HISTORIQUE : v1, 13/05/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' GMAIL ;
'ARGUMENT'     _mt*'MAILLAGE' ;
'ARGUMENT'    nomq*'MOT     ' ;
*
gm = GCHPO _mt nomq 1. ;
dom = 'EXTRAIRE' gm 'MAIL' ;
*
'RESPRO' dom ;
'FINPROC' ;
*
* End of procedure file GMAIL
*
*ENDPROCEDUR gmail
*BEGINPROCEDUR gmass2
************************************************************************
* NOM         : GMASS2
* DESCRIPTION : Une matrice de masse
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v2, 14/03/2006, mise à jour NLIN évolué
* VERSION    : v1, 13/05/2004, version initiale
* HISTORIQUE : v1, 13/05/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' GMASS2 ;
'ARGUMENT'     _mt*'MAILLAGE' ;
'ARGUMENT'     _smt/'MAILLAGE' ;
'ARGUMENT' tdisc*'TABLE' ;
*
* Lectures
*
debug = FAUX ;
lmotcle = 'MOTS' 'NPRI' 'FPRI' 'CPRI' 'NDUA' 'FDUA' 'CDUA'
                 'NCOF' 'FCOF' 'CCOF' ;
* Il faut initialiser valt et valq, sinon on peut capturer ceux de
* la procédure appelante
valt = 'valt' ; valq = 'valq' ;
'REPETER' imotcle ;
   'ARGUMENT' motcle/'MOT' ;
   'SI' ('NON' ('EXISTE' motcle)) ; 'QUITTER' imotcle ; 'FINSI' ;
   'SI' ('NON' ('EXISTE' lmotcle motcle)) ;
      cherr = 'CHAINE' 'Keyword ' motcle ' unknown.' ; 'ERREUR' cherr ;
   'FINSI' ;
   'SI' ('EGA' motcle 'NPRI') ; 'ARGUMENT' nomt*'MOT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'NDUA') ; 'ARGUMENT' nomq*'MOT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'NCOF') ; 'ARGUMENT' nomo*'MOT' ; 'FINSI' ;
   tst1 = 'EGA' motcle 'FPRI' ; tst2 = 'EGA' motcle 'FDUA' ;
   tst = tst1 'OU' tst2 ;
   'SI' tst ;
      'SI' tst1 ; tt = TDISC . nomt ; 'FINSI' ;
      'SI' tst2 ; tt = TDISC . nomq ; 'FINSI' ;
      isvec = ('>' ('DIME' (tt. 'NOMINC')) 1) ;
      'SI' isvec ; 'ARGUMENT' valv*'LISTREEL' ; 'SINON' ;
         'ARGUMENT' valv*'FLOTTANT' ;
      'FINSI' ;
      'SI' tst1 ; valt = valv ; 'FINSI' ;
      'SI' tst2 ; valq = valv ; 'FINSI' ;
   'FINSI' ;
   'SI' ('EGA' motcle 'FCOF') ; 'ARGUMENT' valo*'FLOTTANT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'CPRI') ; 'ARGUMENT' valt*'CHPOINT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'CDUA') ; 'ARGUMENT' valq*'CHPOINT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'CCOF') ; 'ARGUMENT' valo*'CHPOINT' ; 'FINSI' ;
'FIN' imotcle ;
*
* Tests
*
discg = TDISC . 'GEOM' . 'DISC' ;
'SI' ('EXISTE' tdisc 'methgau') ;
   methgau = tdisc . 'methgau' . 'mass' ;
'SINON' ;
   methgau = 'GAU7' ;
'FINSI' ;
tnomt = TDISC . nomt ;
lvalt = 'NEG' ('TYPE' valt) 'MOT' ;
tnomq = TDISC . nomq ;
lvalq = 'NEG' ('TYPE' valq) 'MOT' ;
* Scalaire ou vecteur
ninct = 'DIME' (tnomt . 'NOMINC') ;
nincq = 'DIME' (tnomq . 'NOMINC') ;
'SI' ('NEG' ninct nincq) ;
   cherr = 'CHAINE'
   'les primales et duales nont pas le meme nombre de composantes' ;
   'ERREUR' cherr ;
'FINSI' ;
ninc = ninct ;
*
lcof = 'EXISTE' TDISC nomo ;
'SI' lcof ; ncof = 1 ; tcof = TDISC . nomo ;
'SINON' ; ncof = 0 ;
'FINSI' ;
*
'SI' debug ;
'SI' lcof ; 'MESSAGE' 'Un coef a ete detecte' ;
'SINON' ; 'MESSAGE' 'pas de coef  detecte' ;
'FINSI' ;
'FINSI' ;
*
   vdim = 'VALEUR' 'DIME' ;
   vmod = 'VALEUR' 'MODE' ;
   idim = 0 ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'PLANDEFO')) ;
      idim = 2 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'AXIS')) ;
      idim = 2 ;
      iaxi = VRAI ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 3) ('EGA' vmod 'TRID')) ;
      idim = 3 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' vdim 1) ;
      idim = 1 ;
      iaxi = FAUX ;
   'FINSI' ;
*   'MESSAGE' ('CHAINE' 'iaxi=' iaxi );
   'SI' ('EGA' idim 0) ;
      'ERREUR' ('CHAINE' 'vmod=' vmod ' et vdim=' vdim ' non prevu') ;
   'FINSI' ;
   'SI' iaxi ;
      dprmt = '*' ('COORDONNEE' 1 _mt) ('*' PI 2.D0) ;
   'FINSI' ;
*
* Optimisation possible : construire la matrice par blocs
* qd valt et valq ne sont pas donnés
*
   numop = ninc ; numder = idim ; numvar = ninc ;
   numdat = ncof ; numcof = ncof ;
   A = ININLIN numop numvar numdat numcof numder ;
   'SI' lcof ;
      A . 'DAT' . 1 . 'NOMDDL' = tcof . 'NOMINC' . 1 ;
      A . 'DAT' . 1 . 'DISC'   = tcof . 'DISC' ;
      A . 'DAT' . 1 . 'VALEUR' = valo ;
      A . 'COF' . 1 . 'COMPOR' = 'IDEN' ;
      A . 'COF' . 1 . 'LDAT'   = 'LECT' 1 ;
      ll = 'LECT' 1 ;
   'SINON' ;
      ll = 'LECT' ;
   'FINSI' ;
   lvt = 'EGA' ('TYPE' valt) 'LISTREEL' ;
   'REPETER' iiinc ninc ;
      iinc = &iiinc ;
      A . 'VAR' . iinc . 'NOMDDL' = tnomt . 'NOMINC' . iinc ;
      A . 'VAR' . iinc . 'DISC'   = tnomt . 'DISC'  ;
      'SI' lvalt ;
         'SI' lvt ;
            A . 'VAR' . iinc . 'VALEUR'   = 'EXTRAIRE' valt iinc ;
         'SINON' ;
            A . 'VAR' . iinc . 'VALEUR'   = valt ;
         'FINSI' ;
      'FINSI' ;
      A . iinc . iinc . 0  = ll ;
   'FIN' iiinc ;
*
   'SI' iaxi ;
      numdat = 1 ;
      numcof = 1 ;
   'SINON' ;
      numdat = 0 ;
      numcof = 0 ;
   'FINSI' ;
   B = ININLIN numop numvar numdat numcof numder ;
   'SI' iaxi ;
      B . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
      B . 'DAT' . 1 . 'DISC'   = discg ;
      B . 'DAT' . 1 . 'VALEUR' = dprmt ;
      B . 'COF' . 1 . 'COMPOR' = 'IDEN' ;
      B . 'COF' . 1 . 'LDAT'   = 'LECT' 1 ;
      ll = 'LECT' 1 ;
   'SINON' ;
      ll = 'LECT' ;
   'FINSI' ;
   lvq = 'EGA' ('TYPE' valq) 'LISTREEL' ;
   'REPETER' iiinc ninc ;
      iinc = &iiinc ;
      B . 'VAR' . iinc . 'NOMDDL' = tnomq . 'NOMINC' . iinc ;
      B . 'VAR' . iinc . 'DISC'   = tnomq . 'DISC'  ;
      'SI' lvalq ;
         'SI' lvq ;
            B . 'VAR' . iinc . 'VALEUR'   = 'EXTRAIRE' valq iinc ;
         'SINON' ;
            B . 'VAR' . iinc . 'VALEUR'   = valq ;
         'FINSI' ;
      'FINSI' ;
      B . iinc . iinc . 0  = ll ;
   'FIN' iiinc ;
*
   'SI' ('EXISTE' _smt) ;
       mgmass2 = 'NLIN' discg _mt _smt A B methgau ;
   'SINON' ;
       mgmass2 = NLINP discg _mt A B methgau ;
   'FINSI' ;
*
'RESPRO' mgmass2 ;
'FINPROC' ;
*
* End of procedure file GMASS2
*
*ENDPROCEDUR gmass2
*BEGINPROCEDUR gnorgc
************************************************************************
* NOM         : GNORGC
* DESCRIPTION : Une matrice de masse
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v2, 14/03/2006, mise à jour NLIN évolué
* VERSION    : v1, 13/05/2004, version initiale
* HISTORIQUE : v1, 13/05/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' GNORGC ;
'ARGUMENT'     _mt*'MAILLAGE' ;
'ARGUMENT' tdisc*'TABLE' ;
*
* Lectures
*
vdim = 'VALEUR' 'DIME' ;
debug = FAUX ;
lmotcle = 'MOTS' 'NPRI' 'FPRI' 'CPRI' 'NDUA' 'FDUA' 'CDUA'
                 'NCOF' 'FCOF' 'CCOF' ;
* Il faut initialiser valt et valq, sinon on peut capturer ceux de
* la procédure appelante
valt = 'valt' ; valq = 'valq' ;
'REPETER' imotcle ;
   'ARGUMENT' motcle/'MOT' ;
   'SI' ('NON' ('EXISTE' motcle)) ; 'QUITTER' imotcle ; 'FINSI' ;
   'SI' ('NON' ('EXISTE' lmotcle motcle)) ;
      cherr = 'CHAINE' 'Keyword ' motcle ' unknown.' ; 'ERREUR' cherr ;
   'FINSI' ;
   'SI' ('EGA' motcle 'NPRI') ; 'ARGUMENT' nomt*'MOT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'NDUA') ; 'ARGUMENT' nomq*'MOT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'NCOF') ; 'ARGUMENT' nomo*'MOT' ; 'FINSI' ;
   tst1 = 'EGA' motcle 'FPRI' ; tst2 = 'EGA' motcle 'FDUA' ;
   tst3 = 'EGA' motcle 'FCOF' ;
   tst = tst1 'OU' tst2 'OU' tst3 ;
   'SI' tst ;
      'SI' tst1 ; tt = TDISC . nomt ; 'FINSI' ;
      'SI' tst2 ; tt = TDISC . nomq ; 'FINSI' ;
      'SI' tst3 ; tt = TDISC . nomo ; 'FINSI' ;
      isvec = ('>' ('DIME' (tt. 'NOMINC')) 1) ;
      'SI' isvec ; 'ARGUMENT' valv*'LISTREEL' ; 'SINON' ;
         'ARGUMENT' valv*'FLOTTANT' ;
      'FINSI' ;
      'SI' tst1 ; valt = valv ; 'FINSI' ;
      'SI' tst2 ; valq = valv ; 'FINSI' ;
      'SI' tst3 ; valo = valv ; 'FINSI' ;
   'FINSI' ;
   'SI' ('EGA' motcle 'CPRI') ; 'ARGUMENT' valt*'CHPOINT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'CDUA') ; 'ARGUMENT' valq*'CHPOINT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'CCOF') ; 'ARGUMENT' valo*'CHPOINT' ; 'FINSI' ;
'FIN' imotcle ;
*
* Tests
*
discg = TDISC . 'GEOM' . 'DISC' ;
'SI' ('EXISTE' tdisc 'methgau') ;
   methgau = tdisc . 'methgau' . 'mass' ;
'SINON' ;
   methgau = 'GAU7' ;
'FINSI' ;
tnomt = TDISC . nomt ;
lvalt = 'NEG' ('TYPE' valt) 'MOT' ;
tnomq = TDISC . nomq ;
lvalq = 'NEG' ('TYPE' valq) 'MOT' ;
* Scalaire ou vecteur
ninct = 'DIME' (tnomt . 'NOMINC') ;
nincq = 'DIME' (tnomq . 'NOMINC') ;
'SI' ('NEG' ninct vdim) ;
   cherr = 'CHAINE'
   'la primale doit etre un vecteur' ;
   'ERREUR' cherr ;
'FINSI' ;
'SI' ('NEG' nincq vdim) ;
   cherr = 'CHAINE'
   'la duale doit etre un vecteur' ;
   'ERREUR' cherr ;
'FINSI' ;
*ninc = ninct ;
*
lcof = 'EXISTE' TDISC nomo ;
'SI' lcof ; tcof = TDISC . nomo ;
ncof = 'DIME' (tcof . 'NOMINC') ;
'SINON' ; ncof = 0 ;
'FINSI' ;
'SI' ('NEG' ncof 1) ;
   cherr = 'CHAINE'
   'il faut un coefficient scalaire' ;
   'ERREUR' cherr ;
'FINSI' ;
*
'SI' debug ;
'SI' lcof ; 'MESSAGE' 'Un coef a ete detecte' ;
'SINON' ; 'MESSAGE' 'pas de coef  detecte' ;
'FINSI' ;
'FINSI' ;
*
   vdim = 'VALEUR' 'DIME' ;
   vmod = 'VALEUR' 'MODE' ;
   idim = 0 ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'PLANDEFO')) ;
      idim = 2 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'AXIS')) ;
      idim = 2 ;
      iaxi = VRAI ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 3) ('EGA' vmod 'TRID')) ;
      idim = 3 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' vdim 1) ;
      idim = 1 ;
      iaxi = FAUX ;
   'FINSI' ;
*   'MESSAGE' ('CHAINE' 'iaxi=' iaxi );
   'SI' ('EGA' idim 0) ;
      'ERREUR' ('CHAINE' 'vmod=' vmod ' et vdim=' vdim ' non prevu') ;
   'FINSI' ;
   'SI' iaxi ;
      dprmt = '*' ('COORDONNEE' 1 _mt) ('*' PI 2.D0) ;
   'FINSI' ;
*
* Optimisation possible : construire la matrice par blocs
* qd valt et valq ne sont pas donnés
*
   numop = ninct '*' nincq ; numder = idim ; numvar = ninct ;
   numdat = 1 ; numcof = idim ;
   A = ININLIN numop numvar numdat numcof numder ;
   A . 'DAT' . 1 . 'NOMDDL' = tcof . 'NOMINC' . 1 ;
   A . 'DAT' . 1 . 'DISC'   = tcof . 'DISC' ;
   A . 'DAT' . 1 . 'VALEUR' = valo ;
   'REPETER' iicof numcof ;
      icof = &iicof ;
      A . 'COF' . icof . 'COMPOR' = 'CHAINE' 'D/DX' icof ;
      A . 'COF' . icof . 'LDAT'   = 'LECT' 1 ;
   'FIN' iicof ;
   lvt = 'EGA' ('TYPE' valt) 'LISTREEL' ;
   iop = 0 ;
   'REPETER' iiinct ninct ;
      iinct = &iiinct ;
      A . 'VAR' . iinct . 'NOMDDL' = tnomt . 'NOMINC' . iinct ;
      A . 'VAR' . iinct . 'DISC'   = tnomt . 'DISC'  ;
      'SI' lvalt ;
         'SI' lvt ;
            A . 'VAR' . iinct . 'VALEUR'   = 'EXTRAIRE' valt iinct ;
         'SINON' ;
            A . 'VAR' . iinct . 'VALEUR'   = valt ;
         'FINSI' ;
      'FINSI' ;
      ll = 'LECT' iinct ;
      'REPETER' iiincq nincq ;
         iop = '+' iop 1 ;
         A . iop . iinct . 0  = 'LECT' ;
*         A . iop . iinct . 0  = ll ;
      'FIN' iiincq ;
   'FIN' iiinct ;
*
   'SI' iaxi ;
      numdat = 1 ;
      numcof = idim '+' 1 ;
   'SINON' ;
      numdat = 0 ;
      numcof = idim ;
   'FINSI' ;
   numvar = nincq ;
   B = ININLIN numop numvar numdat numcof numder ;
   icof = 0 ;
   'REPETER' iiidim idim ;
      icof = '+' icof 1 ;
      B . 'COF' . icof . 'COMPOR' = 'CHAINE' 'VNOR' &iiidim ;
      B . 'COF' . icof . 'LDAT'   = 'LECT' ;
   'FIN' iiidim ;
*
   'SI' iaxi ;
      icof = '+' icof 1 ;
      B . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
      B . 'DAT' . 1 . 'DISC'   = discg ;
      B . 'DAT' . 1 . 'VALEUR' = dprmt ;
      B . 'COF' . icof . 'COMPOR' = 'IDEN' ;
      B . 'COF' . icof . 'LDAT'   = 'LECT' 1 ;
      ll = 'LECT' icof ;
   'SINON' ;
      ll = 'LECT' ;
   'FINSI' ;
   lvq = 'EGA' ('TYPE' valq) 'LISTREEL' ;
   'REPETER' iiincq nincq ;
      iincq = &iiincq ;
      B . 'VAR' . iincq . 'NOMDDL' = tnomq . 'NOMINC' . iincq ;
      B . 'VAR' . iincq . 'DISC'   = tnomq . 'DISC'  ;
      'SI' lvalq ;
         'SI' lvq ;
            B . 'VAR' . iincq . 'VALEUR'   = 'EXTRAIRE' valq iincq ;
         'SINON' ;
            B . 'VAR' . iincq . 'VALEUR'   = valq ;
         'FINSI' ;
      'FINSI' ;
   'FIN' iiincq ;
   iop = 0 ;
   'REPETER' iiinct ninct ;
*      iinct = &iiinct ;
      'REPETER' iiincq nincq ;
         iincq = &iiincq ;
         iop = '+' iop 1 ;
         B . iop . iincq . 0  = ('LECT' iincq) 'ET' ll ;
      'FIN' iiincq ;
   'FIN' iiinct ;
*
   mgnorgc = NLIN discg _mt A B methgau ;
*
'RESPRO' mgnorgc ;
'FINPROC' ;
*
* End of procedure file GNORGC
*
*ENDPROCEDUR gnorgc
*BEGINPROCEDUR gnorktan
************************************************************************
* NOM         : GNORKTAN
* DESCRIPTION : Matrice tangente associée à la variation de la normale
*               à une surface (calculée par GNOR)
*               en fonction des déplacements des points de la surface.
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 22/04/2011, version initiale
* HISTORIQUE : v1, 22/04/2011, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
*
*
'DEBPROC' GNORKTAN ;
'ARGUMENT'     _mt*'MAILLAGE' ;
'ARGUMENT' tdisc*'TABLE' ;
*
* Lectures
*
dim = 'VALEUR' 'DIME' ;
mdim = DEADUTIL 'DIMM' _mt ;
'SI' ('NEG' mdim ('-' dim 1)) ;
   'ERREUR' 'Dim. maillage .neq. dim. espace - 1' ;
'FINSI' ;
loi  = 'CHAINE' 'VNOJ' ;
debug = FAUX ;
lmotcle = 'MOTS' 'NPRI' 'FPRI' 'CPRI' 'NDUA' 'FDUA' 'CDUA'
                 'NCOF' 'FCOF' 'CCOF' ;
* Il faut initialiser valt et valq, sinon on peut capturer ceux de
* la procédure appelante
valt = 'valt' ; valq = 'valq' ;
'REPETER' imotcle ;
   'ARGUMENT' motcle/'MOT' ;
   'SI' ('NON' ('EXISTE' motcle)) ; 'QUITTER' imotcle ; 'FINSI' ;
   'SI' ('NON' ('EXISTE' lmotcle motcle)) ;
      cherr = 'CHAINE' 'Keyword ' motcle ' unknown.' ; 'ERREUR' cherr ;
   'FINSI' ;
   'SI' ('EGA' motcle 'NPRI') ; 'ARGUMENT' nomt*'MOT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'NDUA') ; 'ARGUMENT' nomq*'MOT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'NCOF') ; 'ARGUMENT' nomo*'MOT' ; 'FINSI' ;
   tst1 = 'EGA' motcle 'FPRI' ; tst2 = 'EGA' motcle 'FDUA' ;
   tst = tst1 'OU' tst2 ;
   'SI' tst ;
      'SI' tst1 ; tt = TDISC . nomt ; 'FINSI' ;
      'SI' tst2 ; tt = TDISC . nomq ; 'FINSI' ;
      isvec = ('>' ('DIME' (tt. 'NOMINC')) 1) ;
      'SI' isvec ; 'ARGUMENT' valv*'LISTREEL' ; 'SINON' ;
         'ARGUMENT' valv*'FLOTTANT' ;
      'FINSI' ;
      'SI' tst1 ; valt = valv ; 'FINSI' ;
      'SI' tst2 ; valq = valv ; 'FINSI' ;
   'FINSI' ;
   'SI' ('EGA' motcle 'FCOF') ; 'ARGUMENT' valo*'FLOTTANT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'CPRI') ; 'ARGUMENT' valt*'CHPOINT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'CDUA') ; 'ARGUMENT' valq*'CHPOINT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'CCOF') ; 'ARGUMENT' valo*'CHPOINT' ; 'FINSI' ;
'FIN' imotcle ;
*
* Tests
*
discg = TDISC . 'GEOM' . 'DISC' ;
'SI' ('EXISTE' tdisc 'methgau') ;
   methgau = tdisc . 'methgau' . 'mass' ;
'SINON' ;
   methgau = 'GAU7' ;
'FINSI' ;
tnomt = TDISC . nomt ;
lvalt = 'NEG' ('TYPE' valt) 'MOT' ;
tnomq = TDISC . nomq ;
lvalq = 'NEG' ('TYPE' valq) 'MOT' ;
* Scalaire ou vecteur
ninct = 'DIME' (tnomt . 'NOMINC') ;
nincq = 'DIME' (tnomq . 'NOMINC') ;
'SI' ('NEG' ninct dim) ;
   cherr = 'CHAINE'
   'la primale doit etre un vecteur' ;
   'ERREUR' cherr ;
'FINSI' ;
'SI' ('NEG' nincq dim) ;
   cherr = 'CHAINE'
   'la duale doit etre un vecteur' ;
   'ERREUR' cherr ;
'FINSI' ;
ninc = dim ;
*
lcof = 'EXISTE' TDISC nomo ;
'SI' lcof ; tcof = TDISC . nomo ;
ncof = 'DIME' (tcof . 'NOMINC') ;
'SINON' ; ncof = 0 ;
'FINSI' ;
*
'SI' debug ;
'SI' lcof ; 'MESSAGE' 'Un coef a ete detecte' ;
'SINON' ; 'MESSAGE' 'pas de coef  detecte' ;
'FINSI' ;
'FINSI' ;
*
   vdim = 'VALEUR' 'DIME' ;
   vmod = 'VALEUR' 'MODE' ;
   idim = 0 ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'PLANDEFO')) ;
      idim = 2 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'AXIS')) ;
      idim = 2 ;
      iaxi = VRAI ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 3) ('EGA' vmod 'TRID')) ;
      idim = 3 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' vdim 1) ;
      idim = 1 ;
      iaxi = FAUX ;
   'FINSI' ;
*   'MESSAGE' ('CHAINE' 'iaxi=' iaxi );
   'SI' ('EGA' idim 0) ;
      'ERREUR' ('CHAINE' 'vmod=' vmod ' et vdim=' vdim ' non prevu') ;
   'FINSI' ;
   'SI' iaxi ;
      deupi = '*' PI 2.D0 ;
      dprmt = '*' ('COORDONNEE' 1 _mt) deupi ;
   'FINSI' ;
*
* Optimisation possible : construire la matrice par blocs
* qd valt et valq ne sont pas donnés
*
   numop = idim '*' idim '*' idim ;
   'SI' iaxi ;
      numop = numop '+' idim ;
   'FINSI' ;
   numder = idim ; numvar = ninct ;
   numdat = ncof ; numcof = ncof ;
   A = ININLIN numop numvar numdat numcof numder ;
   'SI' lcof ;
      lvo = 'EGA' ('TYPE' valo) 'LISTREEL' ;
      'REPETER' iicof ncof ;
         icof = &iicof ;
         A . 'DAT' . icof . 'NOMDDL' = tcof . 'NOMINC' . icof ;
         A . 'DAT' . icof . 'DISC'   = tcof . 'DISC' ;
         'SI' lvo ;
            A . 'DAT' . icof . 'VALEUR' = 'EXTRAIRE' valo icof ;
         'SINON' ;
            A . 'DAT' . icof . 'VALEUR' = valo ;
         'FINSI' ;
         A . 'COF' . icof . 'COMPOR' = 'IDEN' ;
         A . 'COF' . icof . 'LDAT'   = 'LECT' icof ;
      'FIN' iicof ;
   'SINON' ;
      ll = 'LECT' ;
   'FINSI' ;
   lvt = 'EGA' ('TYPE' valt) 'LISTREEL' ;
   iop = 0 ;
   'REPETER' iiinct ninct ;
      iinct = &iiinct ;
      A . 'VAR' . iinct . 'NOMDDL' = tnomt . 'NOMINC' . iinct ;
      A . 'VAR' . iinct . 'DISC'   = tnomt . 'DISC'  ;
      'SI' lvalt ;
         'SI' lvt ;
            A . 'VAR' . iinct . 'VALEUR'   = 'EXTRAIRE' valt iinct ;
         'SINON' ;
            A . 'VAR' . iinct . 'VALEUR'   = valt ;
         'FINSI' ;
      'FINSI' ;
      'REPETER' iiincq nincq ;
         'REPETER' iiider numder ;
            iop = '+' iop 1 ;
            'SI' lcof ;
               icof = 'MINIMUM' ('LECT' &iiincq ncof) ;
               A . iop . iinct . &iiider = 'LECT' icof ;
            'SINON' ;
               A . iop . iinct . &iiider = ll ;
            'FINSI' ;
         'FIN' iiider ;
      'FIN' iiincq ;
   'FIN' iiinct ;
   'SI' iaxi ;
      'REPETER' iiincq nincq ;
         iop = '+' iop 1 ;
         'SI' lcof ;
            icof = 'MINIMUM' ('LECT' &iiincq ncof) ;
            A . iop . 1 . 0 = 'LECT' icof ;
         'SINON' ;
            A . iop . 1 . 0 = ll ;
         'FINSI' ;
      'FIN' iiincq ;
   'FINSI' ;
*
*   'SI' iaxi ;
*      numdat = 1 ;
*      numcof = dim '+' 1 ;
*   'SINON' ;
      numdat = 0 ;
      numcof = idim '*' idim '*' idim ;
*   'FINSI' ;
   'SI' iaxi ;
      numdat = '+' numdat 2 ;
      numcof = '+' numcof ('+' idim 2) ;
   'FINSI' ;
   numvar = nincq ;
   B = ININLIN numop numvar numdat numcof numder ;
*
   lvq = 'EGA' ('TYPE' valq) 'LISTREEL' ;
   'REPETER' iiinc nincq ;
      iinc = &iiinc ;
      B . 'VAR' . iinc . 'NOMDDL' = tnomq . 'NOMINC' . iinc ;
      B . 'VAR' . iinc . 'DISC'   = tnomq . 'DISC'  ;
      'SI' lvalq ;
         'SI' lvq ;
            B . 'VAR' . iinc . 'VALEUR'   = 'EXTRAIRE' valq iinc ;
         'SINON' ;
            B . 'VAR' . iinc . 'VALEUR'   = valq ;
         'FINSI' ;
      'FINSI' ;
   'FIN' iiinc ;
   idat = 0 ;
   icof = 0 ;
   'SI' iaxi ;
      'REPETER' iiidim idim ;
         icof = '+' icof 1 ;
         B . 'COF' . icof . 'COMPOR' = 'CHAINE' 'VNOR' &iiidim ;
         B . 'COF' . icof . 'LDAT'   = 'LECT' ;
      'FIN' iiidim ;
      idat = '+' idat 1 ;
      icof = '+' icof 1 ;
      B . 'DAT' . idat . 'NOMDDL' = 'MOTS' 'SCAL' ;
      B . 'DAT' . idat . 'DISC'   = discg ;
      B . 'DAT' . idat . 'VALEUR' = dprmt ;
      B . 'COF' . icof . 'COMPOR' = 'IDEN' ;
      B . 'COF' . icof . 'LDAT'   = 'LECT' idat ;
      ll = 'LECT' icof ;
      idat = '+' idat 1 ;
      icof = '+' icof 1 ;
      B . 'DAT' . idat . 'NOMDDL' = 'MOTS' 'SCAL' ;
      B . 'DAT' . idat . 'DISC'   = 'CSTE' ;
      B . 'DAT' . idat . 'VALEUR' = deupi ;
      B . 'COF' . icof . 'COMPOR' = 'IDEN' ;
      B . 'COF' . icof . 'LDAT'   = 'LECT' idat ;
      ll2 = 'LECT' icof ;
   'SINON' ;
      ll = 'LECT' ;
   'FINSI' ;
*
  iop = 0 ;
  'REPETER' iiinct ninct ;
     'REPETER' iiincq nincq ;
         'REPETER' iiider numder ;
            iop  = '+' iop 1 ;
            icof = '+' icof 1 ;
            lcomp = 'CHAINE' loi &iiincq &iiinct &iiider ;
*            lcomp = 'CHAINE' loi &iiinct &iiincq &iiider ;
            B . 'COF' . icof . 'COMPOR' = lcomp ;
            B . 'COF' . icof . 'LDAT'   = 'LECT' ;
            B . iop . &iiincq . 0 = ('LECT' icof) 'ET' ll ;
         'FIN' iiider ;
      'FIN' iiincq ;
   'FIN' iiinct ;
   'SI' iaxi ;
      'REPETER' iiincq nincq ;
         iincq = &iiincq ;
         iop = '+' iop 1 ;
         B . iop . iincq . 0 = ('LECT' iincq) 'ET' ll2 ;
      'FIN' iiincq ;
   'FINSI' ;
*
*   mgnorkt = NLIN discg _mt A B 'CRES' methgau ;
   mgnorkt = NLIN discg _mt A B methgau ;
*
'RESPRO' mgnorkt ;
'FINPROC' ;
*
* End of procedure file GNORKTAN
*
*ENDPROCEDUR gnorktan
*BEGINPROCEDUR gnor
************************************************************************
* NOM         : GNOR
* DESCRIPTION : Calcule le champ de normales à une surface.
*               Peut servir à calculer une pression, un potentiel
*               lié à la gravité, un volume contenu dans une surface.
*               Attention à l'orientation de la surface !
*
*               Computes a field of normal to a surface.
*               Also useful to compute a pressure field,
*               a gravity potential field, a volume enclosed
*               by a surface.
*               WARNING : The orientation of the surface matters !
*
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 22/04/2011
* HISTORIQUE : v1, 22/04/2011, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
*
*
'DEBPROC' GNOR ;
'ARGUMENT'     _mt*'MAILLAGE' ;
'ARGUMENT' tdisc*'TABLE' ;
*
* Lectures
*
dim = 'VALEUR' 'DIME' ;
debug = FAUX ;
lmotcle = 'MOTS' 'NPRI' 'FPRI' 'CPRI' 'NDUA' 'FDUA' 'CDUA'
                 'NCOF' 'FCOF' 'CCOF' ;
* Il faut initialiser valt et valq, sinon on peut capturer ceux de
* la procédure appelante
valt = 'valt' ; valq = 'valq' ;
'REPETER' imotcle ;
   'ARGUMENT' motcle/'MOT' ;
   'SI' ('NON' ('EXISTE' motcle)) ; 'QUITTER' imotcle ; 'FINSI' ;
   'SI' ('NON' ('EXISTE' lmotcle motcle)) ;
      cherr = 'CHAINE' 'Keyword ' motcle ' unknown.' ; 'ERREUR' cherr ;
   'FINSI' ;
   'SI' ('EGA' motcle 'NPRI') ; 'ARGUMENT' nomt*'MOT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'NDUA') ; 'ARGUMENT' nomq*'MOT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'NCOF') ; 'ARGUMENT' nomo*'MOT' ; 'FINSI' ;
   tst1 = 'EGA' motcle 'FPRI' ; tst2 = 'EGA' motcle 'FDUA' ;
   tst3 = 'EGA' motcle 'FCOF' ;
   tst = tst1 'OU' tst2 'OU' tst3 ;
   'SI' tst ;
      'SI' tst1 ; tt = TDISC . nomt ; 'FINSI' ;
      'SI' tst2 ; tt = TDISC . nomq ; 'FINSI' ;
      'SI' tst3 ; tt = TDISC . nomo ; 'FINSI' ;
      isvec = ('>' ('DIME' (tt. 'NOMINC')) 1) ;
      'SI' isvec ; 'ARGUMENT' valv*'LISTREEL' ; 'SINON' ;
         'ARGUMENT' valv*'FLOTTANT' ;
      'FINSI' ;
      'SI' tst1 ; valt = valv ; 'FINSI' ;
      'SI' tst2 ; valq = valv ; 'FINSI' ;
      'SI' tst3 ; valo = valv ; 'FINSI' ;
   'FINSI' ;
   'SI' ('EGA' motcle 'CPRI') ; 'ARGUMENT' valt*'CHPOINT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'CDUA') ; 'ARGUMENT' valq*'CHPOINT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'CCOF') ; 'ARGUMENT' valo*'CHPOINT' ; 'FINSI' ;
'FIN' imotcle ;
*
* Tests
*
discg = TDISC . 'GEOM' . 'DISC' ;
'SI' ('EXISTE' tdisc 'methgau') ;
   methgau = tdisc . 'methgau' . 'mass' ;
'SINON' ;
   methgau = 'GAU7' ;
'FINSI' ;
tnomt = TDISC . nomt ;
lvalt = 'NEG' ('TYPE' valt) 'MOT' ;
tnomq = TDISC . nomq ;
lvalq = 'NEG' ('TYPE' valq) 'MOT' ;
* Scalaire ou vecteur
ninct = 'DIME' (tnomt . 'NOMINC') ;
nincq = 'DIME' (tnomq . 'NOMINC') ;
'SI' ('ET' ('NEG' ninct 1) ('NEG' ninct dim)) ;
   cherr = 'CHAINE'
   'la primale doit etre un scalaire ou un vecteur' ;
   'ERREUR' cherr ;
'FINSI' ;
'SI' ('NEG' nincq dim) ;
   cherr = 'CHAINE'
   'la duale doit etre un vecteur' ;
   'ERREUR' cherr ;
'FINSI' ;
*ninc = ninct ;
*
lcof = 'EXISTE' TDISC nomo ;
'SI' lcof ; tcof = TDISC . nomo ;
ncof = 'DIME' (tcof . 'NOMINC') ;
'SINON' ; ncof = 0 ;
'FINSI' ;
*
'SI' debug ;
'SI' lcof ; 'MESSAGE' 'Un coef a ete detecte' ;
'SINON' ; 'MESSAGE' 'pas de coef  detecte' ;
'FINSI' ;
'FINSI' ;
*
   vdim = 'VALEUR' 'DIME' ;
   vmod = 'VALEUR' 'MODE' ;
   idim = 0 ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'PLANDEFO')) ;
      idim = 2 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'AXIS')) ;
      idim = 2 ;
      iaxi = VRAI ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 3) ('EGA' vmod 'TRID')) ;
      idim = 3 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' vdim 1) ;
      idim = 1 ;
      iaxi = FAUX ;
   'FINSI' ;
*   'MESSAGE' ('CHAINE' 'iaxi=' iaxi );
   'SI' ('EGA' idim 0) ;
      'ERREUR' ('CHAINE' 'vmod=' vmod ' et vdim=' vdim ' non prevu') ;
   'FINSI' ;
   'SI' iaxi ;
      dprmt = '*' ('COORDONNEE' 1 _mt) ('*' PI 2.D0) ;
   'FINSI' ;
*
* Optimisation possible : construire la matrice par blocs
* qd valt et valq ne sont pas donnés
*
   numop = nincq ; numder = idim ; numvar = ninct ;
   numdat = ncof ; numcof = ncof ;
   A = ININLIN numop numvar numdat numcof numder ;
   'SI' lcof ;
      lvo = 'EGA' ('TYPE' valo) 'LISTREEL' ;
      'REPETER' iicof ncof ;
         icof = &iicof ;
         A . 'DAT' . icof . 'NOMDDL' = tcof . 'NOMINC' . icof ;
         A . 'DAT' . icof . 'DISC'   = tcof . 'DISC' ;
         'SI' lvo ;
            A . 'DAT' . icof . 'VALEUR' = 'EXTRAIRE' valo icof ;
         'SINON' ;
            A . 'DAT' . icof . 'VALEUR' = valo ;
         'FINSI' ;
         A . 'COF' . icof . 'COMPOR' = 'IDEN' ;
         A . 'COF' . icof . 'LDAT'   = 'LECT' icof ;
      'FIN' iicof ;
   'SINON' ;
      ll = 'LECT' ;
   'FINSI' ;
   lvt = 'EGA' ('TYPE' valt) 'LISTREEL' ;
   'REPETER' iiincq nincq ;
      iincq = &iiincq ;
      iinct = 'MINIMUM' ('LECT' iincq ninct) ;
      A . 'VAR' . iinct . 'NOMDDL' = tnomt . 'NOMINC' . iinct ;
      A . 'VAR' . iinct . 'DISC'   = tnomt . 'DISC'  ;
      'SI' lvalt ;
         'SI' lvt ;
            A . 'VAR' . iinct . 'VALEUR'   = 'EXTRAIRE' valt iinct ;
         'SINON' ;
            A . 'VAR' . iinct . 'VALEUR'   = valt ;
         'FINSI' ;
      'FINSI' ;
      'SI' lcof ;
         icof = 'MINIMUM' ('LECT' iincq ncof) ;
         A . iincq . iinct . 0  = 'LECT' icof ;
      'SINON' ;
         A . iincq . iinct . 0  = ll ;
      'FINSI' ;
   'FIN' iiincq ;
*
   'SI' iaxi ;
      numdat = 1 ;
      numcof = dim '+' 1 ;
   'SINON' ;
      numdat = 0 ;
      numcof = dim ;
   'FINSI' ;
   numvar = nincq ;
   B = ININLIN numop numvar numdat numcof numder ;
   icof = 0 ;
   'REPETER' iiidim idim ;
      icof = '+' icof 1 ;
      B . 'COF' . icof . 'COMPOR' = 'CHAINE' 'VNOR' &iiidim ;
      B . 'COF' . icof . 'LDAT'   = 'LECT' ;
   'FIN' iiidim ;
*
   'SI' iaxi ;
      icof = '+' icof 1 ;
      B . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
      B . 'DAT' . 1 . 'DISC'   = discg ;
      B . 'DAT' . 1 . 'VALEUR' = dprmt ;
      B . 'COF' . icof . 'COMPOR' = 'IDEN' ;
      B . 'COF' . icof . 'LDAT'   = 'LECT' 1 ;
      ll = 'LECT' icof ;
   'SINON' ;
      ll = 'LECT' ;
   'FINSI' ;
   lvq = 'EGA' ('TYPE' valq) 'LISTREEL' ;
   'REPETER' iiincq nincq ;
      iincq = &iiincq ;
      B . 'VAR' . iincq . 'NOMDDL' = tnomq . 'NOMINC' . iincq ;
      B . 'VAR' . iincq . 'DISC'   = tnomq . 'DISC'  ;
      'SI' lvalq ;
         'SI' lvq ;
            B . 'VAR' . iincq . 'VALEUR'   = 'EXTRAIRE' valq iincq ;
         'SINON' ;
            B . 'VAR' . iincq . 'VALEUR'   = valq ;
         'FINSI' ;
      'FINSI' ;
      B . iincq . iincq . 0  = ('LECT' iincq) 'ET' ll ;
   'FIN' iiincq ;
*
   mgnor = NLIN discg _mt A B methgau ;
*
'RESPRO' mgnor ;
'FINPROC' ;
*
* End of procedure file GNOR
*
*ENDPROCEDUR gnor
*BEGINPROCEDUR grig
************************************************************************
* NOM         : GRIG
* DESCRIPTION :
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, ??/??/2007, version initiale
* HISTORIQUE : v1, ??/??/2007, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' GRIG ;
'ARGUMENT'     _mt*'MAILLAGE' ;
'ARGUMENT' tdisc*'TABLE' ;
*
* Lectures
*
debug = FAUX ;
lmotcle = 'MOTS' 'NPRI' 'FPRI' 'CPRI' 'NDUA' 'FDUA' 'CDUA'
                 'NCOF' 'FCOF' 'CCOF' 'LAPN' 'GMBT' ;
* Il faut initialiser valt et valq, sinon on peut capturer ceux de
* la procédure appelante
valt  = 'valt' ; valq = 'valq' ;
llapn = 0 ;
'REPETER' imotcle ;
   'ARGUMENT' motcle/'MOT' ;
   'SI' ('NON' ('EXISTE' motcle)) ; 'QUITTER' imotcle ; 'FINSI' ;
   'SI' ('NON' ('EXISTE' lmotcle motcle)) ;
      cherr = 'CHAINE' 'Keyword ' motcle ' unknown.' ; 'ERREUR' cherr ;
   'FINSI' ;
   'SI' ('EGA' motcle 'NPRI') ; 'ARGUMENT' nomt*'MOT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'NDUA') ; 'ARGUMENT' nomq*'MOT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'NCOF') ; 'ARGUMENT' nomo*'MOT' ; 'FINSI' ;
   tst1 = 'EGA' motcle 'FPRI' ; tst2 = 'EGA' motcle 'FDUA' ;
   tst = tst1 'OU' tst2 ;
   'SI' tst ;
      'SI' tst1 ; tt = TDISC . nomt ; 'FINSI' ;
      'SI' tst2 ; tt = TDISC . nomq ; 'FINSI' ;
      isvec = ('>' ('DIME' (tt. 'NOMINC')) 1) ;
      'SI' isvec ; 'ARGUMENT' valv*'LISTREEL' ; 'SINON' ;
         'ARGUMENT' valv*'FLOTTANT' ;
      'FINSI' ;
      'SI' tst1 ; valt = valv ; 'FINSI' ;
      'SI' tst2 ; valq = valv ; 'FINSI' ;
   'FINSI' ;
   'SI' ('EGA' motcle 'FCOF') ; 'ARGUMENT' valo*'FLOTTANT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'CPRI') ; 'ARGUMENT' valt*'CHPOINT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'CDUA') ; 'ARGUMENT' valq*'CHPOINT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'CCOF') ; 'ARGUMENT' valo*'CHPOINT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'LAPN') ; llapn = 1 ; 'FINSI' ;
   'SI' ('EGA' motcle 'GMBT') ; llapn = 2 ; 'FINSI' ;
'FIN' imotcle ;
*
* Tests
*
discg = TDISC . 'GEOM' . 'DISC' ;
'SI' ('EXISTE' tdisc 'methgau') ;
   methgau = tdisc . 'methgau' . 'rigi' ;
'SINON' ;
   methgau = 'GAU7' ;
'FINSI' ;
tnomt = TDISC . nomt ;
lvalt = 'NEG' ('TYPE' valt) 'MOT' ;
tnomq = TDISC . nomq ;
lvalq = 'NEG' ('TYPE' valq) 'MOT' ;
* Scalaire ou vecteur
ninct = 'DIME' (tnomt . 'NOMINC') ;
nincq = 'DIME' (tnomq . 'NOMINC') ;
'SI' ('NEG' ninct nincq) ;
   cherr = 'CHAINE'
   'les primales et duales nont pas le meme nombre de composantes' ;
   'ERREUR' cherr ;
'FINSI' ;
'SI' ('NEG' ninct ('VALEUR' 'DIME')) ;
   cherr = 'CHAINE'
   'les inconnues doivent etre vectorielles' ;
   'ERREUR' cherr ;
'FINSI' ;
*
ninc = ninct ;
*
lcof = 'EXISTE' TDISC nomo ;
'SI' lcof ; ncof = 1 ; tcof = TDISC . nomo ;
'SINON' ; ncof = 0 ;
'FINSI' ;
*
'SI' debug ;
'SI' lcof ; 'MESSAGE' 'Un coef a ete detecte' ;
'SINON' ; 'MESSAGE' 'pas de coef  detecte' ;
'FINSI' ;
'FINSI' ;
*
   vdim = 'VALEUR' 'DIME' ;
   vmod = 'VALEUR' 'MODE' ;
   idim = 0 ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'PLANDEFO')) ;
      idim = 2 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'AXIS')) ;
      idim = 2 ;
      iaxi = VRAI ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 3) ('EGA' vmod 'TRID')) ;
      idim = 3 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' vdim 1) ;
      idim = 1 ;
      iaxi = FAUX ;
   'FINSI' ;
*   'MESSAGE' ('CHAINE' 'iaxi=' iaxi );
   'SI' ('EGA' idim 0) ;
      'ERREUR' ('CHAINE' 'vmod=' vmod ' et vdim=' vdim ' non prevu') ;
   'FINSI' ;
   'SI' iaxi ;
      rmt   = 'COORDONNEE' 1 _mt ;
      deupi = '*' PI 2.D0 ;
   'FINSI' ;
*
* Optimisation possible : construire la matrice par blocs
* qd valt et valq ne sont pas donnés
*
*
*Bug ?   numop  = ('**' ninc 2) '+' 1 ;
   numop  = '**' ninc 2 ;
   'SI' iaxi ; numop = '+' numop 1 ; 'FINSI' ;
   numder = idim ;
   numvar = ninc ;
   ncof = '+' ncof 1 ;
*delete   'SI' iaxi ; ncof = '+' ncof 1 ; 'FINSI' ;
   numdat = ncof ;
   numcof = ncof ;
*
   A = ININLIN numop numvar numdat numcof numder ;
*
   lvt = 'EGA' ('TYPE' valt) 'LISTREEL' ;
   'REPETER' iiinc ninc ;
      iinc = &iiinc ;
      A . 'VAR' . iinc . 'NOMDDL' = tnomt . 'NOMINC' . iinc ;
      A . 'VAR' . iinc . 'DISC'   = tnomt . 'DISC'  ;
      'SI' lvalt ;
         'SI' lvt ;
            A . 'VAR' . iinc . 'VALEUR'   = 'EXTRAIRE' valt iinc ;
         'SINON' ;
            A . 'VAR' . iinc . 'VALEUR'   = valt ;
         'FINSI' ;
      'FINSI' ;
   'FIN' iiinc ;
*
   icof = 0 ;
   ll = 'LECT' ;
   icof = '+' icof 1 ;
   A . 'DAT' . icof . 'NOMDDL' = 'MOTS' 'SCAL' ;
   A . 'DAT' . icof . 'DISC'   = 'CSTE' ;
   A . 'DAT' . icof . 'VALEUR' = 2.D0 ;
   A . 'COF' . icof . 'COMPOR' = 'IDEN' ;
   A . 'COF' . icof . 'LDAT'   = 'LECT' icof ;
   ll  = 'LECT' ;
   ll2 = 'LECT' icof ;
   'SI' lcof ;
      icof = '+' icof 1 ;
      A . 'DAT' . icof . 'NOMDDL' = tcof . 'NOMINC' . 1 ;
      A . 'DAT' . icof . 'DISC'   = tcof . 'DISC' ;
      A . 'DAT' . icof . 'VALEUR' = valo ;
      A . 'COF' . icof . 'COMPOR' = 'IDEN' ;
      A . 'COF' . icof . 'LDAT'   = 'LECT' icof ;
      ll  = 'ET' ll  ('LECT' icof) ;
      ll2 = 'ET' ll2 ('LECT' icof) ;
   'FINSI' ;
*
   iop = 0 ;
   'REPETER' iidim idim ;
      'REPETER' jidim idim ;
         iop = '+' iop 1 ;
         'SI' ('EGA' &iidim &jidim) ;
            'SI' ('EGA' llapn 0) ;
               A . iop . &iidim . &jidim = ll2 ;
            'SINON' ;
               A . iop . &iidim . &jidim = ll ;
            'FINSI' ;
         'SINON' ;
            'SI' ('NEG' llapn 2) ;
               A . iop . &iidim . &jidim = ll ;
            'FINSI' ;
            'SI' ('NEG' llapn 1) ;
               A . iop . &jidim . &iidim = ll ;
            'FINSI' ;
         'FINSI' ;
      'FIN' jidim ;
   'FIN' iidim ;
   'SI' iaxi ;
      iop = '+' iop 1 ;
      'SI' ('EGA' llapn 0) ;
         A . iop . 1 . 0 = ll2 ;
      'SINON' ;
         A . iop . 1 . 0 = ll ;
      'FINSI' ;
   'FINSI' ;
*
   'SI' iaxi ;
      numdat = 2 ;
      numcof = 2 ;
   'SINON' ;
      numdat = 0 ;
      numcof = 0 ;
   'FINSI' ;
*
   B = ININLIN numop numvar numdat numcof numder ;
*
   icof = 0 ;
*
   'SI' iaxi ;
      icof = '+' icof 1 ;
      B . 'DAT' . icof . 'NOMDDL' = 'MOTS' 'SCAL' ;
      B . 'DAT' . icof . 'DISC'   = discg ;
      B . 'DAT' . icof . 'VALEUR' = rmt ;
      B . 'COF' . icof . 'COMPOR' = 'IDEN' ;
      B . 'COF' . icof . 'LDAT'   = 'LECT' icof ;
      icof = '+' icof 1 ;
      B . 'DAT' . icof . 'NOMDDL' = 'MOTS' 'SCAL' ;
      B . 'DAT' . icof . 'DISC'   = 'CSTE' ;
      B . 'DAT' . icof . 'VALEUR' = deupi ;
      B . 'COF' . icof . 'COMPOR' = 'IDEN' ;
      B . 'COF' . icof . 'LDAT'   = 'LECT' icof ;
      ll  = 'LECT' ('-' icof 1) icof ;
      mic = '*' ('-' icof 1) -1 ;
      llb = 'LECT' mic icof ;
   'FINSI' ;
*
   lvq = 'EGA' ('TYPE' valq) 'LISTREEL' ;
   'REPETER' iiinc ninc ;
      iinc = &iiinc ;
      B . 'VAR' . iinc . 'NOMDDL' = tnomq . 'NOMINC' . iinc ;
      B . 'VAR' . iinc . 'DISC'   = tnomq . 'DISC'  ;
      'SI' lvalq ;
         'SI' lvq ;
            B . 'VAR' . iinc . 'VALEUR'   = 'EXTRAIRE' valq iinc ;
         'SINON' ;
            B . 'VAR' . iinc . 'VALEUR'   = valq ;
         'FINSI' ;
      'FINSI' ;
   'FIN' iiinc ;
*
   iop = 0 ;
   'REPETER' iidim idim ;
      'REPETER' jidim idim ;
         iop = '+' iop 1 ;
         B . iop . &iidim . &jidim = ll ;
      'FIN' jidim ;
   'FIN' iidim ;
   'SI' iaxi ;
      iop = '+' iop 1 ;
      B . iop . 1 . 0 = llb ;
*      B . iop . 1 . 0 = ll ;
   'FINSI' ;
*
   mgrig = NLINP discg _mt A B methgau ;
* Integration par parties
*   mgrig = '*' mgrig -1.D0 ;
*
'RESPRO' mgrig ;
'FINPROC' ;
*
* End of procedure file GRIG
*
*ENDPROCEDUR grig
*BEGINPROCEDUR gugrad2
************************************************************************
* NOM         : GUGRAD2
* DESCRIPTION : Une matrice de convection
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v2, 14/03/2006, mise à jour NLIN évolué
* VERSION    : v1, 13/05/2004, version initiale
* HISTORIQUE : v1, 13/05/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' GUGRAD2 ;
'ARGUMENT'     _mt*'MAILLAGE' ;
'ARGUMENT'     _smt/'MAILLAGE' ;
'ARGUMENT' tdisc*'TABLE' ;
*
* Lectures
*
debug = FAUX ;
lmotcle = 'MOTS' 'NPRI' 'FPRI' 'CPRI' 'NDUA' 'FDUA' 'CDUA'
                 'NVIT' 'FVIT' 'CVIT' 'NCOF' 'FCOF' 'CCOF' ;
'REPETER' imotcle ;
   'ARGUMENT' motcle/'MOT' ;
   'SI' ('NON' ('EXISTE' motcle)) ; 'QUITTER' imotcle ; 'FINSI' ;
   'SI' ('NON' ('EXISTE' lmotcle motcle)) ;
      cherr = 'CHAINE' 'Keyword ' motcle ' unknown.' ; 'ERREUR' cherr ;
   'FINSI' ;
   'SI' ('EGA' motcle 'NPRI') ; 'ARGUMENT' nomt*'MOT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'NDUA') ; 'ARGUMENT' nomq*'MOT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'NCOF') ; 'ARGUMENT' nomo*'MOT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'NVIT') ; 'ARGUMENT' nomu*'MOT' ; 'FINSI' ;
   tst1 = 'EGA' motcle 'FPRI' ; tst2 = 'EGA' motcle 'FDUA' ;
   tst = tst1 'OU' tst2 ;
   'SI' tst ;
      'SI' tst1 ; tt = TDISC . nomt ; 'FINSI' ;
      'SI' tst2 ; tt = TDISC . nomq ; 'FINSI' ;
      isvec = ('>' ('DIME' (tt. 'NOMINC')) 1) ;
      'SI' isvec ; 'ARGUMENT' valv*'LISTREEL' ; 'SINON' ;
         'ARGUMENT' valv*'FLOTTANT' ;
      'FINSI' ;
      'SI' tst1 ; valt = valv ; 'FINSI' ;
      'SI' tst2 ; valq = valv ; 'FINSI' ;
   'FINSI' ;
   'SI' ('EGA' motcle 'FCOF') ; 'ARGUMENT' valo*'FLOTTANT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'FVIT') ; 'ARGUMENT' valu*'LISTREEL' ; 'FINSI' ;
   'SI' ('EGA' motcle 'CPRI') ; 'ARGUMENT' valt*'CHPOINT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'CDUA') ; 'ARGUMENT' valq*'CHPOINT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'CCOF') ; 'ARGUMENT' valo*'CHPOINT' ; 'FINSI' ;
   'SI' ('EGA' motcle 'CVIT') ; 'ARGUMENT' valu*'CHPOINT' ; 'FINSI' ;
'FIN' imotcle ;
*
* Tests
*
discg = TDISC . 'GEOM' . 'DISC' ;
'SI' ('EXISTE' tdisc 'methgau') ;
   methgau = tdisc . 'methgau' . 'amor' ;
'SINON' ;
   methgau = 'GAU7' ;
'FINSI' ;
tnomt = TDISC . nomt ;
lvalt = 'NEG' ('TYPE' valt) 'MOT' ;
tnomq = TDISC . nomq ;
lvalq = 'NEG' ('TYPE' valq) 'MOT' ;
tnomu = TDISC . nomu ;
* Scalaire ou vecteur
ninct = 'DIME' (tnomt . 'NOMINC') ;
nincq = 'DIME' (tnomq . 'NOMINC') ;
'SI' ('NEG' ninct nincq) ;
   cherr = 'CHAINE'
   'les primales et duales nont pas le meme nombre de composantes' ;
   'ERREUR' cherr ;
'FINSI' ;
ninc = ninct ;
*
lcof = 'EXISTE' TDISC nomo ;
'SI' lcof ; ncof = 1 ; tcof = TDISC . nomo ;
'SINON' ; ncof = 0 ;
'FINSI' ;
*
'SI' debug ;
'SI' lcof ; 'MESSAGE' 'Un coef a ete detecte' ;
'SINON' ; 'MESSAGE' 'pas de coef  detecte' ;
'FINSI' ;
'FINSI' ;
*
   vdim = 'VALEUR' 'DIME' ;
   vmod = 'VALEUR' 'MODE' ;
   idim = 0 ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'PLANDEFO')) ;
      idim = 2 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'AXIS')) ;
      idim = 2 ;
      iaxi = VRAI ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 3) ('EGA' vmod 'TRID')) ;
      idim = 3 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' vdim 1) ;
      idim = 1 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' idim 0) ;
      'ERREUR' ('CHAINE' 'vmod=' vmod ' et vdim=' vdim ' non prevu') ;
   'FINSI' ;
   'SI' iaxi ;
      dprmt = '*' ('COORDONNEE' 1 _mt) ('*' PI 2.D0) ;
   'FINSI' ;
* Scalaire ou vecteur
nincu = 'DIME' (tnomu . 'NOMINC') ;
'SI' ('NEG' nincu idim) ;
   cherr = 'CHAINE'
   'la vitesse doit etre un vecteur' ;
   'ERREUR' cherr ;
'FINSI' ;
ncof = '+' ncof nincu ;
*
* Optimisation possible : construire la matrice par blocs
* qd valt et valq ne sont pas donnés
*
   numop = ninc ; numder = idim ; numvar = ninc ;
   numdat = ncof ; numcof = ncof ;
   A = ININLIN numop numvar numdat numcof numder ;
*
   lvt = 'EGA' ('TYPE' valt) 'LISTREEL' ;
   'REPETER' iiinc ninc ;
      iinc = &iiinc ;
      A . 'VAR' . iinc . 'NOMDDL' = tnomt . 'NOMINC' . iinc ;
      A . 'VAR' . iinc . 'DISC'   = tnomt . 'DISC'  ;
      'SI' lvalt ;
         'SI' lvt ;
            A . 'VAR' . iinc . 'VALEUR'   = 'EXTRAIRE' valt iinc ;
         'SINON' ;
            A . 'VAR' . iinc . 'VALEUR'   = valt ;
         'FINSI' ;
      'FINSI' ;
   'FIN' iiinc ;
*
   lvu = 'EGA' ('TYPE' valu) 'LISTREEL' ;
   icof = 0 ;
   'REPETER' iiincu nincu ;
      iincu = &iiincu ;
      icof = icof '+' 1 ;
      A . 'DAT' . icof . 'NOMDDL' = tnomu . 'NOMINC' . iincu ;
      A . 'DAT' . icof . 'DISC'   = tnomu . 'DISC' ;
      'SI' lvu ;
         A . 'DAT' . icof . 'VALEUR'   = 'EXTRAIRE' valu iincu ;
      'SINON' ;
         A . 'DAT' . icof . 'VALEUR'   = valu ;
      'FINSI' ;
      A . 'COF' . icof . 'COMPOR' = 'IDEN' ;
      A . 'COF' . icof . 'LDAT'   = 'LECT' icof ;
   'FIN' iiincu ;
   'SI' lcof ;
      icof = icof '+' 1 ;
      A . 'DAT' . icof . 'NOMDDL' = tcof . 'NOMINC' . 1 ;
      A . 'DAT' . icof . 'DISC'   = tcof . 'DISC' ;
      A . 'DAT' . icof . 'VALEUR' = valo ;
      A . 'COF' . icof . 'COMPOR' = 'IDEN' ;
      A . 'COF' . icof . 'LDAT'   = 'LECT' icof ;
      ll = 'LECT' icof ;
   'SINON' ;
      ll = 'LECT' ;
   'FINSI' ;
*
   'REPETER' iiinc ninc ;
      iinc = &iiinc ;
      'REPETER' iiidim idim ;
         iidim = &iiidim ;
         A . iinc . iinc . iidim = ('ET' ('LECT' iidim) ll) ;
      'FIN' iiidim ;
   'FIN' iiinc ;
*
   'SI' iaxi ;
      numdat = 1 ;
      numcof = 1 ;
   'SINON' ;
      numdat = 0 ;
      numcof = 0 ;
   'FINSI' ;
   B = ININLIN numop numvar numdat numcof numder ;
   'SI' iaxi ;
      B . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
      B . 'DAT' . 1 . 'DISC'   = discg ;
      B . 'DAT' . 1 . 'VALEUR' = dprmt ;
      B . 'COF' . 1 . 'COMPOR' = 'IDEN' ;
      B . 'COF' . 1 . 'LDAT'   = 'LECT' 1 ;
      ll = 'LECT' 1 ;
   'SINON' ;
      ll = 'LECT' ;
   'FINSI' ;
   lvq = 'EGA' ('TYPE' valq) 'LISTREEL' ;
   'REPETER' iiinc ninc ;
      iinc = &iiinc ;
      B . 'VAR' . iinc . 'NOMDDL' = tnomq . 'NOMINC' . iinc ;
      B . 'VAR' . iinc . 'DISC'   = tnomq . 'DISC'  ;
      'SI' lvalq ;
         'SI' lvq ;
            B . 'VAR' . iinc . 'VALEUR'   = 'EXTRAIRE' valq iinc ;
         'SINON' ;
            B . 'VAR' . iinc . 'VALEUR'   = valq ;
         'FINSI' ;
      'FINSI' ;
      B . iinc . iinc . 0  = ll ;
   'FIN' iiinc ;
*
   'SI' ('EXISTE' _smt) ;
       mgugrad2 = 'NLIN' discg _mt _smt A B methgau ;
   'SINON' ;
       mgugrad2 = NLINP discg _mt A B methgau ;
   'FINSI' ;
*
'RESPRO' mgugrad2 ;
'FINPROC' ;
*
* End of procedure file GUGRAD2
*
*ENDPROCEDUR gugrad2
*BEGINPROCEDUR gvol
************************************************************************
* NOM         : GVOL
* DESCRIPTION :
* Calcule le volume compris dans une surface fermée
* La normale doit être vers l'intérieur pour que le volume soit positif
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 22/04/2011, version initiale
* HISTORIQUE : v1, 22/04/2011, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
*
*
'DEBPROC' GVOL ;
'ARGUMENT' _surf*'MAILLAGE' ;
'ARGUMENT' tdisc*'TABLE' ;
'ARGUMENT' dbg/'LOGIQUE' ;
*
'SI' ('NON' ('EXISTE' dbg)) ;
   dbg = FAUX ;
'FINSI' ;
*
*  Vecteur position et calcul du volume
NOMVIT = @STBL (TDISC . 'XN' . 'NOMINC') ;
DISCG  = TDISC . 'GEOM' . 'DISC' ;
vdim = 'VALEUR' 'DIME' ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'AXIS')) ;
      fdim = 3 ;
   'SINON' ;
      fdim = vdim ;
   'FINSI' ;
   vposc = GETCOO _surf nomvit ;
*   'SI' iaxi ;
*      rs zs = 'COORDONNEE' _surf ;
*      nr = 'EXTRAIRE' nomvit 1 ;
*      nz = 'EXTRAIRE' nomvit 2 ;
*      vposc =
*   'FINSI' ;
*   fvol = GNOR _surf tdisc 'NPRI' ('CHAINE' discg 'V') 'CPRI' vpos
*                          'NDUA' 'CSTEV' ;
*   rfvol = 'RESULT' fvol ;
*   volx = 'MAXIMUM' ('EXCO' 'UX' rfvol) ;
*   voly = 'MAXIMUM' ('EXCO' 'UY' rfvol) ;
*   vol = '/' ('+' volx voly) vdim ;
   fvolc = GNOR _surf tdisc 'NPRI' discg
                          'NCOF' (chai discg 'V')
                          'CCOF' vposc
                          'NDUA' (chai discg 'V')
                          'FDUA' ('PROG' vdim * 1.) ;
   volc = '/' ('MAXIMUM' ('RESULT' fvolc))
              fdim ;
   vol = volc '*' -1. ;
'RESPRO' vol ;
*
* End of procedure file GVOL
*
'FINPROC' ;
*ENDPROCEDUR gvol
*BEGINPROCEDUR jetmod
************************************************************************
* NOM         : JETMOD
* DESCRIPTION :
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, ??/??/2007, version initiale
* HISTORIQUE : v1, ??/??/2007, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' JETMOD ;
*'ARGUMENT' .... ;
'SI' ('EGA' vdim 2) ;
   'SI' ('NEG' vmod 'AXIS') ;
      nomdep = 'MOTS' 'UX' 'UY' ;
      nomvit = nomdep ;
*      nomvit = 'MOTS' 'VX' 'VY' ;
      nomfor = 'MOTS' 'FX' 'FY' ;
      nomqdm = 'MOTS' 'GX' 'GY' ;
   'SINON' ;
      nomdep = 'MOTS' 'UR' 'UZ' ;
      nomvit = nomdep ;
      nomfor = 'MOTS' 'FR' 'FZ' ;
      nomqdm = 'MOTS' 'GR' 'GZ' ;
   'FINSI' ;
   'SI' ('EGA' discp 'LINM') ;
      nompre = 'MOTS' 'LX1' 'LX2' 'LX3' ;
   'SINON' ;
      nompre = 'MOTS' 'LXP' ;
   'FINSI' ;
'SINON' ;
   nomdep = 'MOTS' 'UX' 'UY' 'UZ' ;
   nomvit = nomdep ;
   nomfor = 'MOTS' 'FX' 'FY' 'FZ' ;
   nomqdm = 'MOTS' 'GX' 'GY' 'GZ' ;
   'SI' ('EGA' discp 'LINM') ;
      nompre = 'MOTS' 'LX1' 'LX2' 'LX3' 'LX4' ;
   'SINON' ;
      nompre = 'MOTS' 'LXP' ;
    'FINSI' ;
'FINSI' ;
*
nomsca = 'MOTS' 'SCAL' ;
*
TDISC = 'TABLE' ;
TDISC . 'GEOM' = 'TABLE' ;
TDISC . 'GEOM' . 'DISC' = discg ;
TDISC . 'XN' = 'TABLE' ;
TDISC . 'XN' . 'DISC' = TDISC . 'GEOM' . 'DISC' ;
*TDISC . 'XN' . 'DISC' = 'LINB' ;
TDISC . 'XN' . 'NOMINC' = 'TABLE' ;
'REPETER' idim vdim ;
   TDISC . 'XN' . 'NOMINC' . &idim = 'MOTS' ('EXTRAIRE' nomdep &idim) ;
'FIN' idim ;
TDISC . 'UN' = 'TABLE' ;
*TDISC . 'UN' . 'DISC' = TDISC . 'GEOM' . 'DISC' ;
TDISC . 'UN' . 'DISC' = discv ;
TDISC . 'UN' . 'NOMINC' = 'TABLE' ;
'REPETER' idim vdim ;
   TDISC . 'UN' . 'NOMINC' . &idim = 'MOTS' ('EXTRAIRE' nomvit &idim) ;
'FIN' idim ;
TDISC . 'FN' = 'TABLE' ;
TDISC . 'FN' . 'DISC' = TDISC . 'GEOM' . 'DISC' ;
TDISC . 'FN' . 'NOMINC' = 'TABLE' ;
'REPETER' idim vdim ;
   TDISC . 'FN' . 'NOMINC' . &idim = 'MOTS' ('EXTRAIRE' nomfor &idim) ;
'FIN' idim ;
TDISC . 'GN' = 'TABLE' ;
TDISC . 'GN' . 'DISC' = TDISC . 'GEOM' . 'DISC' ;
TDISC . 'GN' . 'NOMINC' = 'TABLE' ;
'REPETER' idim vdim ;
   TDISC . 'GN' . 'NOMINC' . &idim = 'MOTS' ('EXTRAIRE' nomqdm &idim) ;
'FIN' idim ;
TDISC . 'PN' = 'TABLE' ;
TDISC . 'PN' . 'DISC' = discp ;
TDISC . 'PN' . 'NOMINC' = 'TABLE' ;
TDISC . 'PN' . 'NOMINC' . 1 = nompre ;
lmdisc = 'MOTS' 'CSTE' 'LINE' 'QUAF' ;
'REPETER' iidisc ('DIME' lmdisc) ;
   mdisc = 'EXTRAIRE' lmdisc &iidisc ;
   tdisc . mdisc = 'TABLE' ;
   tdisc . mdisc . 'DISC' = mdisc ;
   tdisc . mdisc . 'NOMINC' = 'TABLE' ;
   tdisc . mdisc . 'NOMINC' . 1 = nomsca ;
   mdiscv = 'CHAINE' mdisc 'V' ;
   tdisc . mdiscv = 'TABLE' ;
   tdisc . mdiscv . 'DISC' = mdisc ;
   tdisc . mdiscv . 'NOMINC' = 'TABLE' ;
   'REPETER' idim vdim ;
      TDISC . mdiscv. 'NOMINC' . &idim =
         'MOTS' ('EXTRAIRE' nomdep &idim) ;
   'FIN' idim ;
'FIN' iidisc ;
'RESPRO' tdisc ;
*
* End of procedure file JETMOD
*
'FINPROC' ;
*ENDPROCEDUR jetmod
*BEGINPROCEDUR log10
************************************************************************
* NOM         : LOG10
* DESCRIPTION : Log_10
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 18/02/2003, version initiale
* HISTORIQUE : v1, 18/02/2003, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' LOG10 ;
'REPETER' bouc ;
   ok = FAUX ;
   'ARGUMENT' fl/'FLOTTANT' ;
   'ARGUMENT' lr/'LISTREEL' ;
   'ARGUMENT' cp/'CHPOINT ' ;
   'ARGUMENT' cm/'MCHAML  ' ;
   'SI' ('EXISTE' fl) ;
      ok = VRAI ;
      'RESPRO' ('/' ('LOG' fl) ('LOG' 10.D0)) ;
   'FINSI' ;
   'SI' ('EXISTE' lr) ;
      ok = VRAI ;
      'RESPRO' ('/' ('LOG' lr) ('LOG' 10.D0)) ;
   'FINSI' ;
   'SI' ('EXISTE' cp) ;
      ok = VRAI ;
      'RESPRO' ('/' ('LOG' cp) ('LOG' 10.D0)) ;
   'FINSI' ;
   'SI' ('EXISTE' cm) ;
      ok = VRAI ;
      'RESPRO' ('/' ('LOG' cm) ('LOG' 10.D0)) ;
   'FINSI' ;
   'SI' ('NON' ok) ;
      'QUITTER' bouc ;
   'FINSI' ;
'FIN' bouc ;
*
* End of procedure file LOG10
*
'FINPROC' ;
*ENDPROCEDUR log10
*BEGINPROCEDUR modulo
************************************************************************
* NOM         : MODULO
* DESCRIPTION : Calcule un entier modulo un autre...
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 15/10/2002, version initiale
* HISTORIQUE : v1, 15/10/2002, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' MODULO ;
'ARGUMENT' i*'ENTIER' j*'ENTIER' ;
'SI' ('EGA' j 0) ;
  'MESSAGE' 'Impossible de faire modulo 0' ;
  'ERREUR' 5 ;
'SINON' ;
  k=i '/' j ;
  mod=i '-' ( k '*'j ) ;
  'RESPRO' mod ;
'FINSI' ;
*
* End of procedure file MODULO
*
'FINPROC' ;
*ENDPROCEDUR modulo
*BEGINPROCEDUR myent
************************************************************************
* NOM         : MYENT
* DESCRIPTION :
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, ??/??/2007, version initiale
* HISTORIQUE : v1, ??/??/2007, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' MYENT ;
'ARGUMENT' rr*'FLOTTANT' ;
'SI' ('>EG' rr 0.) ;
   ii = 'ENTIER' ('+' rr 0.5)  ;
'SINON' ;
   ii = 'ENTIER' ('-' rr 0.5)  ;
'FINSI' ;
'RESPRO' ii ;
*
* End of procedure file MYENT
*
'FINPROC' ;
*ENDPROCEDUR myent
*BEGINPROCEDUR nortans
************************************************************************
* NOM         : NORTANS
* DESCRIPTION :
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, ??/??/2007, version initiale
* HISTORIQUE : v1, ??/??/2007, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' NORTANS ;
'ARGUMENT' vno*'CHPOINT' ;
'REPETER' bcl ;
   'ARGUMENT' chpo/'CHPOINT' ;
   'SI' ('EXISTE' chpo) ;
* chpo + vnor * 0  pour le cas des chpoints vides
      chpon = PSCAL ('+' chpo ('*' vnor 0.))
         vnor nomdep nomdep ;
*      'LISTE' chpo ;
*      'LISTE' chpon  ;
*      'LISTE' vnor ;
      chponn = '*' chpon vnor ;
      chpott = '-' chpo chponn ;
      chpot = '**' ('PSCAL' chpott chpott nomdep nomdep) 0.5D0 ;
      'RESPRO' chpon chpot ;
   'SINON' ;
      'QUITTER' bcl ;
   'FINSI' ;
'FIN' bcl ;
*
* End of procedure file NORTANS
*
'FINPROC' ;
*ENDPROCEDUR nortans
*BEGINPROCEDUR projsysc
************************************************************************
* NOM         : PROJSYSC
* DESCRIPTION : Calcul matrice et second membre projetés suivant
*               un champ de directions données
*
*               Project a linear system with respect to a given
*               vector field
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 22/04/2011, version initiale
* HISTORIQUE : v1, 22/04/2011, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
*
*
'DEBPROC' PROJSYSC ;
'ARGUMENT' tdisc*'TABLE' ;
'ARGUMENT' vnorn*'CHPOINT' ;
'ARGUMENT' ktgra*'RIGIDITE' ;
'ARGUMENT' fpgra*'CHPOINT' ;
'ARGUMENT' kvol/'CHPOINT' ;
lcnt = 'EXISTE' kvol ;
'SI' lcnt ;
   'ARGUMENT' dvol*'FLOTTANT' ;
'FINSI' ;
vdim = 'VALEUR' 'DIME' ;
NOMVIT = @STBL (TDISC . 'XN' . 'NOMINC') ;
   fpgran = 'PSCAL' fpgra vnorn nomvit nomvit ;
* Condensation de la matrice
   'SI' lmatrik ;
      knord = 'KOPS' 'MATDIAGO' vnorn 'MATRIK' ;
   'SINON' ;
      knord = 'KOPS' 'MATDIAGO' vnorn ;
      knord = 'CHANGER' 'INCO' knord nomvit nomvit
         nomfor nomvit  ;
*   knordk= 'KOPS' 'MATDIAGO' vnorn 'MATRIK' ;
   'FINSI' ;
   'SI' ('EGA' vdim 2) ;
      nomscal = 'MOTS' 'SCAL' 'SCAL' ;
   'SINON' ;
      nomscal = 'MOTS' 'SCAL' 'SCAL' 'SCAL' ;
   'FINSI' ;
   knor  = 'CHANGER' 'INCO' knord nomvit nomscal nomvit nomvit  ;
   knort = 'CHANGER' 'INCO' knord nomvit nomvit  nomvit nomscal ;
   'SI' lmatrik ;
      ktgrak = 'KOPS' 'RIMA' ktgra ;
   'SINON' ;
      ktgrak = ktgra ;
   'FINSI' ;
*   'MESSAGE' 'ktgrak' ;
*   'LISTE' ('EXTRAIRE' ktgrak 'COMP') ;
*   'LISTE' ('EXTRAIRE' ktgrak 'COMP' 'DUAL') ;
*   'MESSAGE' 'knort' ;
*   'LISTE' ('EXTRAIRE' knort 'COMP') ;
*   'LISTE' ('EXTRAIRE' knort 'COMP' 'DUAL') ;
   ktg1  = 'KOPS' 'CMCT' ktgrak knort ;
*   'MESSAGE' 'ktg1' ;
*   'LISTE' ('EXTRAIRE' ktg1 'COMP') ;
*   'LISTE' ('EXTRAIRE' ktg1 'COMP' 'DUAL') ;
   ktg2 = 'KOPS' 'TRANSPOS' ktg1 ;
*   'MESSAGE' 'ktg2' ;
*   'LISTE' ('EXTRAIRE' ktg2 'COMP') ;
*   'LISTE' ('EXTRAIRE' ktg2 'COMP' 'DUAL') ;
   ktg3 = 'KOPS' 'CMCT' knort ktg2 ;
*   'MESSAGE' 'ktg3' ;
*   'LISTE' ('EXTRAIRE' ktg3 'COMP') ;
*   'LISTE' ('EXTRAIRE' ktg3 'COMP' 'DUAL') ;
   ktot = ktg3 ;
   ftot = fpgran ;
   'SI' lcnt ;
      ktvol = 'PSCAL' kvol vnorn nomvit nomvit ;
      ktv = rela ('NOMC' 'T' ktvol) ;
      smbvol = 'DEPIMPOSE' ktv dvol ;
      'SI' lmatrik ;
         ktv = 'KOPS' 'RIMA' ktv ;
      'FINSI' ;
      lpr1 = 'MOTS' 'T' 'LX' ; l2 = 'MOTS' 'SCAL' 'LX' ;
      ldu1 = 'MOTS' 'Q' 'FLX' ;
      ktv = 'CHANGER' 'INCO' ktv lpr1 l2 ldu1 l2 ;
      smbvol = 'NOMC' ldu1 l2 smbvol ;
      ktot = ktot 'ET' ktv ;
      ftot = ftot '+' smbvol ;
   'FINSI' ;
'RESPRO' ktot ftot ;
*
* End of procedure file PROJSYSC
*
'FINPROC' ;
*ENDPROCEDUR projsysc
*BEGINPROCEDUR quafme
************************************************************************
* NOM         : QUAFME
* DESCRIPTION :
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 01/12/2004, version initiale
* HISTORIQUE : v1, 01/12/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' QUAFME ;
'REPETER' bcl ;
   'ARGUMENT' mquad/'MAILLAGE' ;
   'SI' ('EXISTE' mquad) ;
      mquaf = 'CHANGER' mquad 'QUAF' ;
*      mlin = 'CHANGER' mquad 'LINEAIRE' ;
      'RESPRO' mquaf ;
   'SINON' ;
      'QUITTER' bcl ;
   'FINSI' ;
'FIN' bcl ;
'FINPROC' ;
*
* End of procedure file QUAFME
*
*ENDPROCEDUR quafme
*BEGINPROCEDUR surchpo
************************************************************************
* NOM         : SURCHPO
* DESCRIPTION : Surcharge un chpoint par un autre
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 17/05/2006, version initiale
* HISTORIQUE : v1, 17/05/2006, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' SURCHPO ;
'ARGUMENT' chpo1*'CHPOINT' ;
'ARGUMENT' chpo2*'CHPOINT' ;
tchpo = 'TABLE' ;
*
* Extraction des noms de composantes
*
lncomp = 'EXTRAIRE' chpo1 'COMP' ;
dlncomp = 'DIME' lncomp ;
'SI' ('EGA' dlncomp 0) ;
   'RESPRO' chpo2 ;
   'QUITTER' SURCHPO ;
'FINSI' ;
lncomp2 = 'EXTRAIRE' chpo2 'COMP' ;
'REPETER' iicomp dlncomp ;
   icomp = &iicomp ;
   com = 'EXTRAIRE' lncomp icomp ;
   ccom = 'EXCO' com chpo1 com ;
   'SI' ('EGA' (ISINLIS com lncomp2) 0) ;
      tchpo . icomp = ccom ;
   'SINON' ;
      ccom2 = 'EXCO' com chpo2 com ;
      mcc  = 'EXTRAIRE' ccom 'MAIL' ;
      mcc2 = 'EXTRAIRE' ccom2 'MAIL' ;
      mr = 'DIFF' mcc mcc2 ;
      ncom = '+' ('REDU' ccom mr)
                 ccom2 ;
      tchpo . icomp = ncom ;
   'FINSI' ;
'FIN' iicomp ;
'REPETER' iicomp dlncomp ;
   icomp = &iicomp ;
   chpo = tchpo . icomp ;
   'SI' ('EGA' icomp 1) ;
      chpot = chpo ;
   'SINON' ;
      chpot = chpot '+' chpo ;
   'FINSI' ;
'FIN' iicomp ;
'RESPRO' chpot ;
*
* End of procedure file SURCHPO
*
'FINPROC' ;
*ENDPROCEDUR surchpo
*BEGINPROCEDUR trvec
************************************************************************
* NOM         : TRVEC
* DESCRIPTION : Trace des champs de vecteurs.
*               Utile pour tracer des bilans de forces
*
*               Display vector fields.
*               Useful for visualization of force balance.
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 22/04/2011, version initiale
* HISTORIQUE : v1, 22/04/2011, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
*
*
'DEBPROC' TRVEC ;
*'ARGUMENT' tdisc*'TABLE' ;
*'ARGUMENT' motdom*'MOT' ;
'ARGUMENT' tdom*'MAILLAGE' ;
*
tvec = 'TABLE' ; ttit = 'TABLE' ;
i = 0 ;
lcoul = 'MOTS' 'JAUN' 'ROUG' 'BLAN' 'TURQ' 'VERT' 'OLIV'
 'AZUR' 'ORAN' 'VIOL' 'GRIS' 'OCEA' ;
*
'REPETER' livec ;
   'SI' ('EGA' i 0) ;
      'ARGUMENT' ccvec*'CHPOINT' ;
   'SINON' ;
      'ARGUMENT' ccvec/'CHPOINT' ;
   'FINSI' ;
   'SI' ('EXISTE' ccvec) ;
      'ARGUMENT' ttvec*'MOT' ;
   'SINON' ;
      'QUITTER' livec ;
   'FINSI' ;
   i = '+' i 1 ;
*   'MESSAGE' ('CHAINE' 'i=' i) ;
*   'LISTE' ccvec ;
*   'LISTE' tvec ;
   tvec . i = ccvec ;
   ttit . i = ttvec ;
'FIN' livec ;
'ARGUMENT' echv/'FLOTTANT' ;
'ARGUMENT' lnclk/'LOGIQUE' ;
'SI' ('NON' ('EXISTE' lnclk)) ;
   lnclk = faux ;
'FINSI' ;
*
lmax = 'PROG' ;
'REPETER' ii i ;
   mm = 'MAXIMUM' (tvec . &ii) 'ABS' ;
   lmax = 'ET' lmax ('PROG' mm) ;
'FIN' ii ;
mm = '+' ('MAXIMUM' lmax) 1.D-60 ;
'SI' ('NON' ('EXISTE' echv)) ;
   vmodo = 'EGA' ('VALEUR' 'MODE') 'AXIS' ;
   'SI' vmodo ; 'OPTI' 'MODE' 'PLAN' ; 'FINSI' ;
   ctail = gmass2 ('CHANGER' tdom 'QUAF') tdisc
      'NPRI' 'CSTE' 'FPRI' 1. 'NDUA' 'CSTE' 'FDUA' 1. ;
*   'LISTE' ctail ;
   'SI' vmodo ; 'OPTI' 'MODE' 'AXIS' ; 'FINSI' ;
   vdim = 'VALEUR' 'DIME' ;
   dimm = DEADUTIL 'DIMM' tdom ;
*   ctail = '**' ctail ('/' 1. ('-' vdim 1)) ;
   ctail = '**' ctail ('/' 1. dimm) ;
   tail = '**' ('*' ('MAXIMUM' ctail) ('MINIMUM' ctail)) 0.5 ;
*'LISTE' tail ;
*'LISTE' mm ;
   echv = '/' ('*' 0.9 tail) mm ;
'FINSI' ;
tit  = 'CHAINE' 'Max. =' (formar mm 2) ;
*'MESSAGE' ('CHAINE' 'mm=' mm) ;
'REPETER' ii i ;
   cou = EXMOMOD lcoul &ii ;
   tvec . &ii = 'VECT' (tvec . &ii) echv 'DEPL' cou ;
   tit = 'CHAINE' tit ' ' cou '=' (ttit . &ii) ;
'FIN' ii ;
'SI' lnclk ;
   'TRACER' (@stbl tvec) tdom 'TITR' tit 'NCLK' ;
'SINON' ;
   'TRACER' (@stbl tvec) tdom 'TITR' tit ;
'FINSI' ;
*
* End of procedure file TRVEC
*
'FINPROC' ;
*ENDPROCEDUR trvec
*BEGINPROCEDUR tsurktan
************************************************************************
* NOM         : TSURKTAN
* DESCRIPTION : La matrice tangente pour la tension de surface
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 17/01/2007, version initiale
* HISTORIQUE : v1, 17/01/2007, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' TSURKTAN ;
'ARGUMENT' _mt*'MAILLAGE' ;
'ARGUMENT' gdisc*'MOT' ;
'ARGUMENT' methgau*'MOT' ;
'ARGUMENT' dppri*'LISTMOTS' ;
'ARGUMENT' dpdua*'LISTMOTS' ;
*
dpdis = gdisc ;
*
idim = 'VALEUR' 'DIME' ;
vdim = DEADUTIL 'DIMM' _mt ;
laxi = DEADUTIL 'AXI?' ;
lsph = DEADUTIL 'SPH?' ;
*
loi = 'CHAINE' 'TSUJ' ;
loij = 'CHAINE' 'TSU' ;
*
'ARGUMENT' coef/'FLOTTANT' ;
   'SI' ('NON' ('EXISTE' coef)) ;
      'ARGUMENT' coef2/'CHPOINT ' ;
      'SI' ('NON' ('EXISTE' coef2)) ;
         'ERREUR' 'Il faut donner un coef FLOTTANT ou CHPOINT' ;
      'SINON' ;
         coef = coef2 ;
         'ARGUMENT' discc*'MOT     ' ;
      'FINSI' ;
   'SINON' ;
      discc = 'CSTE' ;
   'FINSI' ;
*
'ARGUMENT' jaco/'ENTIER' ;
'SI' ('NON' ('EXISTE' jaco)) ;
   jaco = 1 ;
   dir1 = VRAI ;
'FINSI' ;
'SI' ('OU' ('EGA' jaco 2) ('EGA' jaco 3)) ;
   'ARGUMENT' idir/'ENTIER' ;
   'SI' ('EXISTE' idir) ;
      ldir = 'LECT' idir ;
      'SI' ('EGA' idir 1) ;
         dir1 = VRAI ;
      'FINSI' ;
   'SINON' ;
      'ARGUMENT' ldir/'LISTENTI' ;
      'SI' ('NON' ('EXISTE' ldir)) ;
         ldir = 'LECT' 1 'PAS' 1 idim ;
         dir1 = VRAI ;
      'FINSI' ;
   'FINSI' ;
'FINSI' ;
'ARGUMENT' lterm/'LISTENTI' ;
llterm = 'EXISTE' lterm ;
'SI' llterm ;
   dlterm = 'DIME' lterm ;
'SINON' ;
   dlterm = 1 ;
'FINSI' ;
*
* Calcul du jacobien complet (jaco = 1)
*
'SI' ('EGA' jaco 1) ;
   numop  = '*' ('**' vdim 2) ('**' idim 2) ;
   numop = '*' numop dlterm ;
   'SI' ('OU' laxi lsph) ;
      numop  = '+' numop ('*' (vdim '*' idim) 2) ;
   'FINSI' ;
   'SI' lsph ;
      numop = '+' numop 1 ;
   'FINSI' ;
   numder = vdim ;
   numvar = idim ;
   numdat = 0 ;
   numcof = 0 ;
*
   A = ININLIN numop numvar numdat numcof numder ;
   numdat = 1 ;
   numcof = numop ;
   B = ININLIN numop numvar numdat numcof numder ;
   'REPETER' ivar numvar ;
      A . 'VAR' . &ivar . 'NOMDDL' = 'MOTS' ('EXTRAIRE' dppri &ivar) ;
      A . 'VAR' . &ivar . 'DISC'   = dpdis ;
      B . 'VAR' . &ivar . 'NOMDDL' = 'MOTS' ('EXTRAIRE' dpdua &ivar) ;
      B . 'VAR' . &ivar . 'DISC'   = dpdis ;
   'FIN' ivar ;
   iop = 0 ;
   'REPETER' h dlterm ;
      'REPETER' i idim ;
         'REPETER' j vdim ;
            'REPETER' k idim ;
               'REPETER' l vdim ;
                  iop = iop '+' 1 ;
                  A . iop . &i . &j  = 'LECT' ;
                  'SI' llterm ;
                     nl = 'EXTRAIRE' lterm &h ;
                     nomloi = 'CHAINE' loij nl &i &j &k &l ;
                  'SINON' ;
                     nomloi = 'CHAINE' loi &i &j &k &l ;
                  'FINSI' ;
*              'MESSAGE' ('CHAINE' 'Nomloi=' nomloi) ;
                  B . 'COF' . iop . 'COMPOR' = nomloi ;
                  B . 'COF' . iop . 'LDAT'   = 'LECT' 1 ;
                  B . iop . &k . &l  = 'LECT' iop ;
               'FIN' l ;
            'FIN' k ;
         'FIN' j ;
      'FIN' i ;
   'FIN' h ;
   'SI' ('OU' laxi lsph) ;
      'REPETER' i idim ;
         'REPETER' j vdim ;
            iop = iop '+' 1 ;
            A . iop . &i . &j  = 'LECT' ;
            nomloi = 'CHAINE' loi &i &j '10' ;
*              'MESSAGE' ('CHAINE' 'Nomloi=' nomloi) ;
            B . 'COF' . iop . 'COMPOR' = nomloi ;
            B . 'COF' . iop . 'LDAT'   = 'LECT' 1 ;
            B . iop . 1 . 0  = 'LECT' iop ;
         'FIN' j ;
      'FIN' i ;
      'REPETER' k idim ;
         'REPETER' l vdim ;
            iop = iop '+' 1 ;
            A . iop . 1 . 0  = 'LECT' ;
            nomloi = 'CHAINE' loi '10' &k &l ;
*              'MESSAGE' ('CHAINE' 'Nomloi=' nomloi) ;
            B . 'COF' . iop . 'COMPOR' = nomloi ;
            B . 'COF' . iop . 'LDAT'   = 'LECT' 1 ;
            B . iop . &k . &l  = 'LECT' iop ;
         'FIN' l ;
      'FIN' k ;
   'FINSI' ;
   'SI' lsph  ;
      iop = iop '+' 1 ;
      A . iop . 1 . 0  = 'LECT' ;
      nomloi = 'CHAINE' loi '1010' ;
*      'MESSAGE' ('CHAINE' 'Nomloi=' nomloi) ;
      B . 'COF' . iop . 'COMPOR' = nomloi ;
      B . 'COF' . iop . 'LDAT'   = 'LECT' 1 ;
      B . iop . 1 . 0  = 'LECT' iop ;
   'FINSI' ;
'FINSI' ;
'SI' ('EGA' jaco 2) ;
   nldir = 'DIME' ldir ;
   numop  = '*' nldir ('**' vdim 2) ;
   'SI' dir1 ;
      'SI' ('OU' laxi lsph) ;
         numop = '+' numop ('*' vdim 2) ;
      'FINSI' ;
      'SI' lsph ;
         numop = '+' numop 1 ;
      'FINSI' ;
   'FINSI' ;
*
   numder = vdim ;
   numvar = idim ;
   numdat = 0 ;
   numcof = 0 ;
*
   A = ININLIN numop numvar numdat numcof numder ;
   numdat = 1 ;
   numcof = numop ;
   B = ININLIN numop numvar numdat numcof numder ;
   'REPETER' ivar numvar ;
      A . 'VAR' . &ivar . 'NOMDDL' = 'MOTS' ('EXTRAIRE' dppri &ivar) ;
      A . 'VAR' . &ivar . 'DISC'   = dpdis ;
      B . 'VAR' . &ivar . 'NOMDDL' = 'MOTS' ('EXTRAIRE' dpdua &ivar) ;
      B . 'VAR' . &ivar . 'DISC'   = dpdis ;
   'FIN' ivar ;
   iop = 0 ;
   'REPETER' i nldir ;
      idir = 'EXTRAIRE' ldir &i ;
      'REPETER' j vdim ;
         'REPETER' l vdim ;
            iop = iop '+' 1 ;
            A . iop . idir . &j  = 'LECT' ;
            nomloi = 'CHAINE' loi idir &j idir &l ;
*               'MESSAGE' ('CHAINE' 'Nomloi=' nomloi) ;
            B . 'COF' . iop . 'COMPOR' = nomloi ;
            B . 'COF' . iop . 'LDAT'   = 'LECT' 1 ;
            B . iop . idir . &l  = 'LECT' iop ;
         'FIN' l ;
      'FIN' j ;
   'FIN' i ;
   'SI' dir1 ;
      'SI' ('OU' laxi lsph) ;
         'REPETER' j vdim ;
            iop = iop '+' 1 ;
            A . iop . 1 . &j  = 'LECT' ;
            nomloi = 'CHAINE' loi '1' &j '10' ;
*               'MESSAGE' ('CHAINE' 'Nomloi=' nomloi) ;
            B . 'COF' . iop . 'COMPOR' = nomloi ;
            B . 'COF' . iop . 'LDAT'   = 'LECT' 1 ;
            B . iop . 1 . 0  = 'LECT' iop ;
         'FIN' j ;
         'REPETER' l vdim ;
            iop = iop '+' 1 ;
            A . iop . 1 . 0 = 'LECT' ;
            nomloi = 'CHAINE' loi '101' &l ;
*               'MESSAGE' ('CHAINE' 'Nomloi=' nomloi) ;
            B . 'COF' . iop . 'COMPOR' = nomloi ;
            B . 'COF' . iop . 'LDAT'   = 'LECT' 1 ;
            B . iop . 1 . &l  = 'LECT' iop ;
         'FIN' l ;
      'FINSI' ;
      'SI' lsph ;
         iop = iop '+' 1 ;
         A . iop . 1 . 0  = 'LECT' ;
         nomloi = 'CHAINE' loi '1010' ;
*      'MESSAGE' ('CHAINE' 'Nomloi=' nomloi) ;
         B . 'COF' . iop . 'COMPOR' = nomloi ;
         B . 'COF' . iop . 'LDAT'   = 'LECT' 1 ;
         B . iop . 1 . 0  = 'LECT' iop ;
      'FINSI' ;
   'FINSI' ;
'FINSI' ;
*
'SI' ('EGA' jaco 3) ;
   nldir = 'DIME' ldir ;
*   numop  = '**' vdim 2 ;
   numop  = '*' nldir vdim ;
   'SI' ('ET' dir1 lsph) ;
      numop = '+' numop 1 ;
   'FINSI' ;
*
   numder = vdim ;
   numvar = idim ;
   numdat = 0 ;
   numcof = 0 ;
*
   A = ININLIN numop numvar numdat numcof numder ;
   numdat = 1 ;
   numcof = numop ;
   B = ININLIN numop numvar numdat numcof numder ;
   'REPETER' ivar numvar ;
      A . 'VAR' . &ivar . 'NOMDDL' = 'MOTS' ('EXTRAIRE' dppri &ivar) ;
      A . 'VAR' . &ivar . 'DISC'   = dpdis ;
      B . 'VAR' . &ivar . 'NOMDDL' = 'MOTS' ('EXTRAIRE' dpdua &ivar) ;
      B . 'VAR' . &ivar . 'DISC'   = dpdis ;
   'FIN' ivar ;
   iop = 0 ;
   'REPETER' i nldir ;
      idir = 'EXTRAIRE' ldir &i ;
      'REPETER' j vdim ;
         iop = iop '+' 1 ;
         A . iop . idir . &j  = 'LECT'  ;
         nomloi = 'CHAINE' loi idir &j idir &j ;
*               'MESSAGE' ('CHAINE' 'Nomloi=' nomloi) ;
         B . 'COF' . iop . 'COMPOR' = nomloi ;
         B . 'COF' . iop . 'LDAT'   = 'LECT' 1 ;
         B . iop . idir . &j  = 'LECT' iop ;
      'FIN' j ;
   'FIN' i ;
   'SI' ('ET' dir1 lsph) ;
      iop = iop '+' 1 ;
      A . iop . 1 . 0  = 'LECT' ;
      nomloi = 'CHAINE' loi '1010' ;
*      'MESSAGE' ('CHAINE' 'Nomloi=' nomloi) ;
      B . 'COF' . iop . 'COMPOR' = nomloi ;
      B . 'COF' . iop . 'LDAT'   = 'LECT' 1 ;
      B . iop . 1 . 0  = 'LECT' iop ;
   'FINSI' ;
'FINSI' ;
*
* Partie commune
*
   B . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
   B . 'DAT' . 1 . 'DISC'   = discc ;
   B . 'DAT' . 1 . 'VALEUR' = coef ;
*
jac = 'NLIN' gdisc _mt A B 'EREF' methgau ;
*
'RESPRO' jac ;
*
* End of procedure file TSURKTAN
*
'FINPROC' ;
*ENDPROCEDUR tsurktan
*BEGINPROCEDUR tsurresi
************************************************************************
* NOM         : TSURRESI
* DESCRIPTION : Le résidu à annuler pour la tension de surface
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 17/01/2007, version initiale
* HISTORIQUE : v1, 17/01/2007, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' TSURRESI ;
'ARGUMENT' _mt*'MAILLAGE' ;
'ARGUMENT' gdisc*'MOT' ;
'ARGUMENT' methgau*'MOT' ;
'ARGUMENT' dpdua*'LISTMOTS' ;
*
dpdis = gdisc ;
*
idim  = 'VALEUR' 'DIME' ;
vdim  = DEADUTIL 'DIMM' _mt ;
laxi = DEADUTIL 'AXI?' ;
lsph = DEADUTIL 'SPH?' ;
*
loi = 'CHAINE' 'TSUR' ;
*
'ARGUMENT' coef/'FLOTTANT' ;
   'SI' ('NON' ('EXISTE' coef)) ;
      'ARGUMENT' coef2/'CHPOINT ' ;
      'SI' ('NON' ('EXISTE' coef2)) ;
         'ERREUR' 'Il faut donner un coef FLOTTANT ou CHPOINT' ;
      'SINON' ;
         coef = coef2 ;
         'ARGUMENT' discc*'MOT     ' ;
      'FINSI' ;
   'SINON' ;
      discc = 'CSTE' ;
   'FINSI' ;
*
dir1 = FAUX ;
'ARGUMENT' idir/'ENTIER' ;
'SI' ('EXISTE' idir) ;
   ldir = 'LECT' idir ;
   'SI' ('EGA' idir 1) ;
      dir1 = VRAI ;
   'FINSI' ;
'SINON' ;
   'ARGUMENT' ldir/'LISTENTI' ;
   'SI' ('NON' ('EXISTE' ldir)) ;
      ldir = 'LECT' 1 'PAS' 1 idim ;
      dir1 = VRAI ;
   'FINSI' ;
'FINSI' ;
*
* Calcul du résidu
*
nldir = 'DIME' ldir ;
*
numop  = '*' nldir vdim ;
term1 = ('OU' laxi lsph) 'ET' dir1 ;
'SI' term1 ;
   numop = '+' numop 1 ;
'FINSI' ;
numder = vdim ;
numvar = 1 ;
numdat = 0 ;
numcof = 0 ;
*
   A = ININLIN numop numvar numdat numcof numder ;
   A . 'VAR' . 1 . 'NOMDDL' = 'MOTS' 'DUMM' ;
   A . 'VAR' . 1 . 'DISC'   = 'CSTE' ;
   A . 'VAR' . 1 . 'VALEUR' = 1.D0 ;
*
   numvar = idim ;
   numdat = 1 ;
   numcof = numop ;
   B = ININLIN numop numvar numdat numcof numder ;
   'REPETER' ivar numvar ;
      B . 'VAR' . &ivar . 'NOMDDL' = 'MOTS' ('EXTRAIRE' dpdua &ivar) ;
      B . 'VAR' . &ivar . 'DISC'   = dpdis ;
   'FIN' ivar ;
*
   B . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
   B . 'DAT' . 1 . 'DISC'   = discc ;
   B . 'DAT' . 1 . 'VALEUR' = coef ;
*
   iop = 0 ;
   'REPETER' k nldir ;
      idir = 'EXTRAIRE' ldir &k ;
      'REPETER' l vdim ;
         iop = '+' iop 1 ;
         A . iop . 1 . 0  = 'LECT' ;
         nomloi = 'CHAINE' loi idir &l ;
*         'MESSAGE' ('CHAINE' 'Nomloi=' nomloi) ;
         B . 'COF' . iop . 'COMPOR' = nomloi ;
         B . 'COF' . iop . 'LDAT'   = 'LECT' 1 ;
         B . iop . idir . &l  = 'LECT' iop ;
      'FIN' l ;
   'FIN' k ;
*   'LISTE' A ; 'LISTE' iop ;
   'SI' term1 ;
      iop = '+' iop 1 ;
      A . iop . 1 . 0  = 'LECT' ;
      nomloi = 'CHAINE' loi '10' ;
      B . 'COF' . iop . 'COMPOR' = nomloi ;
      B . 'COF' . iop . 'LDAT'   = 'LECT' 1 ;
      B . iop . 1 . 0  = 'LECT' iop ;
   'FINSI' ;
*
res = 'NLIN' gdisc _mt A B 'EREF' methgau ;
*
'RESPRO' res ;
*
* End of procedure file TSURRESI
*
'FINPROC' ;
*ENDPROCEDUR tsurresi
*BEGINPROCEDUR vide
************************************************************************
* NOM         : VIDE
* DESCRIPTION : Construit un objet vide
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 14/09/2004, version initiale
* HISTORIQUE : v1, 14/09/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' VIDE ;
'REPETER' bcl ;
'ARGUMENT' typ/'MOT' ;
'SI' ('NON' ('EXISTE' typ)) ;
   'QUITTER' bcl ;
'FINSI' ;
vdim = 'VALEUR' 'DIME' ;
'SI' ('EGA' vdim 1) ;
   p1 = 'POIN' 0. ;
'FINSI' ;
'SI' ('EGA' vdim 2) ;
   p1 = 'POIN' 0. 0. ;
'FINSI' ;
'SI' ('EGA' vdim 3) ;
   p1 = 'POIN' 0. 0. 0.;
'FINSI' ;
p2 = 'PLUS' p1 p1 ;
mp1 = 'MANUEL' 'POI1' p1 ;
mp2 = 'MANUEL' 'POI1' p2 ;
'SI' ('EGA' typ 'MAIL') ;
   mailvid = mp1 'ELEM' 'APPUYE' 'STRICTEMENT' mp2 'NOVERIF' ;
   'RESPRO' mailvid ;
'FINSI' ;
'SI' ('EGA' typ 'CHPO') ;
   chp1 = 'MANUEL' 'CHPO' mp1 1 'T' 0.D0 'NATURE' 'DISCRET' ;
   chpvid = 'EXCO' 'Q' chp1 'NOID' ;
   'RESPRO' chpvid ;
'FINSI' ;
'SI' ('EGA' typ 'RIGI') ;
   rig1 = 'MANUEL' 'RIGIDITE' mp1 ('MOTS' 'T') ('PROG' 0.D0) ;
   rigvid = 'EXTRAIRE' rig1 'RIGI' 'MULT' ;
   'RESPRO' rigvid ;
'FINSI' ;
'FIN' bcl ;
*
* End of procedure file VIDE
*
'FINPROC' ;
*ENDPROCEDUR vide
**
************************************************************************
*
*
*   END OF PROCEDURES
*
*
************************************************************************
************************************************************************
*
*
*   MAIN : 1) MESH
*          2) COMPUTATIONAL LOOP
*          3) TESTs
*
************************************************************************
*
* Construction du "modèle" (maillage)
* et des paramètres de départ
*
'SI' complet ;
   raff = 3 ;
   nitermax = 25 ;
   critnf = 5.D-4 ;
   critdf = 5.D-4 ;
'SINON' ;
   raff = 2 ;
   nitermax = 15 ;
   critnf = 5.D-3 ;
   critdf = 5.D-3 ;
'FINSI' ;
*
* si clbloq : on utilise les blocages pour les clim de Dirichlet
clbloq = vrai ;
*omegn = 0.5 ; nitn = 20 ; critn = 5.D-3 ;
*omegd = 0.5 ; nitd = 20 ; critd = 1.D-1 ; nbck = 16 ;
omegn = 0.75 ; nitn = 1 ; critn = 1.D-3 ;
omegd = 0.75 ; nitd = 20 ; critd = 1.D-3 ; nbck = 1 ;
tbfor = faux ;
tjaco = FAUX ;
lpdro = vrai ;
idir = 1 ; jacoxf = 3 ; jacoxg = 0 ; jacoxv = 0 ;
           jacoxt = 'LECT' 1 2 3 4;
lrest = 'EGA' ('TYPE' tdisc) 'TABLE' ;
'SI' ('NON' lrest) ;
discg = 'QUAF' ; discv = 'QUAF' ; discp = 'LINM' ;
*
vdim = 'VALEUR' 'DIME' ;
vmod = 'VALEUR' 'MODE' ;
*
* Numérique
*
*
rsou = 1. ; lav = 20. ; lap = 20. ; prof = 20. ;
diam = '*' rsou 2. ;
*
*
* Création du maillage
*
tdisc = DEFMAIL rsou lav lap prof raff ;
tdisc . 'methgau' = 'TABLE' ;
tdisc . 'methgau' . 'mass' = 'GAM2' ;
tdisc . 'methgau' . 'amor'  = 'GAM2' ;
tdisc . 'methgau' . 'rigi'  = 'GAR2' ;
*tdisc . 'methgau' . 'mass' = 'GAU7' ;
*tdisc . 'methgau' . 'amor'  = 'GAU7' ;
*tdisc . 'methgau' . 'rigi'  = 'GAU7' ;
*
DISCG  = TDISC . 'GEOM' . 'DISC' ;
DISCU  = TDISC . 'XN' . 'DISC' ;
DISCV  = TDISC . 'UN' . 'DISC' ;
NOMDEP = @STBL (TDISC . 'XN' . 'NOMINC') ;
NOMVIT = @STBL (TDISC . 'UN' . 'NOMINC') ;
NOMPRE = @STBL (TDISC . 'PN' . 'NOMINC') ;
NOMFOR = @STBL (TDISC . 'FN' . 'NOMINC') ;
*
*
_mtw  = tdisc . 'mtw' . 'QUAF' ;
_cmtw  = tdisc . 'cmtw' . 'QUAF' ;
_hau = tdisc . 'hau' . 'QUAF' ;
_gau = tdisc . 'gau' . 'QUAF' ;
_bas = tdisc . 'bas' . 'QUAF' ;
_dro = tdisc . 'dro' . 'QUAF' ;
mtw = tdisc . 'mtw' . discg ;
cmtw = tdisc . 'cmtw' . discg ;
mdes = cmtw ;
hau = tdisc . 'hau' . discg ;
gau = tdisc . 'gau' . discg ;
bas = tdisc . 'bas' . discg ;
dro = tdisc . 'dro' . discg ;
'SI' ('EGA' vdim 3) ;
   _fro = tdisc . 'fro' .'QUAF' ;
    fro = tdisc . 'fro' . discg  ;
   _rea = tdisc . 'rea' .'QUAF' ;
    rea = tdisc . 'rea' . discg  ;
   _dhau = tdisc . 'dhau' .'QUAF' ;
    dhau = tdisc . 'dhau' . discg  ;
    amtw = 'ARETE' mtw ;
    mdes = amtw ;
'FINSI' ;
*
*list vdim;
*list ('PROG' vdim * 0.);

* CB215821 : Ancienne syntaxe supprimee en 2015
*pA = 'POIN' hau  'PROC' ('POIN' ('PROG' vdim * 0.)) ;
*mpA = 'COULEUR' ('MANUEL' 'POI1' pA) 'ROUG' ;
* Maillage pour les blocages en vitesse
*'TRACER' 'CACH' mtw 'TITR' ('CHAINE' 'nbl=' ('NBEL' mtw))
*   'NCLK' ;
*
'SI' ('EGA' vdim 2) ;
   pA  = 'POIN' hau  'PROC' ('POIN' 0. 0. ) ;
   mpA = 'COULEUR' ('MANUEL' 'POI1' pA) 'ROUG' ;

   mblux = gau ;
   mblux = 'COULEUR' ('CHANGER' 'POI1' mblux) 'ROUG' ;
   mblun = 'COULEUR' ('CHANGER' 'POI1' hau) 'ROUG' ;
*   mbluy = gau 'ET' bas 'ET' dro ;
   mbluy = gau 'ET' bas ;
   mbluy = 'CHANGER' mbluy 'POI1' ;
   mpoi = 'INTERSECTION' mblun mbluy ;
   'SI' ('NEG' ('NBEL' mpoi) 0) ;
      mbluy = 'DIFF' mbluy mpoi ;
   'FINSI' ;
   mbluy = 'COULEUR' mbluy 'ROUG' ;
*mblpn = 'POIN' (GMAIL _mtr 'PN') 'INITIAL' ;
'FINSI' ;
'SI' ('EGA' vdim 3) ;
   pA  = 'POIN' hau  'PROC' ('POIN' 0. 0. 0.) ;
   mpA = 'COULEUR' ('MANUEL' 'POI1' pA) 'ROUG' ;

   mblux = gau ;
   mblux = 'COULEUR' ('CHANGER' 'POI1' mblux) 'ROUG' ;
   mbluy = gau 'ET' fro 'ET' rea ;
   mbluy = 'COULEUR' ('CHANGER' 'POI1' mbluy) 'ROUG' ;
   mblun = 'COULEUR' ('CHANGER' 'POI1' hau) 'ROUG' ;
   mbluz = gau 'ET' bas ;
   mbluz = 'CHANGER' mbluz 'POI1' ;
   mpoi = 'INTERSECTION' mblun mbluz ;
   'SI' ('NEG' ('NBEL' mpoi) 0) ;
      mbluz = 'DIFF' mbluz mpoi ;
   'FINSI' ;
   mbluz = 'COULEUR' mbluz 'ROUG' ;
*mblpn = 'POIN' (GMAIL _mtr 'PN') 'INITIAL' ;
'FINSI' ;

'SI' faux ;
   mdd =mtw ;
   'SI' ('EGA' vdim 3);  mdd = cmtw ; 'FINSI' ;
   'TRACER' ('ET' mdd mpA) 'TITR' 'Point dobservation pA' ;
   'TRACER' ('ET' mdd mblux) 'TITR' 'Blocage UX' ;
   'TRACER' ('ET' mdd mbluy) 'TITR' 'Blocage UY' ;
   'TRACER' ('ET' mdd mblun) 'TITR' 'Blocage UN' ;
'FINSI' ;
*   'OPTI' 'MODE' plan ;
met = calimet _mtw discg 'GAU1' ;
************************************************************************
*
* COMPUTATIONAL LOOP
*
************************************************************************
* Re : nombre de Reynolds (convection / viscosité)
* Eu : nombre d'Euler (pression imposée / convection)
* FrEu : nombre de Froude * nombre d'Euler (pression imposée / gravité)
* We : (pression imposée / tension de surface)
*
'DEBPROC' calcul ;
'ARGUMENT' Re*'FLOTTANT' ;
'ARGUMENT' Eu*'FLOTTANT' ;
'ARGUMENT' FrEu*'FLOTTANT' ;
'ARGUMENT' We*'FLOTTANT' ;
*
ckonv = '/' 1. Eu ;
crig  = '/' 1. ('*' Re Eu) ;
cgra  = '/' 1. FrEu ;
ctsur = '/' 1. We. ;
*
nomdir = 'CHAINE' '/test4/gounand/kong/' ;
nomfic = 'CHAINE' 'defila' vdim 'd'
                        'Re' (MYENT Re)
                        'Eu' (MYENT Eu)
                        'FE' (MYENT FrEu)
                        'We' (MYENT We)
                        'r' raff ;
*
* Boucle d'itérations
*
vol = GVOL _cmtw tdisc faux ;
'SI' debug ;
'MESSAGE' ('CHAINE' 'Volume  initial = ' (formar vol 2)) ;
'FINSI' ;
pini = 0. ;
delp = 0. ; delp2 = 0. ;
lza  = 'PROG' ;
*
sol   = vide 'CHPO' ;
itcou = 0 ;
*tc smise en commentaire deu finsi cidessous
*'FINSI';
*DEFSUMM ;
'REPETER' it nitermax ;
*      'MESSAGE' ('CHAINE' 'itcou = ' ('+' itcou 1)) ;
      'SI' lpdro ; delp = '+' delp delp2 ; 'FINSI' ;
*
* Problème volumique
*
   'REPETER' itn nitn ;
      sol = 'EXCO' (nomvit 'ET' nompre) sol 'NOID' ;
*      'MESSAGE' ('CHAINE' 'itn = ' &itn) ;
*
* Terme de pression
*
      'SI' ('EGA' vdim 2) ;
         rhau = 'COORDONNEE' 1 hau ;
      'SINON' ;
*         rhau = 'COORDONNEE' 1 hau ;
         xhau = 'COORDONNEE' 1 hau ;
         yhau = 'COORDONNEE' 2 hau ;
         rhau = '**' ('+' ('**' xhau 2) ('**' yhau 2)) 0.5 ;
      'FINSI' ;
      pfor = 'EXP' ('*' ('**' ('/' rhau rsou) 2) -1.) ;
      fpfor = GFORC _hau tdisc pfor ;
      ktforx = GKFORC _hau tdisc pfor jacoxf ;
*      ktforx0 = GKFORC _hau tdisc pfor 0 ;
      'SI' ('EGA' jacoxf 3) ;
         ktforx = '*' ktforx 0. ;
      'FINSI' ;
*      TRVEC hau fpfor 'FPFOR' ;
*
*  Terme de gravité
*
      fpgra = GGRAVI _hau tdisc cgra 0. ;
      ktgrax = GKGRAVI _hau tdisc jacoxg ('*' cgra -1.) 0. ;
*      ktgrax0 = GKGRAVI _hau tdisc 0 ('*' cgra -1.) 0. ;
*
*  Tension de surface
*
      mgtens = tdisc . 'methgau' . 'rigi' ;
      ftsur = TSURRESI _hau discg mgtens nomvit ('*' -1. ctsur) ;
      'SI' tbfor ;
         ftsura = 'REDU' ftsur ('POIN' hau 'INITIAL') ;
         ftsur = '-' ftsur ftsura ;
      'FINSI' ;
      ktsurx = TSURKTAN _hau discg mgtens nomvit nomvit ('*' -1. ctsur)
         jacoxt ;
*      ktsurx0 = TSURKTAN _hau discg mgtens nomvit nomvit
*         ('*' -1. ctsur) ('LECT' 1 2 3 4) ;
*
* Terme de pression sur le bord droit
*
*      'MESSAGE' ('CHAINE' 'delp=' delp) ;
*      'MESSAGE' ('CHAINE' 'delp2=' delp2) ;
      'SI' lpdro ;
         lpn = 'PROG' vdim * 0. ;
         'REMPLACER' lpn 1 ('*' delp -1.) ;
         ftpdr = GMASS2 _dro tdisc 'NPRI' 'UN'
            'FPRI' lpn
            'NDUA' 'UN' ;
      'FINSI' ;
*
*  Rigidité
*
      gri = GRIG _mtw tdisc 'NPRI' 'UN' 'NDUA' 'UN' ;
      gri = '*' gri crig ;
* Autres matrices
      gugr = gugrad2 _mtw tdisc 'NPRI' 'UN' 'NDUA' 'UN'
                               'NVIT' 'UN' 'CVIT' sol ;
      gugr = '*' gugr ckonv ;
      gdiv = GDIV2 _mtw tdisc 'NPRI' 'UN' 'NDUA' 'PN' 'GBBT' ;
      gdiv = '*' gdiv -1. ;
* Blocages
      cblox = '+' ('MANUEL' 'CHPO' mblux 1 'UX' 0.)
                  ('MANUEL' 'CHPO' gau 1 'UX' 1.) ;
      'SI' clbloq ;
         mblox = 'BLOQUE' 'UX' mblux ;
         fblox = 'DEPIMPOSE' mblox cblox ;
         fblox = 'NOMC' 'LX' fblox ;
      'FINSI' ;
*
      cbloy =  'MANUEL' 'CHPO' mbluy 1 'UY' 0. ;
      'SI' clbloq ;
         mbloy = 'BLOQUE' 'UY' mbluy ;
      'FINSI' ;
      vnor = DEFDD tdisc 0 ;
      mblon = 'BLOQUE' 'DEPL' 'DIRE' vnor mblun ;
      mp = GMAIL _mtw 'PN' ;
*   mblop = 'BLOQUE' 'T' ('POIN' mp 'INITIAL') ;
      'SI' clbloq ;
         mblot = mblox 'ET' mbloy 'ET' mblon ;
      'SINON' ;
         cblot = cblox '+' cbloy ;
         mblot = mblon ;
      'FINSI' ;
      'SI' ('EGA' vdim 3) ;
         cbloz =  'MANUEL' 'CHPO' mbluz 1 'UZ' 0. ;
         mbloz = 'BLOQUE' 'UZ' mbluz ;
         'SI' clbloq ;
            mblot = mblot 'ET' mbloz ;
         'SINON' ;
            mblot = mblon ;
            cblot = cblot '+' cbloz ;
         'FINSI' ;
      'FINSI' ;
* Changement type et noms d'inconnues
      mpri = nomdep 'ET' ('MOTS' 'T' 'LX') ;
      mdua = nomfor 'ET' ('MOTS' 'Q' 'FLX') ;
      mfin = nomdep 'ET' ('MOTS' 'LX1' 'LX') ;
      'SI' clbloq ;
         'SI' lmatrik ;
            mbloxk = 'CHANGER' 'INCO' ('KOPS' 'RIMA' mblox)
               mpri mfin mdua mfin ;
            mbloyk = 'CHANGER' 'INCO' ('KOPS' 'RIMA' mbloy)
               mpri mfin mdua mfin ;
            'SI' ('EGA' vdim 3) ;
               mblozk = 'CHANGER' 'INCO' ('KOPS' 'RIMA' mbloz)
               mpri mfin mdua mfin ;
            'FINSI' ;
         'SINON' ;
            mbloxk = 'CHANGER' 'INCO' mblox
               mpri mfin mdua mfin 'MULT' ;
            mbloyk = 'CHANGER' 'INCO' mbloy
               mpri mfin mdua mfin 'MULT' ;
            'SI' ('EGA' vdim 3) ;
               mblozk = 'CHANGER' 'INCO' mbloz
               mpri mfin mdua mfin 'MULT' ;
            'FINSI' ;
         'FINSI' ;
      'FINSI' ;
      'SI' lmatrik ;
         mblonk = 'CHANGER' 'INCO' ('KOPS' 'RIMA' mblon)
            mpri mfin mdua mfin ;
         mblotk = 'CHANGER' 'INCO' ('KOPS' 'RIMA' mblot)
            mpri mfin mdua mfin ;
         gugrk = 'KOPS' 'RIMA' gugr ;
         grik  = 'KOPS' 'RIMA' gri ;
         gdivk = 'KOPS' 'RIMA' gdiv ;
      'SINON' ;
         mblonk = 'CHANGER' 'INCO' mblon
            mpri mfin mdua mfin 'MULT' ;
         mblotk = 'CHANGER' 'INCO' mblot
            mpri mfin mdua mfin 'MULT' ;
         gugrk = gugr ;
         grik  = gri ;
         gdivk = gdiv ;
      'FINSI' ;

      ktot = gugrk 'ET' grik 'ET' gdivk 'ET' mblotk ;
      ktg  = ('*' (gugrk 'ET' grik) ('/' 1. omegn)) 'ET' gdivk
         'ET' mblotk ;
      'SI' ('EGA' vdim 3) ;
         mpvid = GMASS2 _mtw tdisc 'NPRI' 'PN' 'NDUA' 'PN'
            'NCOF' 'CSTE' 'FCOF' 0. ;
         'SI' lmatrik ;
            mpvidk = 'KOPS' 'RIMA' mpvid ;
         'SINON' ;
            mpvidk = mpvid ;
         'FINSI' ;
         ktg = ktg 'ET' mpvidk ;
      'FINSI' ;
      ftot = vide 'CHPO' ;
      'SI' clbloq ;
         ftot = ftot '+' fblox ;
      'FINSI' ;
      'SI' tbfor ;
         ftot = ftot '+' fpgra '+' ftsur '+' fpfor ;
      'FINSI' ;
      'SI' lpdro ;
         ftot = '+' ftot ftpdr ;
      'FINSI' ;
      'SI' ('NON' clbloq) ;
         sol = SURCHPO sol cblot ;
      'FINSI' ;
      ftot = '-' ftot ('*' ktot sol) ;
*      'SI' tbfor ;
* Conditions de sortie libre (pas de force tangentielle)
* sur le dernier point de _hau
*         phauf = 'POIN' hau 'FINAL' ;
*         ftan = 'REDU' ftot phauf ;
*         ftanr = 'EXCO' 'UR' ftan 'UR' ;
*         ftanr = '*' ftanr -1. ;
*         ftot = '+' ftot ftanr ;
*      'FINSI' ;
*
*      cp  = 'MANUEL' 'CHPO' ('POIN' mp 'INITIAL')
*         1 ('EXTRAIRE' nompre 1) delp2 ;
*   ccl = cp ;
*   dsol = 'KRES' ktg ftot 'CLIM' ccl ;
      'SI' ('EGA' ('TYPE' ktg) 'RIGIDITE') ;
         ktgr = 'KOPS' 'NINCPRDU' ktg ;
         ftotr = 'KOPS' 'NINCPRDU' ftot ;
      'SINON' ;
         ktgr = ktg ;
         ftotr = ftot ;
      'FINSI' ;
      'SI' clbloq ;
         dsol = 'KRES' ktgr ftotr ;
      'SINON' ;
         dsol tt = 'KRES' ktgr ftotr 'CLIM' ('-' cblot cblot)
            'IMPR' 0 'RESID' 1.D-10 'PRECOND' 5
            'ILUTLFIL' 2. 'ILUTPPIV' 0.
            'TYPINV' 3 'LBCG' 2 'LTIME' VRAI ;
*         'LISTE' tt ;
      'FINSI' ;
      sol = '+' sol dsol ;
      vit = 'EXCO' nomdep sol ;
      pre = 'EXCO' nompre sol ;
      mdv  = 'MAXIMUM' dsol 'ABS' 'AVEC' nomvit ;
      mdvr = '/' mdv ('MAXIMUM' vit 'ABS') ;
      'SI' debug ;
      'MESSAGE' ('CHAINE' '  ' 'itn=' &itn
         ' mdv=' (formar mdv 2) ' mdvr=' (formar mdvr 2)) ;
      'FINSI' ;
*
*      JETPROF1 ('*' rsou 20.) VRAI ;
      'SI' ('EGA' vdim 2) ; rvit = vit ;
      'SINON' ; rvit = 'REDU' vit cmtw ; 'FINSI' ;
      'SI' (graph 'ET' interact) ;
         TRVEC mdes rvit 'Vit' vrai ;
      'FINSI' ;
** On enlève les multiplicateurs de Lagrange.
      'SI' ('<' mdvr critn) ;
         'QUITTER' itn ;
      'FINSI' ;
   'FIN' itn ;
*
* Post-traitement après calcul de la vitesse
*
   'SI' graph ;
      'SI' dbggra1 ; DEFVIT ; 'FINSI' ;
      'SI' dbggra2 ; DEFVSURF ; defvsurf ('*' rsou 5.) ;
*      'SINON' ; defvsurf ('*' rsou 5.) vrai ; attente 1. ;
      'FINSI' ;
   'FINSI' ;
*
* Forces
*
   fpre  = 'EXCO' nomdep ('*' ('*' gdivk -1.) sol) ;
   fblon = 'EXCO' nomdep ('*' ('*' mblonk -1.) sol) 'NOID' ;
   'SI' clbloq ;
      fblox = 'EXCO' nomdep ('*' ('*' mbloxk -1.) sol) 'NOID' ;
      fbloy = 'EXCO' nomdep ('*' ('*' mbloyk -1.) sol) 'NOID' ;
      'SI' ('EGA' vdim 3) ;
         fbloz = 'EXCO' nomdep ('*' ('*' mblozk -1.) sol) 'NOID' ;
      'FINSI' ;
   'FINSI' ;
   frig = ('*' ('*' grik -1.) sol) ;
   fugr = 'EXCO' nomdep ('*' ('*' gugr -1.) sol) ;
   desfq = fpre '+' frig '+' fugr '+' fblon ;
   'SI' clbloq ;
      desfq = desfq '+' fblox '+' fbloy ;
      'SI' ('EGA' vdim 3) ;
         desfq = '+' desfq fbloz ;
      'FINSI' ;
   'FINSI' ;
   'SI' tbfor ;
      desfq = desfq '+' fpgra '+' ftsur '+' fpfor ;
   'FINSI' ;
   'SI' graph ;
      'SI' ('ET' clbloq ('EGA' vdim 2)) ;
         'SI' dbggra1 ; DEFQFORV ; 'FINSI' ;
         'SI' dbggra1 ; DEFQFORS ('*' rsou 5.) ;
*         'SINON' ; DEFQFORS ('*' rsou 5.) vrai ;
         'FINSI' ;
      'FINSI' ;
   'FINSI' ;
*
* On a calculé les forces et le déséquilibre normal, on en déduit le
* déplacement normal
*
   'SI' tbfor ;
      desn = ('*' fblon -1.) ;
   'SINON' ;
      desn = ('*' fblon -1.) '+' fpgra '+' ftsur '+' fpfor ;
   'FINSI' ;
   ktotx = ktgrax 'ET' ktforx 'ET' ktsurx ;
   ktotx = '*' ktotx -1. ;
*
* Contrainte sur le volume
*
   volc = GVOL _cmtw tdisc ;
   dvol = ('-' vol volc) '*' -1. ;
   kvol = GKVOL _cmtw tdisc jacoxv ;
*
* Réduction du système sur l'inconnue déplacement normal
*
   vnorn = DEFDD tdisc idir ;
   vnor = vnorn ;
   ok = FAUX ;
   omd = omegd ;
   'REPETER' bck nbck ;
      ktot ftot = PROJSYSC tdisc vnor ('*' ktotx ('/' 1. omd))
         desn kvol dvol ;
      'SI' ('EGA' ('TYPE' ktot) 'RIGIDITE') ;
         ktotr = 'KOPS' 'NINCPRDU' ktot ;
         ftotr = 'KOPS' 'NINCPRDU' ftot ;
      'SINON' ;
         ktotr = ktot ;
         ftotr = ftot ;
      'FINSI' ;
      sold = 'KRES' ktotr ftotr ;
      dep  = '*' ('EXCO' 'SCAL' sold) vnor ;
      mdep = 'MAXIMUM' dep 'ABS' ;
      mdepr = '/' mdep prof ;
   odep = dep ;
*
* Bilan des forces
*
   fblonn = 'PSCAL' ('*' fblon -1.) vnor nomdep nomdep ;
   'SI' ('NON' tbfor) ;
      ffornn = 'PSCAL' fpfor vnor nomdep nomdep ;
      fgrann = 'PSCAL' fpgra vnor nomdep nomdep ;
      fsurnn = 'PSCAL' ftsur vnor nomdep nomdep ;
   'FINSI' ;
   mulag   = 'EXCO' 'LX' sold 'LX' ;
   delp2    = 'MAXIMUM' mulag ;
   fpvolnn = '*' ktot ('*' mulag -1.) ;
* Bilan des forces en surface
   'SI' tbfor ;
      desfd = fblonn '+' fpvolnn ;
   'SINON' ;
      desfd = fblonn '+' fgrann '+' fsurnn '+' ffornn '+' fpvolnn ;
   'FINSI' ;
*
   'SI' debug ;
   chmes = 'CHAINE' ' dvol=' (formar dvol 1) ;
   chmes2 = 'CHAINE' '  mdep=' (formar mdep 1)
                    ' mdepr=' (formar mdepr 1)
                    ' delp2=' (formar delp2 1) ;
      'SI' ('>' &bck 1) ;
         chmes = 'CHAINE' '! bck=' &bck ' ' chmes ;
      'FINSI' ;
      'MESSAGE' chmes ; 'MESSAGE' chmes2 ;
   'FINSI' ;
   'SI' graph ;
      'SI' ('EGA' vdim 2) ;
         'SI' dbggra2 ; DEFDFORS ;
*         'SINON' ; DEFDFORS ('*' 5. rsou) vrai ;
         'FINSI' ;
      'FINSI' ;
   'FINSI' ;
   'SI' ('<' mdep critd) ;
      'QUITTER' bck ;
   'SINON' ;
      omd = '/' omd 2. ;
   'FINSI' ;
   'FIN' bck ;
   'SI' ('ET' ('<' mdepr critdf) ('<' mdvr critnf)) ;
      itcou = '+' itcou 1 ;
      'QUITTER' it ;
   'FINSI' ;
*
* Déplacement du maillage
*
'SI' ('EGA' vdim 2) ;
   muy = bas 'ET' hau ;
   bux = 'BLOQUE' 'UX' mtw ;
   buy = 'BLOQUE' 'UY' muy ;
   cblo =  ('MANUEL' 'CHPO' cmtw 2 'UX' 0. 'UY' 0.) '+'
      odep ;
   ftot = 'DEPIMPOSE' buy cblo ;
   dxv = 'DEDU' adap mtw (bux 'ET' buy) ftot 'METR' met 'CSTE'
      'NITM' 1 ;
'SINON' ;
   muz = bas 'ET' hau ;
   bux = 'BLOQUE' 'UX' mtw ;
   buy = 'BLOQUE' 'UY' mtw ;
   buz = 'BLOQUE' 'UZ' muz ;
   btot = bux 'ET' buy 'ET' buz ;
   cblo =  ('MANUEL' 'CHPO' muz 1 'UZ' 0.) '+'
      odep ;
   ftot = 'DEPIMPOSE' buz cblo ;
   dxv = 'DEDU' adap mtw btot ftot 'METR' met 'CSTE'
      'NITM' 1 ;
'FINSI' ;
   'FORME' dxv ;
*
* Tracé du profil
*
   za = 'COORDONNEE' vdim pA ;
   zcmt = 'COORDONNEE' vdim hau ;
   miz = 'MINIMUM' zcmt ; maz = 'MAXIMUM' zcmt ;
   miv = 'MINIMUM' vit ; mav = 'MAXIMUM' vit ;
   'MESSAGE' ('CHAINE' 'It=' ('+' itcou 1)
      ' zA=' (formar zA 2) ' miz=' (formar miz 2)
         ' maz=' (formar maz 2)  ' miv=' (formar miv 2)
         ' mav=' (formar mav 2) ) ;
   lza = 'ET' lza ('PROG' zA) ;
   'SI' graph ;
      'SI' dbggra2 ; DEFZSURF ; defzsurf ('*' rsou 5.) ;
      'SINON' ; defzsurf ('*' rsou 5.) vrai ; 'FINSI' ;
   'FINSI' ;
   itcou = '+' itcou 1 ;
'FIN' it ;
*
'SI' graph ;
   dza = 'DIME' lza ;
   'SI' (> dza 1) ;
      lit = 'PROG' 1. 'PAS' 1 dza ;
      tabev = 'TABLE' ;   tabt  = 'TABLE' ;
      tabev . 1 = 'EVOL' 'MANU' lit lza ;
      tabt  . 1 = 'CHAINE' 'Z pA' ;
      tix = 'iter' ; tiy = 'z' ; tit = 'CHAINE' tiy '(' tix ')' ;
      dessevol (@STBL tabev) tabt tit tix tiy ;
   'FINSI' ;
'FINSI' ;
* list *MATRIK ;
'OUBL' KTG ; 'OUBL' KTOT ; 'OUBL' GDIVK ; 'OUBL'  GRIK  ;
'OUBL' GUGRK ; 'OUBL' MBLOTK  ; 'OUBL' MBLONK  ; 'OUBL' MBLOZK  ;
'OUBLIER'  MBLORK  ; 'OUBLIER' mbloyk ; 'OUBLIER' mbloxk ;
'OUBLIER' mpvidk ;
* list *rigidite ;
'OUBLIER' btot ;'OUBLIER' buz ; 'OUBLIER' mbloy ; 'OUBLIER' mblox ;
'OUBL'  BUY  ; 'OUBL' BUX ; 'OUBL'     KTOTX ; 'OUBL'   KTPREX0 ;
'OUBL' KTPREX ; 'OUBL'  KTDIVX2 ; 'OUBL' KTDIVX1 ; 'OUBL' KTUGRX0 ;
'OUBL' KTUGRX ; 'OUBL'  KTUGRX2 ; 'OUBL'  KTUGRX1 ; 'OUBL' KTRIGX0 ;
'OUBL' KTRIGX ; 'OUBL'  KTRIGX2 ; 'OUBL' KTRIGX1 ; 'OUBL' GMABS   ;
'OUBL' GMAB  ; 'OUBL'   GMAV  ; 'OUBL'   MBLOT ; 'OUBL'   MBLON ;
'OUBL'   MBLOZ  ; 'OUBL'  MBLOR  ; 'OUBL'  GUGR  ; 'OUBL'   GRI     ;
'OUBL' KTSURX0 ; 'OUBL' KTSURX ; 'OUBL'  KTGRAX0 ; 'OUBL' KTGRAX ;
'OUBLIER' ktforx0 ; 'OUBLIER' ktforx ;
'OUBL'  GDIV    ; 'OUBLIER' mpvid ;
*fic = 'CHAINE' nomdir nomfic 'it' itcou '.sauv' ;
*'MESSAGE' ('CHAINE' 'Saving ' fic '...') ;
*'OPTI' 'SAUV' fic ;
*'SAUV' ;
*'TEMPS' 'IMPR' ;
'SI' graph ;
*DEFSUMM ;
DEFVIT ;
*'SI' ('EGA' vdim 2) ;
*DEFQFORV ;
*DEFQFORS ;
*DEFQFORS ('*' rsou 5.) ;
*DEFDFORS ;
*DEFDFORS ('*' rsou 5.) ;
*'SINON' ;
*      TRVEC mdes ('REDU' vit cmtw) 'Vit' ;
*'FINSI' ;
DEFZSURF ;
*defzsurf ('*' rsou 5.) ;
*DEFVSURF ;
*defvsurf ('*' rsou 5.) ;
*'TRACER' ('ET' mtw cmtw) 'TITR' ('CHAINE' 'nbl=' ('NBEL' mtw)) ;
'FINSI' ;
'RESPRO' zA miz maz ;
'FINPROC' ;
************************************************************************
*
* END OF COMPUTATIONAL LOOP
*
************************************************************************
*
************************************************************************
*
* TEST PART
*
************************************************************************
*
lpass = VRAI ;
'SAUTER' 2 'LIGNE' ; 'OPTI' 'ECHO' 1 ;
***
*** Test 1  Re=50. Eu=10000.  FrEu=1. We=10000.
***
***         La pression imposée est équilibrée par le poids
***         de fluide déplacé. L'écoulement n'a pas
***         d'influence sur la forme de la surface.
***
***
'OPTI' 'ECHO' 0 ;
Re = 50. ;
Eu= 10000. ;
FrEu =  1. ;
We = 10000.  ;
lmatrik = faux ;
za miz maz = calcul Re Eu FrEu We ;
dz = '-' maz miz ;
* Reference values
zaref = -0.956 ; dzref = 1. ;
* Tests
AFFVAR zaref 'zaref' za 'za' ;
AFFVAR dzref 'dzref' dz 'dz' ;
errv = 2.D-2 ;
err1 = errrel za zaref ; tst1 = '<' err1 errv ;
err2 = errrel dz dzref ; tst2 = '<' err2 errv ;
tst = tst1 'ET' tst2 ;
'MESSAGE' ('CHAINE' 'Test 1 :')   ;
'MESSAGE' ('CHAINE' '         err1 = ' err1)  ;
'MESSAGE' ('CHAINE' '         err2 = ' err2)  ;
'SI' tst ;
   'MESSAGE' 'Test 1 OK' ;
'SINON' ;
   'MESSAGE' '!!! Test 1 not passed  ' ;
'FINSI' ;
lpass = lpass 'ET' tst ;
'SAUTER' 2 'LIGNE' ; 'OPTI' 'ECHO' 1 ;
***
*** Test 2  Re=50. Eu=10000.  FrEu=1. We=1.
***
***         La pression imposée est équilibrée par le poids
***         de fluide déplacé et la tension de surface.
***         L'écoulement n'a pas d'influence sur la forme de la surface.
***         On met lmatrik=vrai pour vérifier que l'algo marche
***         encore en MATRIK (les résultats doivent être strictement
***         identiques !)
***
'OPTI' 'ECHO' 0 ;
Re = 50. ;
Eu= 10000. ;
FrEu =  1. ;
We = 1.  ;
lmatrik = vrai ;
za miz maz = calcul Re Eu FrEu We ;
dz = '-' maz miz ;
* Reference values
zaref = -0.505 ; dzref = 0.55 ;
* Tests
AFFVAR zaref  'zaref' za 'za' ;
AFFVAR dzref 'dzref' dz 'dz' ;
errv = 2.D-2 ;
err1 = errrel za zaref ; tst1 = '<' err1 errv ;
err2 = errrel dz dzref ; tst2 = '<' err2 errv ;
tst = tst1 'ET' tst2 ;
'MESSAGE' ('CHAINE' 'Test 2 :')   ;
'MESSAGE' ('CHAINE' '         err1 = ' err1)  ;
'MESSAGE' ('CHAINE' '         err2 = ' err2)  ;
'SI' tst ;
   'MESSAGE' 'Test 2 OK' ;
'SINON' ;
   'MESSAGE' '!!! Test 2 not passed  ' ;
'FINSI' ;
lpass = lpass 'ET' tst ;
'SAUTER' 2 'LIGNE' ; 'OPTI' 'ECHO' 1 ;
***
*** Test 3  Re=50. Eu=1.  FrEu=1. We=1.
***
***         La pression imposée est équilibrée par le poids
***         de fluide déplacé et la tension de surface.
***         L'écoulement influence la forme de la surface (aspiration).
***
***
'OPTI' 'ECHO' 0 ;
Re = 50. ;
Eu= 1. ;
FrEu =  1. ;
We = 1.  ;
lmatrik = faux ;
za miz maz = calcul Re Eu FrEu We ;
dz = '-' maz miz ;
* Reference values
zaref = -1.07 ; dzref = 1.21 ;
* Tests
AFFVAR zaref  'zaref' za 'za' ;
AFFVAR dzref  'dzref' dz 'dz' ;
errv = 2.D-2 ;
err1 = errrel za zaref ; tst1 = '<' err1 errv ;
err2 = errrel dz dzref ; tst2 = '<' err2 errv ;
tst = tst1 'ET' tst2 ;
'MESSAGE' ('CHAINE' 'Test 3 :')   ;
'MESSAGE' ('CHAINE' '         err1 = ' err1)  ;
'MESSAGE' ('CHAINE' '         err2 = ' err2)  ;
'SI' tst ;
   'MESSAGE' 'Test 3 OK' ;
'SINON' ;
   'MESSAGE' '!!! Test 3 not passed  ' ;
'FINSI' ;
lpass = lpass 'ET' tst ;



'SAUTER' 2 'LIGNE' ;
'SI' lpass ;
   'MESSAGE' 'Tout sest bien passe' ;
'SINON' ;
   'MESSAGE' 'Il y a eu des erreurs' ;
'FINSI' ;
'SAUTER' 2 'LIGNE' ;
'SI' ('NON' lpass) ;
   'ERREUR' 5 ;
'FINSI' ;
************************************************************************
*
* END OF TEST PART
*
************************************************************************
'SI' interact ;
   'OPTION' 'DONN' 5 'ECHO' 1 ;
'FINSI' ;
*
'FIN' ;

















