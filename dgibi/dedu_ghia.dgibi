* fichier : dedu_ghia.dgibi
************************************************************************
* Section : Maillage Autres
* Section : Fluides Thermique
************************************************************************
'OPTI' 'ECHO' 0 ;
************************************************************************
* NOM         : DEDU_GHIA
* DESCRIPTION : Calcul de la cavité carrée à paroi défilante
*               (Navier-Stokes incompressible) pour plusieurs nombres de
*                Reynolds et comparaison avec les résultats de
*               référence de Ghia et al. :
*
*@Article{ghia,
*  author =       {U. Ghia and K.N. Ghia and C.T. Shin},
*  title =        {High-Re Solutions for Incompressible Flow Using the
*                  Navier-Stokes Equations and a Multigrid Method},
*  journal =      {JCP},
*  year =         {1982},
*  volume =    {48},
*  pages =     {387-411},
*  endroit = {Classeur Benchmarks (I)}
*}
*
*              On utilise une adaptation de maillage par bougé de noeuds
*              utilisant l'algorithme implémenté dans 'DEDU' 'ADAP'
*              pour calculer le cas avec peu de mailles et sans
*              viscosité artificielle (décentrement).
*              On arrive à passer Re= 10^4 avec un maillage 25x25
*              (ca oscille un peu sur les bords !)
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 13/04/2007, version initiale
* HISTORIQUE : v1, 13/04/2007, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
'SAUTER' 2 'LIGNE' ;
'MESSAGE' ' Execution de dedu_ghia.dgibi' ;
'SAUTER' 2 'LIGNE' ;
*
*
*
interact= FAUX ;
graph   = FAUX ;
verbose = FAUX ;
debug   = FAUX ;
complet = FAUX ;
*
*BEGINPROCEDUR gmass
************************************************************************
* NOM         : GMASS
* DESCRIPTION : Une matrice de masse
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v2, 14/03/2006, mise à jour NLIN évolué
* VERSION    : v1, 13/05/2004, version initiale
* HISTORIQUE : v1, 13/05/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' GMASS ;
'ARGUMENT'     _mt*'MAILLAGE' ;
'ARGUMENT'     _smt/'MAILLAGE' ;
'ARGUMENT'   gdisc*'MOT     ' ;
'ARGUMENT'   lnomt/'LISTMOTS' ;
'SI' ('NON' ('EXISTE' lnomt)) ;
   'ARGUMENT'    nomt*'MOT     ' ;
   lnomt = 'MOTS' nomt ;
'FINSI' ;
'ARGUMENT'   disct*'MOT     ' ;
'ARGUMENT'   lnomq/'LISTMOTS' ;
'SI' ('NON' ('EXISTE' lnomq)) ;
   'ARGUMENT'    nomq*'MOT     ' ;
   lnomq = 'MOTS' nomq ;
'FINSI' ;
'ARGUMENT'   discq*'MOT     ' ;
'ARGUMENT' coef/'FLOTTANT' ;
   'SI' ('NON' ('EXISTE' coef)) ;
      'ARGUMENT' coef2/'CHPOINT ' ;
      'SI' ('NON' ('EXISTE' coef2)) ;
         'ERREUR' 'Il faut donner un coef FLOTTANT ou CHPOINT' ;
      'SINON' ;
         coef = coef2 ;
         'ARGUMENT' discc*'MOT     ' ;
      'FINSI' ;
   'SINON' ;
      discc = 'CSTE' ;
   'FINSI' ;
'ARGUMENT' methgau/'MOT     ' ;
   'SI' ('NON' ('EXISTE' methgau)) ;
      methgau = 'GAU7' ;
   'FINSI' ;
'ARGUMENT' chpop/'CHPOINT' ;
'ARGUMENT' chpod/'CHPOINT' ;
*
   vdim = 'VALEUR' 'DIME' ;
   vmod = 'VALEUR' 'MODE' ;
   idim = 0 ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'PLANDEFO')) ;
      idim = 2 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'AXIS')) ;
      idim = 2 ;
      iaxi = VRAI ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 3) ('EGA' vmod 'TRID')) ;
      idim = 3 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' vdim 1) ;
      idim = 1 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' idim 0) ;
      'ERREUR' ('CHAINE' 'vmod=' vmod ' et vdim=' vdim ' non prevu') ;
   'FINSI' ;
   'SI' iaxi ;
      dprmt = '*' ('COORDONNEE' 1 _mt) ('*' PI 2.D0) ;
   'FINSI' ;
   dlnomt = 'DIME' lnomt ; dlnomq = 'DIME' lnomq ;
   'SI' ('NEG' dlnomt dlnomq) ;
    'ERREUR' ('CHAINE' 'Pas le meme nombre dincos primales et duales');
   'FINSI' ;
*   numop  = 1 ;
   numop  = dlnomt ;
   numder = idim ;
   numvar = dlnomt ;
   numdat = 1 ;
   numcof = 1 ;
*
   A = ININLIN numop numvar numdat numcof numder ;
   'REPETER' iilnomt dlnomt ;
      ilnomt = &iilnomt ;
      A . 'VAR' . ilnomt . 'NOMDDL' = 'MOTS' ('EXTRAIRE' lnomt ilnomt) ;
      A . 'VAR' . ilnomt . 'DISC'   = disct ;
      'SI' ('EXISTE' chpop) ;
         A . 'VAR' . ilnomt . 'VALEUR'   = chpop ;
      'FINSI' ;
   'FIN' iilnomt ;
   A . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
   A . 'DAT' . 1 . 'DISC'   = discc ;
   A . 'DAT' . 1 . 'VALEUR' = coef ;
   A . 'COF' . 1 . 'COMPOR' = 'IDEN' ;
   A . 'COF' . 1 . 'LDAT'   = 'LECT' 1 ;
*
   'REPETER' iilnomt dlnomt ;
      ilnomt = &iilnomt ;
      A . ilnomt . ilnomt . 0 = 'LECT' 1 ;
   'FIN' iilnomt ;
*
   'SI' iaxi ;
      numdat = 1 ;
      numcof = 1 ;
   'SINON' ;
      numdat = 0 ;
      numcof = 0 ;
   'FINSI' ;
   B = ININLIN numop numvar numdat numcof numder ;
   'REPETER' iilnomq dlnomq ;
      ilnomq = &iilnomq ;
      B . 'VAR' . ilnomq . 'NOMDDL' = 'MOTS' ('EXTRAIRE' lnomq ilnomq) ;
      B . 'VAR' . ilnomq . 'DISC'   = discq ;
      'SI' ('EXISTE' chpod) ;
         B . 'VAR' . ilnomq . 'VALEUR'   = chpod ;
      'FINSI' ;
   'FIN' iilnomq ;
*
   'SI' iaxi ;
      B . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
      B . 'DAT' . 1 . 'DISC'   = gdisc ;
      B . 'DAT' . 1 . 'VALEUR' = dprmt ;
      B . 'COF' . 1 . 'COMPOR' = 'IDEN' ;
      B . 'COF' . 1 . 'LDAT'   = 'LECT' 1 ;
   'FINSI' ;
   'SI' iaxi ;
      'REPETER' iilnomq dlnomq ;
         ilnomq = &iilnomq ;
         B . ilnomq . ilnomq . 0 = 'LECT' 1 ;
      'FIN' iilnomq ;
   'SINON' ;
      'REPETER' iilnomq dlnomq ;
         ilnomq = &iilnomq ;
         B . ilnomq . ilnomq . 0 = 'LECT' ;
      'FIN' iilnomq ;
   'FINSI' ;
*
   'SI' ('EXISTE' _smt) ;
       mgmass = 'NLIN' gdisc _mt _smt A B methgau ;
   'SINON' ;
       mgmass = 'NLIN' gdisc _mt A B methgau ;
   'FINSI' ;
*
'RESPRO' mgmass ;
'FINPROC' ;
*
* End of procedure file GMASS
*
*ENDPROCEDUR gmass
*BEGINPROCEDUR glapn
************************************************************************
* NOM         : GLAPN
* DESCRIPTION : Un laplacien scalaire
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v2, 14/03/2006, mise à jour NLIN évolué
* VERSION    : v1, 13/05/2004, version initiale
* HISTORIQUE : v1, 13/05/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' GLAPN ;
'ARGUMENT'     _mt*'MAILLAGE' ;
'ARGUMENT'   gdisc*'MOT     ' ;
'ARGUMENT'    nomt*'MOT     ' ;
'ARGUMENT'   disct*'MOT     ' ;
'ARGUMENT'    nomq*'MOT     ' ;
'ARGUMENT'   discq*'MOT     ' ;
'ARGUMENT' coef/'FLOTTANT' ;
   'SI' ('NON' ('EXISTE' coef)) ;
      'ARGUMENT' coef2/'CHPOINT ' ;
      'SI' ('NON' ('EXISTE' coef2)) ;
         'ERREUR' 'Il faut donner un coef FLOTTANT ou CHPOINT' ;
      'SINON' ;
         coef = coef2 ;
         'ARGUMENT' discc*'MOT     ' ;
      'FINSI' ;
   'SINON' ;
      discc = 'CSTE' ;
   'FINSI' ;
   'ARGUMENT' methgau/'MOT     ' ;
   'SI' ('NON' ('EXISTE' methgau)) ;
      methgau = 'GAU7' ;
   'FINSI' ;
'ARGUMENT' chpop/'CHPOINT' ;
'ARGUMENT' chpod/'CHPOINT' ;
*
   vdim = 'VALEUR' 'DIME' ;
   vmod = 'VALEUR' 'MODE' ;
   idim = 0 ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'PLANDEFO')) ;
      idim = 2 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'AXIS')) ;
      idim = 2 ;
      iaxi = VRAI ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 3) ('EGA' vmod 'TRID')) ;
      idim = 3 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' vdim 1) ;
      idim = 1 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' idim 0) ;
      'ERREUR' ('CHAINE' 'vmod=' vmod ' et vdim=' vdim ' non prevu') ;
   'FINSI' ;
   'SI' iaxi ;
      dprmt = '*' ('COORDONNEE' 1 _mt) ('*' PI 2.D0) ;
   'FINSI' ;
* Test bête...
   'SI' ('EGA' ('TYPE' coef) 'CHPOINT ') ;
      mincoef = 'MINIMUM' coef ;
   'SINON' ;
      mincoef = coef ;
   'FINSI' ;
   'SI' ('<' mincoef 0.D0) ;
      'ERREUR' 'Le coef (une viscosité) doit etre positive' ;
   'FINSI' ;
*
   'SI' iaxi ;
      lcoef = 'MOTS' 'NURR' 'NUZZ' ;
   'SINON' ;
      'SI' ('EGA' idim 2) ;
         lcoef = 'MOTS' 'NUXX' 'NUYY' ;
      'SINON' ;
         lcoef = 'MOTS' 'NUXX' 'NUYY' 'NUZZ' ;
      'FINSI' ;
   'FINSI' ;
*
   ltens = FAUX ;
   'SI' ('EGA' ('TYPE' coef) 'CHPOINT') ;
      ncomp = 'DIME' ('EXTRAIRE' coef 'COMP') ;
      'SI' ('EGA' ncomp idim) ;
         ltens = VRAI ;
      'FINSI' ;
   'FINSI' ;
*
   tcoef = 'TABLE' ;
   'SI' ltens ;
      'REPETER' iidim idim ;
         tcoef . &iidim = 'EXCO' ('EXTRAIRE' lcoef &iidim) coef ;
      'FIN' iidim ;
   'SINON' ;
      'REPETER' iidim idim ;
         tcoef . &iidim = coef ;
      'FIN' iidim ;
   'FINSI' ;
*
   numop  = idim ;
   numder = idim ;
   mmt = 'MOTS' nomt ;
   mmq = 'MOTS' nomq ;
   numvar = 1 ;
   numdat = idim ;
   numcof = idim ;
*
   A = ININLIN numop numvar numdat numcof numder ;
   A . 'VAR' . 1 . 'NOMDDL' = mmt ;
   A . 'VAR' . 1 . 'DISC'   = disct ;
   'SI' ('EXISTE' chpop) ;
      A . 'VAR' . 1 . 'VALEUR'   = chpop ;
   'FINSI' ;
   'REPETER' iidim idim ;
      A . 'DAT' . &iidim . 'NOMDDL' = 'MOTS' 'SCAL' ;
      A . 'DAT' . &iidim . 'DISC'   = discc ;
      A . 'DAT' . &iidim . 'VALEUR' = tcoef . &iidim ;
      A . 'COF' . &iidim . 'COMPOR' = 'IDEN' ;
      A . 'COF' . &iidim . 'LDAT'   = 'LECT' &iidim ;
   'FIN' iidim ;
*
   'REPETER' iidim idim ;
      A . &iidim . 1 . &iidim = 'LECT' &iidim ;
   'FIN' iidim ;
*
   'SI' iaxi ;
      numdat = 1 ;
      numcof = 1 ;
   'SINON' ;
      numdat = 0 ;
      numcof = 0 ;
   'FINSI' ;
*
   B = ININLIN numop numvar numdat numcof numder ;
   B . 'VAR' . 1 . 'NOMDDL' = mmq ;
   B . 'VAR' . 1 . 'DISC'   = discq ;
   'SI' ('EXISTE' chpod) ;
      B . 'VAR' . 1 . 'VALEUR'   = chpod ;
   'FINSI' ;
   'SI' iaxi ;
      B . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
      B . 'DAT' . 1 . 'DISC'   = gdisc ;
      B . 'DAT' . 1 . 'VALEUR' = dprmt ;
      B . 'COF' . 1 . 'COMPOR' = 'IDEN' ;
      B . 'COF' . 1 . 'LDAT'   = 'LECT' 1 ;
   'FINSI' ;
*
   'REPETER' iidim idim ;
      'SI' iaxi ;
         B . &iidim . 1 . &iidim = 'LECT' 1 ;
      'SINON' ;
         B . &iidim . 1 . &iidim = 'LECT' ;
      'FINSI' ;
   'FIN' iidim ;
*
   mglapn = 'NLIN' gdisc _mt A B methgau ;
* Integration par parties
   mglapn = '*' mglapn -1.D0 ;
*
'RESPRO' mglapn ;
'FINPROC' ;
*
* End of procedure file GLAPN
*
*ENDPROCEDUR glapn
*BEGINPROCEDUR gugrad
************************************************************************
* NOM         : GUGRAD
* DESCRIPTION : U . grad
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 13/05/2004, version initiale
* HISTORIQUE : v1, 13/05/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' GUGRAD ;
'ARGUMENT'     _mt*'MAILLAGE' ;
'ARGUMENT'   gdisc*'MOT     ' ;
'ARGUMENT'    nomp*'MOT     ' ;
'ARGUMENT'   discp*'MOT     ' ;
'ARGUMENT'    nomd*'MOT     ' ;
'ARGUMENT'   discd*'MOT     ' ;
'ARGUMENT'    vtot*'CHPOINT ' ;
'ARGUMENT'    vcomp*'LISTMOTS' ;
'ARGUMENT'   discv*'MOT     ' ;
'ARGUMENT' coef/'FLOTTANT' ;
   'SI' ('NON' ('EXISTE' coef)) ;
      'ARGUMENT' coef2/'CHPOINT ' ;
      'SI' ('NON' ('EXISTE' coef2)) ;
         'ERREUR' 'Il faut donner un coef FLOTTANT ou CHPOINT' ;
      'SINON' ;
         coef = coef2 ;
         'ARGUMENT' discc*'MOT     ' ;
      'FINSI' ;
   'SINON' ;
      discc = 'CSTE' ;
   'FINSI' ;
'ARGUMENT' methgau/'MOT     ' ;
   'SI' ('NON' ('EXISTE' methgau)) ;
      methgau = 'GAU7' ;
   'FINSI' ;
'ARGUMENT' chpop/'CHPOINT' ;
'ARGUMENT' chpod/'CHPOINT' ;
*
   vdim = 'VALEUR' 'DIME' ;
   vmod = 'VALEUR' 'MODE' ;
   idim = 0 ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'PLANDEFO')) ;
      idim = 2 ;
      iaxi = FAUX ;
*      Passé en argument désormais
*      vcomp = 'MOTS' 'UX' 'UY' ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'AXIS')) ;
      idim = 2 ;
      iaxi = VRAI ;
*      vcomp = 'MOTS' 'UR' 'UZ' ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 3) ('EGA' vmod 'TRID')) ;
      idim = 3 ;
      iaxi = FAUX ;
*      vcomp = 'MOTS' 'UX' 'UY' 'UZ' ;
   'FINSI' ;
   'SI' ('EGA' vdim 1) ;
      idim = 1 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' idim 0) ;
      'ERREUR' ('CHAINE' 'vmod=' vmod ' et vdim=' vdim ' non prevu') ;
   'FINSI' ;
   'SI' iaxi ;
      dprmt = '*' ('COORDONNEE' 1 _mt) ('*' PI 2.D0) ;
   'FINSI' ;
*
   numop  = 1 ;
   numder = idim ;
   mmp = 'MOTS' nomp ;
   mmd = 'MOTS' nomd ;
   numvar = 1 ;
   numdat = idim ;
   numcof = idim ;
*
   A = ININLIN numop numvar numdat numcof numder ;
   A . 'VAR' . 1 . 'NOMDDL' = mmp ;
   A . 'VAR' . 1 . 'DISC'   = discp ;
   'SI' ('EXISTE' chpop) ;
      A . 'VAR' . 1 . 'VALEUR'   = chpop ;
   'FINSI' ;
   'REPETER' iidim idim ;
      nomco = 'EXTRAIRE' vcomp &iidim ;
      A . 'DAT' . &iidim . 'NOMDDL' = 'MOTS' nomco ;
      A . 'DAT' . &iidim . 'DISC'   = discv ;
*      A . 'DAT' . &iidim . 'VALEUR' = 'EXCO' nomco 'NOID' vtot nomco ;
      A . 'DAT' . &iidim . 'VALEUR' = 'EXCO' nomco vtot nomco ;
*
      A . 'COF' . &iidim . 'COMPOR' = 'IDEN' ;
      A . 'COF' . &iidim . 'LDAT'   = 'LECT' &iidim ;
   'FIN' iidim ;
*
   'REPETER' iidim idim ;
      A . 1 . 1 . &iidim = 'LECT' &iidim ;
   'FIN' iidim ;
*
   numvar = 1 ;
   'SI' iaxi ;
      numdat = 2 ;
      numcof = 2 ;
   'SINON' ;
      numdat = 1 ;
      numcof = 1 ;
   'FINSI' ;
*
   B = ININLIN numop numvar numdat numcof numder ;
   B . 'VAR' . 1 . 'NOMDDL' = mmd ;
   B . 'VAR' . 1 . 'DISC'   = discd ;
   'SI' ('EXISTE' chpod) ;
      B . 'VAR' . 1 . 'VALEUR'   = chpod ;
   'FINSI' ;
*
   B . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
   B . 'DAT' . 1 . 'DISC'   = discc ;
   B . 'DAT' . 1 . 'VALEUR' = coef ;
   B . 'COF' . 1 . 'COMPOR' = 'IDEN' ;
   B . 'COF' . 1 . 'LDAT'   = 'LECT' 1 ;
*
   'SI' iaxi ;
      B . 'DAT' . 2 . 'NOMDDL' = 'MOTS' 'SCAL' ;
      B . 'DAT' . 2 . 'DISC'   = gdisc ;
      B . 'DAT' . 2 . 'VALEUR' = dprmt ;
      B . 'COF' . 2 . 'COMPOR' = 'IDEN' ;
      B . 'COF' . 2 . 'LDAT'   = 'LECT' 2 ;
   'FINSI' ;
*
   'SI' iaxi ;
      B . 1 . 1 . 0 = 'LECT' 1 2 ;
   'SINON' ;
      B . 1 . 1 . 0 = 'LECT' 1 ;
   'FINSI' ;
*
   mgugrad = 'NLIN' gdisc _mt A B methgau ;
*
'RESPRO' mgugrad ;
'FINPROC' ;
*
* End of procedure file GUGRAD
*
*ENDPROCEDUR gugrad
*BEGINPROCEDUR gdecent
************************************************************************
* NOM         : GDECENT
* DESCRIPTION : Décentrement
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 13/05/2004, version initiale
* HISTORIQUE : v1, 13/05/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' GDECENT ;
'ARGUMENT' imeth*'ENTIER' ;
'ARGUMENT'     _mt*'MAILLAGE' ;
'ARGUMENT'   gdisc*'MOT     ' ;
'ARGUMENT'    nomp*'MOT     ' ;
'ARGUMENT'   discp*'MOT     ' ;
'ARGUMENT'    nomd*'MOT     ' ;
'ARGUMENT'   discd*'MOT     ' ;
'ARGUMENT'    vtot*'CHPOINT ' ;
'ARGUMENT'    vcomp*'LISTMOTS' ;
'ARGUMENT'   discv*'MOT     ' ;
'ARGUMENT'     rho*'FLOTTANT' ;
'ARGUMENT'      nu*'FLOTTANT' ;
'ARGUMENT'     Pec*'FLOTTANT' ;
'ARGUMENT' methgau/'MOT     ' ;
   'SI' ('NON' ('EXISTE' methgau)) ;
      methgau = 'GAU7' ;
   'FINSI' ;
'ARGUMENT' chpop/'CHPOINT' ;
'ARGUMENT' chpod/'CHPOINT' ;
*
   vdim = 'VALEUR' 'DIME' ;
   vmod = 'VALEUR' 'MODE' ;
   idim = 0 ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'PLANDEFO')) ;
      idim = 2 ;
      iaxi = FAUX ;
*      Passé en argument désormais
*      vcomp = 'MOTS' 'UX' 'UY' ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'AXIS')) ;
      idim = 2 ;
      iaxi = VRAI ;
*      vcomp = 'MOTS' 'UR' 'UZ' ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 3) ('EGA' vmod 'TRID')) ;
      idim = 3 ;
      iaxi = FAUX ;
*      vcomp = 'MOTS' 'UX' 'UY' 'UZ' ;
   'FINSI' ;
   'SI' ('EGA' vdim 1) ;
      idim = 1 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' idim 0) ;
      'ERREUR' ('CHAINE' 'vmod=' vmod ' et vdim=' vdim ' non prevu') ;
   'FINSI' ;
   'SI' iaxi ;
      dprmt = '*' ('COORDONNEE' 1 _mt) ('*' PI 2.D0) ;
   'FINSI' ;
*
   mdumm = 'MOTS' 'DUMM' ;
   numop  = 1 ;
   numder = idim ;
   mmp = 'MOTS' nomp ;
   mmd = 'MOTS' nomd ;
   numvar = 1 ;
   numdat = '+' idim 3 ;
   numcof = idim ;
   lisdat = 'LECT' 1 PAS 1 ('+' idim 3) ;
*
   A = ININLIN numop numvar numdat numcof numder ;
   A . 'VAR' . 1 . 'NOMDDL' = mmp ;
   A . 'VAR' . 1 . 'DISC'   = discp ;
   'SI' ('EXISTE' chpop) ;
      A . 'VAR' . 1 . 'VALEUR'   = chpop ;
   'FINSI' ;
   idat = 0 ;
   idat = '+' idat 1 ;
   A . 'DAT' . idat . 'NOMDDL' = mdumm  ;
   A . 'DAT' . idat . 'DISC'   = 'CSTE' ;
   A . 'DAT' . idat . 'VALEUR' = rho    ;
   idat = '+' idat 1 ;
   A . 'DAT' . idat . 'NOMDDL' = mdumm  ;
   A . 'DAT' . idat . 'DISC'   = 'CSTE' ;
   A . 'DAT' . idat . 'VALEUR' = nu    ;
   'REPETER' iidim idim ;
      nomco = 'EXTRAIRE' vcomp &iidim ;
      idat = '+' idat 1 ;
      A . 'DAT' . idat . 'NOMDDL' = 'MOTS' nomco ;
      A . 'DAT' . idat . 'DISC'   = discv ;
*      A . 'DAT' . idat . 'VALEUR' = 'EXCO' nomco 'NOID' vtot nomco ;
      A . 'DAT' . idat . 'VALEUR' = 'EXCO' nomco vtot nomco ;
   'FIN' iidim ;
   idat = '+' idat 1 ;
   A . 'DAT' . idat . 'NOMDDL' = mdumm  ;
   A . 'DAT' . idat . 'DISC'   = 'CSTE' ;
   A . 'DAT' . idat . 'VALEUR' = Pec    ;
*
   icof = 0 ;
   'REPETER' iidim idim ;
      icof = '+' icof 1 ;
      A . 'COF' . icof . 'COMPOR' = 'CHAINE' 'MUSTAB' imeth &iidim ;
      A . 'COF' . icof . 'LDAT'   = lisdat ;
   'FIN' iidim ;
*
   'REPETER' iidim idim ;
      A . 1 . 1 . &iidim = 'LECT' &iidim ;
   'FIN' iidim ;
*
   numvar = 1 ;
   'SI' iaxi ;
      numdat = '+' idim 4 ;
      numcof = '+' idim 1 ;
   'SINON' ;
      numdat = '+' idim 3 ;
      numcof = idim ;
   'FINSI' ;
*
   B = ININLIN numop numvar numdat numcof numder ;
   B . 'VAR' . 1 . 'NOMDDL' = mmd ;
   B . 'VAR' . 1 . 'DISC'   = discd ;
   'SI' ('EXISTE' chpod) ;
      B . 'VAR' . 1 . 'VALEUR'   = chpod ;
   'FINSI' ;
   idat = 0 ;
   idat = '+' idat 1 ;
   B . 'DAT' . idat . 'NOMDDL' = mdumm  ;
   B . 'DAT' . idat . 'DISC'   = 'CSTE' ;
   B . 'DAT' . idat . 'VALEUR' = rho    ;
   idat = '+' idat 1 ;
   B . 'DAT' . idat . 'NOMDDL' = mdumm  ;
   B . 'DAT' . idat . 'DISC'   = 'CSTE' ;
   B . 'DAT' . idat . 'VALEUR' = nu    ;
   'REPETER' iidim idim ;
      nomco = 'EXTRAIRE' vcomp &iidim ;
      idat = '+' idat 1 ;
      B . 'DAT' . idat . 'NOMDDL' = 'MOTS' nomco ;
      B . 'DAT' . idat . 'DISC'   = discv ;
*      A . 'DAT' . idat . 'VALEUR' = 'EXCO' nomco 'NOID' vtot nomco ;
      B . 'DAT' . idat . 'VALEUR' = 'EXCO' nomco vtot nomco ;
   'FIN' iidim ;
   idat = '+' idat 1 ;
   B . 'DAT' . idat . 'NOMDDL' = mdumm  ;
   B . 'DAT' . idat . 'DISC'   = 'CSTE' ;
   B . 'DAT' . idat . 'VALEUR' = Pec    ;
*
   icof = 0 ;
   'REPETER' iidim idim ;
      icof = '+' icof 1 ;
      B . 'COF' . icof . 'COMPOR' = 'CHAINE' 'MUSTAB' imeth &iidim ;
      B . 'COF' . icof . 'LDAT'   = lisdat ;
   'FIN' iidim ;
*
   'SI' iaxi ;
      idat = '+' idat 1 ;
      B . 'DAT' . idat . 'NOMDDL' = 'MOTS' 'SCAL' ;
      B . 'DAT' . idat . 'DISC'   = gdisc ;
      B . 'DAT' . idat . 'VALEUR' = dprmt ;
      icof = '+' icof 1 ;
      B . 'COF' . icof . 'COMPOR' = 'IDEN' ;
      B . 'COF' . icof . 'LDAT'   = 'LECT' idat ;
   'FINSI' ;
*
   'SI' iaxi ;
      'REPETER' iidim idim ;
         B . 1 . 1 . &iidim = 'LECT' &iidim icof ;
      'FIN' iidim ;
   'SINON' ;
      'REPETER' iidim idim ;
         B . 1 . 1 . &iidim = 'LECT' &iidim ;
      'FIN' iidim ;
   'FINSI' ;
*
   mgdecent = 'NLIN' gdisc _mt A B methgau ;
*
'RESPRO' mgdecent ;
'FINPROC' ;
*
* End of procedure file GDECENT
*
*ENDPROCEDUR gdecent
*BEGINPROCEDUR gbbt
************************************************************************
* NOM         : GBBT
* DESCRIPTION : Copie de GDIV mais en précablé
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 14/09/2004, version initiale
* HISTORIQUE : v1, 14/09/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' GBBT ;
'ARGUMENT'     _mt*'MAILLAGE' ;
'ARGUMENT'   gdisc*'MOT     ' ;
'ARGUMENT'   discv*'MOT     ' ;
'ARGUMENT'   discp*'MOT     ' ;
'ARGUMENT' coef/'FLOTTANT' ;
   'SI' ('NON' ('EXISTE' coef)) ;
      'ARGUMENT' coef2/'CHPOINT ' ;
      'SI' ('NON' ('EXISTE' coef2)) ;
         'ERREUR' 'Il faut donner un coef FLOTTANT ou CHPOINT' ;
      'SINON' ;
         coef = coef2 ;
         'ARGUMENT' discc*'MOT     ' ;
      'FINSI' ;
   'SINON' ;
      discc = 'CSTE' ;
   'FINSI' ;
'ARGUMENT' methgau/'MOT     ' ;
   'SI' ('NON' ('EXISTE' methgau)) ;
      methgau = 'GAU7' ;
   'FINSI' ;
*
   vdim = 'VALEUR' 'DIME' ;
   vmod = 'VALEUR' 'MODE' ;
   idim = 0 ;
   lpp = 'MOTS' 'LX'      ; ldp = 'MOTS' 'FLX' ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'PLANDEFO')) ;
      lpv = 'MOTS' 'UX' 'UY' ; ldv = 'MOTS' 'FX' 'FY' ;
      idim = 2 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'AXIS')) ;
      lpv = 'MOTS' 'UR' 'UZ' ; ldv = 'MOTS' 'FR' 'FZ' ;
      idim = 2 ;
      iaxi = VRAI ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 3) ('EGA' vmod 'TRID')) ;
      lpv = 'MOTS' 'UX' 'UY' 'UZ' ; ldv = 'MOTS' 'FX' 'FY' 'FZ' ;
      idim = 3 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' idim 0) ;
      'ERREUR' ('CHAINE' 'vmod=' vmod ' et vdim=' vdim ' non prevu') ;
   'FINSI' ;
   'SI' iaxi ;
      dp = ('*' PI 2.D0) ;
      rmt = 'COORDONNEE' 1 _mt ;
   'FINSI' ;
*
   numop  = 2 ;
   numder = idim ;
   mmp = 'MOTS' nomp ;
   idim1 = '+' idim 1 ;
   numvar = idim1 ;
   'SI' iaxi ;
      numdat = 3 ;
      numcof = 3 ;
   'SINON' ;
      numdat = 1 ;
      numcof = 1 ;
   'FINSI' ;
*
   A = ININLIN numop numvar numdat numcof numder ;
   'REPETER' iidim idim ;
      A . 'VAR' . &iidim . 'NOMDDL' = 'MOTS' ('EXTRAIRE' lpv &iidim) ;
      A . 'VAR' . &iidim . 'DISC'   = discv ;
   'FIN' iidim ;
   A . 'VAR' . idim1 . 'NOMDDL' = lpp ;
   A . 'VAR' . idim1 . 'DISC'   = discp ;
   A . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
   A . 'DAT' . 1 . 'DISC'   = discc ;
   A . 'DAT' . 1 . 'VALEUR' = coef ;
   A . 'COF' . 1 . 'COMPOR' = 'IDEN' ;
   A . 'COF' . 1 . 'LDAT'   = 'LECT' 1 ;
*
   'SI' iaxi ;
      A . 'DAT' . 2 . 'NOMDDL' = 'MOTS' 'SCAL' ;
      A . 'DAT' . 2 . 'DISC'   = 'CSTE' ;
      A . 'DAT' . 2 . 'VALEUR' = dp ;
      A . 'COF' . 2 . 'COMPOR' = 'IDEN' ;
      A . 'COF' . 2 . 'LDAT'   = 'LECT' 2 ;
      A . 'DAT' . 3 . 'NOMDDL' = 'MOTS' 'SCAL' ;
      A . 'DAT' . 3 . 'DISC'   = gdisc ;
      A . 'DAT' . 3 . 'VALEUR' = rmt ;
      A . 'COF' . 3 . 'COMPOR' = 'IDEN' ;
      A . 'COF' . 3 . 'LDAT'   = 'LECT' 3 ;
   'FINSI' ;
*
   'SI' iaxi ;
      'REPETER' iidim idim ;
         A . 1 . &iidim . &iidim  = 'LECT' 1 2 3 ;
      'FIN' iidim ;
      A . 1 . 1 . 0 = 'LECT' 1 2 ;
   'SINON' ;
      'REPETER' iidim idim ;
         A . 1 . &iidim . &iidim  = 'LECT' 1 ;
      'FIN' iidim ;
   'FINSI' ;
   A . 2 . idim1 . 0 = 'LECT' ;
*
   'SI' iaxi ;
      numdat = 3 ;
      numcof = 3 ;
   'SINON' ;
      numdat = 1 ;
      numcof = 1 ;
   'FINSI' ;
   B = ININLIN numop numvar numdat numcof numder ;
   'REPETER' iidim idim ;
      B . 'VAR' . &iidim . 'NOMDDL' = 'MOTS' ('EXTRAIRE' ldv &iidim) ;
      B . 'VAR' . &iidim . 'DISC'   = discv ;
   'FIN' iidim ;
   B . 'VAR' . idim1 . 'NOMDDL' = ldp ;
   B . 'VAR' . idim1 . 'DISC'   = discp ;
   B . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
   B . 'DAT' . 1 . 'DISC'   = discc ;
   B . 'DAT' . 1 . 'VALEUR' = coef ;
   B . 'COF' . 1 . 'COMPOR' = 'IDEN' ;
   B . 'COF' . 1 . 'LDAT'   = 'LECT' 1 ;
*
   'SI' iaxi ;
      B . 'DAT' . 2 . 'NOMDDL' = 'MOTS' 'SCAL' ;
      B . 'DAT' . 2 . 'DISC'   = 'CSTE' ;
      B . 'DAT' . 2 . 'VALEUR' = dp ;
      B . 'COF' . 2 . 'COMPOR' = 'IDEN' ;
      B . 'COF' . 2 . 'LDAT'   = 'LECT' 2 ;
      B . 'DAT' . 3 . 'NOMDDL' = 'MOTS' 'SCAL' ;
      B . 'DAT' . 3 . 'DISC'   = gdisc ;
      B . 'DAT' . 3 . 'VALEUR' = rmt ;
      B . 'COF' . 3 . 'COMPOR' = 'IDEN' ;
      B . 'COF' . 3 . 'LDAT'   = 'LECT' 3 ;
   'FINSI' ;
*
   'SI' iaxi ;
      'REPETER' iidim idim ;
         B . 2 . &iidim . &iidim  = 'LECT' 1 2 3 ;
      'FIN' iidim ;
      B . 2 . 1 . 0 = 'LECT' 1 2 ;
   'SINON' ;
      'REPETER' iidim idim ;
         B . 2 . &iidim . &iidim  = 'LECT' 1 ;
      'FIN' iidim ;
   'FINSI' ;
   B . 1 . idim1 . 0 = 'LECT' ;
*
   mgbbt = 'NLIN' gdisc _mt A B methgau ;
*
'RESPRO' mgbbt ;
'FINPROC' ;
*
* End of procedure file GBBT
*
*ENDPROCEDUR gbbt
*BEGINPROCEDUR ggradt
************************************************************************
* NOM         : GGRADT
* DESCRIPTION : Gradient d'une quantité
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 08/03/2006, version initiale
* HISTORIQUE : v1, 08/03/2006, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' GGRADT ;
'ARGUMENT'     _mt*'MAILLAGE' ;
'ARGUMENT'   gdisc*'MOT     ' ;
'ARGUMENT'    nomp*'MOT     ' ;
'ARGUMENT'   discp*'MOT     ' ;
'ARGUMENT'    nomv*'LISTMOTS' ;
'ARGUMENT'   discv*'MOT     ' ;
'ARGUMENT' coef/'FLOTTANT' ;
   'SI' ('NON' ('EXISTE' coef)) ;
      'ARGUMENT' coef2/'CHPOINT ' ;
      'SI' ('NON' ('EXISTE' coef2)) ;
         'ERREUR' 'Il faut donner un coef FLOTTANT ou CHPOINT' ;
      'SINON' ;
         coef = coef2 ;
         'ARGUMENT' discc*'MOT     ' ;
      'FINSI' ;
   'SINON' ;
      discc = 'CSTE' ;
   'FINSI' ;
   'ARGUMENT' methgau/'MOT     ' ;
   'SI' ('NON' ('EXISTE' methgau)) ;
      methgau = 'GAU7' ;
   'FINSI' ;
'ARGUMENT' chpop/'CHPOINT' ;
'ARGUMENT' chpod/'CHPOINT' ;
*
   vdim = 'VALEUR' 'DIME' ;
   vmod = 'VALEUR' 'MODE' ;
   idim = 0 ;
   lpp  = 'MOTS' nomp ;
   ldv  = nomv ;
   'SI' ('ET' ('EGA' vdim 1) ('EGA' vmod 'UNIDPLANDYDZ')) ;
      idim = 1 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'PLANDEFO')) ;
      idim = 2 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'AXIS')) ;
      idim = 2 ;
      iaxi = VRAI ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 3) ('EGA' vmod 'TRID')) ;
      idim = 3 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' idim 0) ;
      'ERREUR' ('CHAINE' 'vmod=' vmod ' et vdim=' vdim ' non prevu') ;
   'FINSI' ;
   'SI' iaxi ;
      dp = ('*' PI 2.D0) ;
      rmt = 'COORDONNEE' 1 _mt ;
   'FINSI' ;
*
   numop  = idim ;
   numder = idim ;
   numvar = 1 ;
   'SI' iaxi ;
      numdat = 3 ;
      numcof = 3 ;
   'SINON' ;
      numdat = 1 ;
      numcof = 1 ;
   'FINSI' ;
*
   A = ININLIN numop numvar numdat numcof numder ;
   A . 'VAR' . 1 . 'NOMDDL' = lpp ;
   A . 'VAR' . 1 . 'DISC'   = discp ;
   'SI' ('EXISTE' chpop) ;
      A . 'VAR' . 1 . 'VALEUR'   = chpop ;
   'FINSI' ;
   A . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
   A . 'DAT' . 1 . 'DISC'   = discc ;
   A . 'DAT' . 1 . 'VALEUR' = coef ;
   A . 'COF' . 1 . 'COMPOR' = 'IDEN' ;
   A . 'COF' . 1 . 'LDAT'   = 'LECT' 1 ;
   'SI' iaxi ;
      A . 'DAT' . 2 . 'NOMDDL' = 'MOTS' 'SCAL' ;
      A . 'DAT' . 2 . 'DISC'   = 'CSTE' ;
      A . 'DAT' . 2 . 'VALEUR' = dp ;
      A . 'COF' . 2 . 'COMPOR' = 'IDEN' ;
      A . 'COF' . 2 . 'LDAT'   = 'LECT' 2 ;
      A . 'DAT' . 3 . 'NOMDDL' = 'MOTS' 'SCAL' ;
      A . 'DAT' . 3 . 'DISC'   = gdisc ;
      A . 'DAT' . 3 . 'VALEUR' = rmt ;
      A . 'COF' . 3 . 'COMPOR' = 'IDEN' ;
      A . 'COF' . 3 . 'LDAT'   = 'LECT' 3 ;
   'FINSI' ;
*
   'SI' iaxi ;
      'REPETER' iidim idim ;
         A . &iidim . 1 . 0 = 'LECT' 1 2 3 ;
      'FIN' iidim ;
   'SINON' ;
      'REPETER' iidim idim ;
         A . &iidim . 1 . 0 = 'LECT' 1 ;
      'FIN' iidim ;
   'FINSI' ;
*
   numvar = idim ;
   numdat = 0 ;
   numcof = 0 ;
   B = ININLIN numop numvar numdat numcof numder ;
   'REPETER' iidim idim ;
      msinc = 'MOTS' ('EXTRAIRE' ldv &iidim) ;
      B . 'VAR' . &iidim . 'NOMDDL' = msinc  ;
      B . 'VAR' . &iidim . 'DISC'   = discv ;
      'SI' ('EXISTE' chpod) ;
         B . 'VAR' . &iidim . 'VALEUR'   = 'EXCO' msinc chpod msinc ;
      'FINSI' ;
   'FIN' iidim ;
*
   'REPETER' iidim idim ;
      B . &iidim . &iidim . &iidim = 'LECT' ;
   'FIN' iidim ;
*
   mggradt = 'NLIN' gdisc _mt A B methgau ;
*
'RESPRO' mggradt ;
'FINPROC' ;
*
* End of procedure file GGRADT
*
*ENDPROCEDUR ggradt
*BEGINPROCEDUR dessevol
************************************************************************
* NOM         : DESSEVOL
* DESCRIPTION : Dessine des évolutions : choisit automatiquement
*               les options, marqueurs, couleurs...
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 16/11/2004, version initiale
* HISTORIQUE : v1, 16/11/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' DESSEVOL ;
'ARGUMENT' evtot*'EVOLUTION' ;
'ARGUMENT' tabt*'TABLE' ;
'ARGUMENT' tit*'MOT' ;
'ARGUMENT' tix*'MOT' ;
'ARGUMENT' tiy*'MOT' ;
'ARGUMENT' lnclk/'LOGIQUE' ;
'ARGUMENT' nb/'ENTIER' ;
*
'SI' ('NON' ('EXISTE' lnclk)) ;
   lnclk = FAUX ;
'FINSI' ;
*
'SI' ('NON' ('EXISTE' nb)) ;
   nb = 3 ;
'FINSI' ;
*
nt  = 'DIME' tabt ;
nev = 'DIME' evtot ;
*
* Attention, dans evtot, il y a une évolution avec des noms de points ?
*
*'SI' ('NEG' nev nt) ;
*   cherr = 'CHAINE' 'Evolution and title table : not same dim.' ;
*   'ERREUR' cherr ;
*'FINSI' ;
*
tev = 'TABLE' ;
tev . 'TITRE' = tabt ;
*
toto = 'TABLE' ;
*
lcoul = 'MOTS' 'TURQ' 'VERT' 'JAUN' 'ROSE' 'ROUG' 'BLEU' ;
lmarq = 'MOTS' 'TRIB' 'TRIA' 'LOSA' 'CARR' 'ETOI' 'PLUS' 'CROI' ;
ltirr = 'MOTS' 'TIRR' 'TIRC' 'TIRL' 'TIRM' ;
*
'SI' ('EGA' nb 0) ;
   ev2 = evtot ;
'SINON' ;
   icou = 0 ;
   'REPETER' iev nev ;
      ii = &iev ;
      evi = 'EXTRAIRE' evtot 'COUR' ii ;
      'SI' ('NEG' ('TYPE' ('EXTRAIRE' evi 'ORDO')) 'LISTMOTS') ;
         icou = '+' icou 1 ;
      'FINSI' ;
*      ii2 = '/' ('+' ii 1) 2 ;
*      ci  = EXMOMOD lcoul ii2 ;
*      ci  = EXMOMOD lcoul ii ;
      ci  = EXMOMOD lcoul icou ;
      APPEND toto 'EVOLUTION' ('COULEUR' evi ci) ;
   'FIN' iev ;
   ev2 = toto . 'EVOLUTION' ;
'FINSI' ;
*
'REPETER' iev nev ;
   ii = &iev ;
   mi = EXMOMOD lmarq ii ;
   ti = EXMOMOD ltirr ii ;
   'SI' ('>' nb 2) ;
      tev . ii = 'CHAINE' 'MARQ ' mi ' ' ti ;
   'FINSI' ;
   'SI' ('>' nb 1) ;
      tev . ii = 'CHAINE' 'MARQ ' mi ;
   'FINSI' ;
'FIN' iev ;
*
'SI' lnclk ;
   'DESSIN' ev2 'TITR' tit 'TITX' tix 'TITY' tiy 'LEGE' 'MIMA' tev
   'NCLK' ;
'SINON' ;
   'DESSIN' ev2 'TITR' tit 'TITX' tix 'TITY' tiy 'LEGE' 'MIMA' tev ;
'FINSI' ;
*
* End of procedure file DESSEVOL
*
'FINPROC' ;
*ENDPROCEDUR dessevol
*BEGINPROCEDUR exmomod
************************************************************************
* NOM         : EXMOMOD
* DESCRIPTION : Extraction d'un mot d'un listmots
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 23/06/2003, version initiale
* HISTORIQUE : v1, 23/06/2003, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' EXMOMOD ;
'ARGUMENT' lm*'LISTMOTS' i*'ENTIER' ;
j = 'DIME' lm ;
k = '+' (MODULO ('-' i 1) j) 1 ;
lemot = 'EXTRAIRE' lm k ;
* Usage de l'opérateur text pour éviter que lemot
* ne soit interprété comme un opérateur
'RESPRO' 'TEXTE' lemot ;
*
* End of procedure file EXMOMOD
*
'FINPROC' ;
*ENDPROCEDUR exmomod
*BEGINPROCEDUR modulo
************************************************************************
* NOM         : MODULO
* DESCRIPTION : Calcule un entier modulo un autre...
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 15/10/2002, version initiale
* HISTORIQUE : v1, 15/10/2002, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' MODULO ;
'ARGUMENT' i*'ENTIER' j*'ENTIER' ;
'SI' ('EGA' j 0) ;
  'MESSAGE' 'Impossible de faire modulo 0' ;
  'ERREUR' 5 ;
'SINON' ;
  k=i '/' j ;
  mod=i '-' ( k '*'j ) ;
  'RESPRO' mod ;
'FINSI' ;
*
* End of procedure file MODULO
*
'FINPROC' ;
*ENDPROCEDUR modulo
*BEGINPROCEDUR append
************************************************************************
* NOM         : APPEND
* DESCRIPTION : Rajoute :
*               - un entier à un listentier
*               - un réel   à un listreel
*               - un objet (liste, evolution, matrice ou chpoint)
*                 à un indice de table ('MOT' ou 'ENTIER')
*                    * si l'indice n'existe pas
*                    * 'ET' si l'indice existe
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 10/09/2004, version initiale
* HISTORIQUE : v1, 10/09/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' APPEND ;
'ARGUMENT' tab/'TABLE' ;
'SI' ('EXISTE' tab) ;
   'ARGUMENT' itab/'MOT' ;
   'SI' ('NON' ('EXISTE' itab)) ;
      'ARGUMENT' itab*'ENTIER' ;
   'FINSI' ;
   lobj = FAUX ;
   'SI' ('NON' lobj) ;
      'ARGUMENT' lr/'LISTREEL' ;
      'SI' ('EXISTE' lr) ;
         obj = lr ; lobj = VRAI ;
      'FINSI' ;
   'FINSI' ;
   'SI' ('NON' lobj) ;
      'ARGUMENT' le/'LISTENTI' ;
      'SI' ('EXISTE' le) ;
         obj = le ; lobj = VRAI ;
      'FINSI' ;
   'FINSI' ;
   'SI' ('NON' lobj) ;
      'ARGUMENT' lev/'EVOLUTION' ;
      'SI' ('EXISTE' lev) ;
         obj = lev ; lobj = VRAI ;
      'FINSI' ;
   'FINSI' ;
   'SI' ('NON' lobj) ;
      'ARGUMENT' lm/'MAILLAGE' ;
      'SI' ('EXISTE' lm) ;
         obj = lm ; lobj = VRAI ;
      'FINSI' ;
   'FINSI' ;
   'SI' ('NON' lobj) ;
      'ARGUMENT' chpo/'CHPOINT' ;
      'SI' ('EXISTE' chpo) ;
         obj = chpo ; lobj = VRAI ;
      'FINSI' ;
   'FINSI' ;
   'SI' ('NON' lobj) ;
      'ARGUMENT' rig/'RIGIDITE' ;
      'SI' ('EXISTE' rig) ;
         obj = rig ; lobj = VRAI ;
      'FINSI' ;
   'FINSI' ;
   'SI' ('NON' lobj) ;
      'ARGUMENT' matk/'MATRIK' ;
      'SI' ('EXISTE' matk) ;
         obj = matk ; lobj = VRAI ;
      'FINSI' ;
   'FINSI' ;
   'SI' ('NON' lobj) ;
      cherr = 'CHAINE'
       'Il faut fournir un objet liste, evolution, matrice ou chpoint.'
        ;
      'ERREUR' cherr ;
   'FINSI' ;
   'SI' ('EXISTE' tab itab) ;
      'SI' ('EGA' ('TYPE' obj) 'CHPOINT') ;
         tab . itab = '+' (tab . itab) obj ;
      'SINON' ;
         tab . itab = 'ET' (tab . itab) obj ;
      'FINSI' ;
   'SINON' ;
      tab . itab = obj ;
   'FINSI' ;
   'RESPRO' tab ;
'FINSI' ;
'ARGUMENT' lenti/'LISTENTI' ;
'ARGUMENT' lreel/'LISTREEL' ;
'SI' ('EXISTE' lenti) ;
   'ARGUMENT' enti*'ENTIER' ;
   lenti = 'ET' lenti ('LECT' enti) ;
   'RESPRO' lenti ;
'FINSI' ;
'SI' ('EXISTE' lreel) ;
   'ARGUMENT' reel*'FLOTTANT' ;
   lreel = 'ET' lreel ('PROG' reel) ;
   'RESPRO' lreel ;
'FINSI' ;
*
* End of procedure file APPEND
*
'FINPROC' ;
*ENDPROCEDUR append
*BEGINPROCEDUR histo
************************************************************************
* NOM         : HISTO
* DESCRIPTION : Construit une evolution représentant un histogramme
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 13/09/2004, version initiale
* HISTORIQUE : v1, 13/09/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' HISTO ;
'ARGUMENT' lx*'LISTREEL' ;
'ARGUMENT' ly*'LISTREEL' ;
*
dlx = 'DIME' lx ;
dly = 'DIME' ly ;
*
'SI' ('NEG' dly ('-' dlx 1)) ;
   cherr = 'CHAINE' 'Dimension des arguments incorrecte' ;
   'MESSAGE' ('CHAINE' 'Dime lx=' dlx  ' Dime ly=' dly) ;
   'ERREUR' cherr ;
'FINSI' ;
*
lxn = 'PROG' ;
lyn = 'PROG' ;
*
'REPETER' ii dly ;
   vx  = 'EXTRAIRE' lx &ii ;
   vxp = 'EXTRAIRE' lx ('+' &ii 1) ;
   vy  = 'EXTRAIRE' ly &ii ;
   pvx = 'PROG' vx ; pvxp = 'PROG' vxp ;
   pvy = 'PROG' vy ; pv0  = 'PROG' 0.D0 ;
   lxn = lxn 'ET' pvx 'ET' pvx 'ET' pvxp 'ET' pvxp ;
   lyn = lyn 'ET' pv0 'ET' pvy 'ET' pvy 'ET' pv0 ;
'FIN' ii ;
evhist = 'EVOL' 'MANU' lxn lyn ;
'RESPRO' evhist ;
*
* End of procedure file HISTO
*
'FINPROC' ;
*ENDPROCEDUR histo
*
************************************************************************
* NOM         : GHIA
* DESCRIPTION : Une partie des résultats de référence (profils U_x(y)
*               et U_y(x) obtenus par Ghia et al. dans la référence :
*@Article{ghia,
*  author =       {U. Ghia and K.N. Ghia and C.T. Shin},
*  title =        {High-Re Solutions for Incompressible Flow Using the
*                  Navier-Stokes Equations and a Multigrid Method},
*  journal =      {JCP},
*  year =         {1982},
*  volume =    {48},
*  pages =     {387-411},
*  endroit = {Classeur Benchmarks (I)}
*}
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 14/06/2007, version initiale
* HISTORIQUE : v1, 14/06/2007, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' GHIA ;
'ARGUMENT' Re*'FLOTTANT' ;
lok = FAUX ;
iRe = 'ENTIER' ('+' Re 0.5D0) ;
ly  = 'PROG' 0.0000 0.0547 0.0625 0.0703 0.1016 0.1719 0.2813 0.4531
             0.5000 0.6172 0.7344 0.8516 0.9531 0.9609 0.9688 0.9766
             1.0000 ;
lx  = 'PROG' 0.0000 0.0625 0.0703 0.0781 0.0938 0.1563 0.2266 0.2344
             0.5000 0.8047 0.8594 0.9063 0.9453 0.9531 0.9609 0.9688
             1.0000 ;
'SI' ('EGA' iRe 100) ;
lok = VRAI ;
lu  = 'PROG' 0.00000 -0.03717 -0.04192 -0.04775 -0.06434 -0.10150
             -0.15662 -0.21090
             -0.20581 -0.13641 0.00332 0.23151 0.68717 0.73722 0.78871
             0.84123 1.00000 ;
lv  = 'PROG' 0.00000 0.09233 0.10091 0.10890 0.12317 0.16077 0.17507
             0.17527
             0.05454 -0.24533 -0.22445 -0.16914 -0.10313 -0.08864
             -0.07391 -0.05906 0.00000 ;
'FINSI' ;
'SI' ('EGA' iRe 400) ;
lok = VRAI ;
lu  = 'PROG' 0.00000 -0.08186 -0.09266 -0.10338 -0.14612 -0.24299
             -0.32726 -0.17119
             -0.11477 0.02135 0.16256 0.29093 0.55892 0.61756 0.68439
             0.75837 1.00000 ;
lv  = 'PROG' 0.00000 0.18360 0.19713 0.20920 0.22965 0.28124 0.30203
             0.30174
             0.05186 -0.38598 -0.44993 -0.3827 -0.22847 -0.19254
             -0.15663 -0.12146 0.00000 ;
'FINSI' ;
'SI' ('EGA' iRe 1000) ;
lok = VRAI ;
lu  = 'PROG' 0.00000 -0.18109 -0.20196 -0.22220 -0.29730 -0.38289
             -0.27805 -0.10648
             -0.06080 0.05702 0.18719 0.33304 0.46604 0.51117 0.57492
             0.65928 1.00000 ;
lv  = 'PROG' 0.00000 0.27485 0.29012 0.30353 0.32627 0.37095 0.33075
             0.32235
             0.02526 -0.31966 -0.42665 -0.51550 -0.39188 -0.33714
             -0.27669 -0.21388 0.00000 ;
'FINSI' ;
'SI' ('EGA' iRe 3200) ;
lok = VRAI ;
lu  = 'PROG' 0.00000 -0.32407 -0.35344 -0.37827 -0.41933 -0.34323
             -0.24427 -0.086636
             -0.04272 0.07156 0.19791 0.34682 0.46101 0.46547 0.48296
             0.53236 1.00000 ;
lv  = 'PROG' 0.00000 0.39560 0.40917 0.41906 0.42768 0.37119 0.29030
             0.28188
             0.00999 -0.31184 -0.37401 -0.44307 -0.54053 -0.52357
             -0.47425 -0.39017 0.00000 ;
'FINSI' ;
'SI' ('EGA' iRe 5000) ;
lok = VRAI ;
lu  = 'PROG' 0.00000 -0.41165 -0.42901 -0.43643 -0.40435 -0.33050
             -0.22855 -0.07404
             -0.03039 0.08183 0.20087 0.33556 0.46036 0.45992 0.46120
             0.48223 1.00000 ;
lv  = 'PROG' 0.00000 0.42447 0.43329 0.43648 0.42951 0.35368 0.28066
             0.27280
             0.00945 -0.30018 -0.36214 -0.41442 -0.52876 -0.55408
             -0.55069 -0.49774 0.00000 ;
'FINSI' ;
'SI' ('EGA' iRe 7500) ;
lok = VRAI ;
lu  = 'PROG' 0.00000 -0.43154 -0.43590 -0.43025 -0.38324 -0.32393
             -0.23176 -0.07503
             -0.03800 0.08342 0.20591 0.34228 0.47167 0.47323 0.47048
             0.47244 1.00000 ;
lv  = 'PROG' 0.00000 0.43979 0.44030 0.43564 0.41824 0.35060 0.28117
             0.27348
             0.00824 -0.30448 -0.36213 -0.41050 -0.48590 -0.52347
             -0.55216 -0.53858 0.00000 ;
'FINSI' ;
'SI' ('EGA' iRe 10000) ;
lok = VRAI ;
lu  = 'PROG' 0.00000 -0.42735 -0.42537 -0.41657 -0.38000 -0.32709
             -0.23186 -0.07540
             -0.03111 0.08344 0.20673 0.34635 0.47804 0.48070 0.47783
             0.47221 1.00000 ;
lv  = 'PROG' 0.00000 0.43983 0.43733 0.43124 0.41487 0.35070 0.28003
             0.27224
             0.00831 -0.30719 -0.36737 -0.41496 -0.45863 -0.49099
             -0.52987 -0.54302 0.00000 ;
'FINSI' ;
'SI' ('NON' lok) ;
   cherr = 'CHAINE' 'Pas de sol tabulee pour Re = ' Re ;
   'ERREUR' cherr ;
'FINSI' ;
'RESPRO' ly lu lx lv ;
'FINPROC' ;
*
* Calcul la condition à la limite sur le bord haut
*
*  1 ^
*    |   ________
*    |  /        \
*    | /pente=    \pente = - pmax
*    |/   pmax     \
*  0 +------------------>
*   0                 1
*
'DEBPROC' CALCLIM ;
*
* ! Attention, gros problème de fuite avec la condition à la limite
* ! suivante
*
*ccli = '+' ('MANUEL' 'CHPO' hau 1 'UX' 1.D0)
*           ('MANUEL' 'CHPO' bor mxpri ('PROG' 0.D0 0.D0) ) ;
*
*  Celle-ci est bien smooth
*
*
*           'LISTE' ccli ;
*xhau = 'COORDONNEE' 1 hau ;
*phau = xhau '*' ('-' xhau 1) '*' -4.D0 ;
*ccli = '+' ('NOMC' 'UX' phau)
*           ('MANUEL' 'CHPO' bor mxpri ('PROG' 0.D0 0.D0) ) ;
*
*  Celle-ci est quasi singulière mais correspond au benchmark de ghia !
*
pmax = 100. ; ipmax = '/' 1. pmax ;
*
xhau = 'COORDONNEE' 1 hau ;
xm1 = '-' xhau ipmax ; axm1 = 'ABS' xm1 ;
f1  = '*' ('-' xm1 axm1) ('/' pmax 2.) ;
xm2 = '-' xhau ('-' 1. ipmax) ; axm2 = 'ABS' xm2 ;
f2  = '*' ('+' xm2 axm2) ('/' pmax -2.) ;
ft  = '+' ('+' f1 f2) 1. ;
ccli = '+' ('NOMC' 'UX' ft)
           ('MANUEL' 'CHPO' bor mxpri ('PROG' 0.D0 0.D0) ) ;
'RESPRO' ccli ;
'FINPROC' ;
*
* Calcul de l'incrément vitesse-pression NS incompressible
*
'DEBPROC' SOLAPP ;
'ARGUMENT' _mt*'MAILLAGE' ;
'ARGUMENT' inco*'CHPOINT' ;
'ARGUMENT' ccli*'CHPOINT' ;
*
   mlapx = GLAPN _mt discg 'UX' discv 'FX' discv iRe ;
   mlapx = '*' mlapx -1.D0 ;
   mlapy = 'CHANGER' 'INCO' mlapx ('MOTS' 'UX') ('MOTS' 'UY')
                                  ('MOTS' 'FX') ('MOTS' 'FY') ;
   mcnvx = GUGRAD _mt discg 'UX' discv 'FX' discv inco mxpri discv 1. ;
   mcnvy = 'CHANGER' 'INCO' mcnvx ('MOTS' 'UX') ('MOTS' 'UY')
                                  ('MOTS' 'FX') ('MOTS' 'FY') ;
   'SI' lsupg ;
      mdecx = GDECENT 2 _mt discg 'UX' discv 'FX' discv inco mxpri discv
                     csupg iRe 2.D0 ;
      mdecy = 'CHANGER' 'INCO' mdecx ('MOTS' 'UX') ('MOTS' 'UY')
                                     ('MOTS' 'FX') ('MOTS' 'FY') ;
   'FINSI' ;
   mbbt  = GBBT _mt discg discv discp -1. ;
* Régularisation de pression
   mp    = GMASS _mt discg 'LX' discp 'FLX' discp ('*' ap -1.D0) ;
* Blocage
   mblo  = 'BLOQUE' 'DEPL' bor ;
   fblo  = 'DEPIMPOSE' mblo ccli ;
   mphy  = mlapx 'ET' mlapy 'ET' mcnvx 'ET' mcnvy 'ET' mbbt 'ET' mblo ;
   'SI' lsupg ;
      mphy = mphy 'ET' mdecx 'ET' mdecy ;
   'FINSI' ;
   mtot = mphy 'ET' mp ;
*
   ftot = '-' fblo ('*' mphy inc) ;
*
   incr = 'KRES' mtot ftot ;
   'RESPRO' incr ;
'FINPROC' ;
*
* Calcul de la métrique : on utilise la valeur iRe * grad v : gradtv
* (dissipation thermique = production locale d'entropie) pour réaliser
* l'adaptation
*
'DEBPROC' TGDENT ;
'ARGUMENT' _mt*'MAILLAGE' ;
'ARGUMENT' vit*'CHPOINT' ;
'ARGUMENT' beta*'FLOTTANT' ;
* Volume des éléments
vmtl = GMASS _mt discg 'SCAL' discg 'SCAL' discg 1. c1 c1 ;
vmtml = GMASS _mtmoy discg 'SCAL' discg 'SCAL' discg 1. c1 c1 ;
vmtm  = 'MAXIMUM' ('RESULT' vmtml) ;
discc = 'CSTE' ;
*
* Calcul de la dissipation thermique
*
fdtxi = GLAPN _mt discg 'UX' discv 'UX' discv iRe vit vit ;
fdtyi = GLAPN _mt discg 'UY' discv 'UY' discv iRe vit vit ;
fdtxi = '*' fdtxi -1. ;
fdtyi = '*' fdtyi -1. ;
fdtx = '/' fdtxi vmtl ;
fdty = '/' fdtyi vmtl ;
fdt = '+' fdtx fdty ;
'SI' lsupgm ;
   fdecxi = GDECENT 2 _mt discg 'UX' discv 'UX' discv vit mxpri discv
                     csupg iRe 2.D0 vit vit ;
   fdecyi = GDECENT 2 _mt discg 'UY' discv 'UY' discv vit mxpri discv
                     csupg iRe 2.D0 vit vit ;
   fdecx = '/' fdecxi vmtl ;
   fdecy = '/' fdecyi vmtl ;
   fdec = '+' fdecx fdecy ;
'FINSI' ;
'SI' (graph 'ET' debug) ;
   rescal = 'KCHA' $mt fdt 'CHAM' ;
   tit = 'CHAINE' 'Dissipation thermique'  ;
   'TRACER' rescal $mb 'TITR' tit ;
   'SI' lsupg ;
      rescal = 'KCHA' $mt fdec 'CHAM' ;
      tit = 'CHAINE' 'Dissipation numérique'  ;
      'TRACER' rescal $mb 'TITR' tit ;
   'FINSI' ;
'FINSI' ;
'SI' lsupg ;
   fdt = '+' fdt fdec ;
'FINSI' ;
*
* Lissage de la dissipation
*
'SI' lissd ;
   mms  = GMASS _mt discg 'SCAL' discg  'SCAL' discr 1. c1 ;
   fdti = GMASS _mt discg 'SCAL' 'CSTE' 'SCAL' discr 1. fdt ;
   fdts = '/' fdti mms ;
   fdtsi = GMASS _mt discg 'SCAL' discr 'SCAL' 'CSTE' 1. fdts ;
   fdt   = '/' fdtsi vmtl ;
   'SI' (graph 'ET' debug) ;
      rescal = 'KCHA' $mt fdt 'CHAM' ;
      tit = 'CHAINE' 'Dissipation apres lissage'  ;
      'TRACER' rescal $mb 'TITR' tit ;
   'FINSI' ;
'FINSI' ;
*
* Limitation de la dissipation
*
sfdti = GMASS _mtmoy discg 'SCAL' 'CSTE' 'SCAL' 'CSTE' 1. fdt ;
mfdt = '/' ('MAXIMUM' ('RESULT' sfdti)) vmtm ;
'SI' verbose ;
   'MESSAGE' ('CHAINE' '   Diss. therm. moy.=' mfdt) ;
'FINSI' ;
seuil = '*' limfdt mfdt ;
* Limitation des valeurs supérieures
   m1   = 'MASQUE' fdt 'INFERIEUR' seuil ;
   m0   = '*' ('-' m1 1.) -1. ;
   fdt   = '+' ('*' m1 fdt) ('*' m0 seuil) ;
   'SI' (graph 'ET' debug) ;
      rescal = 'KCHA' $mt m0 'CHAM' ;
      tit = 'CHAINE' 'Masquage de la dissipation'  ;
      'TRACER' rescal $mb 'TITR' tit ;
      rescal = 'KCHA' $mt fdt 'CHAM' ;
      tit = 'CHAINE' 'Dissipation apres limitation'  ;
      'TRACER' rescal $mb 'TITR' tit ;
   'FINSI' ;
*
* Scaling de la dissipation
*
sfdti = GMASS _mtmoy discg 'SCAL' 'CSTE' 'SCAL' 'CSTE' 1. fdt ;
mfdt = '/' ('MAXIMUM' ('RESULT' sfdti)) vmtm ;
'SI' verbose ;
   'MESSAGE' ('CHAINE' '   Diss. therm. moy. apres limitation=' mfdt) ;
'FINSI' ;
* D'où alpha :
alpha = '*' ('/' ('-' 1.D0 beta) beta) mfdt ;
'SI' ('ET' debug verbose) ;
   'MESSAGE' ('CHAINE' '   Alpha = ' alpha) ;
'FINSI' ;
*
* Calcul du gradient de la dissipation thermique et du tenseur directionnel
*
lmvit  = 'MOTS' 'UX' 'UY' ;
mmgs   = GMASS _mt discg lmvit discr lmvit discr 1. ;
gfdti  = GGRADT _mt discg 'SCAL' 'CSTE' lmvit discr 1. fdt ;
*gfdt  = '/' gfdti vmtl ;
gfdts  = 'RESOUD' mmgs gfdti ;
gfdti  = GMASS _mt discg lmvit discr lmvit 'CSTE' 1. gfdts ;
gfdt   = '/' gfdti vmtl ;
'SI' (graph 'ET' debug) ;
   tit = 'CHAINE' 'Gradient de dissipation thermique ; i=' &bcl ;
   vvit = 'VECT' gfdt 'DEPL' 'JAUN' ;
   'TRACER' vvit mt 'TITR' tit ;
'FINSI' ;
*
* Lissage du gradient
*
'SI' lissg ;
   mms  = GMASS _mt discg  'SCAL' discg  'SCAL' discr 1. c1 ;
   gfdti = GMASS _mt discg lmvit 'CSTE' lmvit discr 1. gfdt ;
   gfdts = '/' gfdti mms ;
   gfdtsi = GMASS _mt discg lmvit discr lmvit 'CSTE' 1. gfdts ;
   gfdt   = '/' gfdtsi vmtl ;
   'SI' (graph 'ET' debug) ;
      tit = 'CHAINE' 'Gradient apres lissage ; i=' &bcl ;
      vvit = 'VECT' gfdt 'DEPL' 'JAUN' ;
      'TRACER' vvit mt 'TITR' tit ;
   'FINSI' ;
'FINSI' ;
*
nfdt   = 'PSCAL' gfdt gfdt lmvit lmvit ;
snfdt  = '**' nfdt 0.5D0 ;
msnfdt  = 'MAXIMUM' snfdt ;
'SI' ('<' msnfdt 1.D-100) ;
   binf = 1.D0 ;
'SINON' ;
   binf = '*' msnfdt 1.D-10 ;
'FINSI' ;
snfdt   = '+' snfdt binf ;
sgfdt  = '/' gfdt snfdt ;
'SI' (graph 'ET' debug) ;
   tit = 'CHAINE' 'Gddt mis a lechelle ; i=' &bcl ;
   vvit = 'VECT' sgfdt 'DEPL' 'JAUN' ;
   'TRACER' vvit mt 'TITR' tit ;
'FINSI' ;
td11 = '*' sgfdt sgfdt ('MOTS' 'UX') ('MOTS' 'UX') ('MOTS' 'SCAL') ;
td22 = '*' sgfdt sgfdt ('MOTS' 'UY') ('MOTS' 'UY') ('MOTS' 'SCAL') ;
td12 = '*' sgfdt sgfdt ('MOTS' 'UX') ('MOTS' 'UY') ('MOTS' 'SCAL') ;
* D'où le tenseur
gxx  = '**' fdt 2 ;
vdim = 'VALEUR' 'DIME' ;
limgd2 = '**' limgd 2 ;
gd1 = '**' ('/' gxx ('*' alpha alpha))
               ('/' 1.D0 vdim) ;
gd2 = '-' ('**' ('+' gd1 1.) vdim) 1. ;
*
* Considération pour les calculs de ngd :
* en 1D : gd1 = gd2, la partie anisotrope doit s'annuler
*
gdb = '-' ('*' ('**' ('+' gd1 1.) delta)
               ('**' ('+' gd2 1.) ('-' 1. delta))) 1. ;
gda = '-' ('**' ('+' gd1 1.) delta) 1. ;
dgd = '-' gdb gda ;
*
'SI' (graph 'ET' debug) ;
   rescal = 'KCHA' $mt ('**' gda 0.5D0) 'CHAM' ;
   tit = 'CHAINE' 'Partie isotrope de ladaptation'  ;
   'TRACER' rescal $mb 'TITR' tit ;
   rescal = 'KCHA' $mt ('**' dgd 0.5D0) 'CHAM' ;
   tit = 'CHAINE' 'Partie anisotrope de ladaptation'  ;
   'TRACER' rescal $mb 'TITR' tit ;
'FINSI' ;
*
* Limitation des valeurs supérieures
*
*  de la partie isotrope
   m1    = 'MASQUE' gda 'INFERIEUR' limgd2 ;
   m0    = '*' ('-' m1 1.) -1. ;
   gda   = '+' ('*' m1 gda) ('*' m0 limgd2) ;
* de la partie anisotrope
   gdb  = gda '+' dgd ;
   m1   = 'MASQUE' gdb 'INFERIEUR' limgd2 ;
   m0   = '*' ('-' m1 1.) -1. ;
   gdb  = '+' ('*' m1 gdb) ('*' m0 limgd2) ;
   dgd = '-' gdb gda ;
'SI' (graph 'ET' debug) ;
   rescal = 'KCHA' $mt ('**' gda 0.5D0) 'CHAM' ;
   tit = 'CHAINE' 'Partie isotrope de ladaptation apres lim'  ;
   'TRACER' rescal $mb 'TITR' tit ;
   rescal = 'KCHA' $mt ('**' dgd 0.5D0) 'CHAM' ;
   tit = 'CHAINE' 'Partie anisotrope de ladaptation apres lim'  ;
   'TRACER' rescal $mb 'TITR' tit ;
'FINSI' ;
*
* Le tenseur
*
   g11 = 'NOMC' 'G11' (gda '+' ('*' dgd td11) '+' 1.D0) ;
   g22 = 'NOMC' 'G22' (gda '+' ('*' dgd td22) '+' 1.D0) ;
   g21 = 'NOMC' 'G21' ('*' dgd td12) ;
   gtot = g11 '+' g22 '+' g21 ;
*
'RESPRO' gtot fdt ;
'FINPROC' ;
*
* Début du jeu de donnés
*
'OPTION' 'DIME' 2 ;
'SI' ('NON' interact) ;
  'OPTION' 'TRAC' 'PSC' ;
'SINON' ;
  'OPTION' 'TRAC' 'X' ;
'FINSI' ;
*
* Maillage
*
*   Paramètres d'adaptation :
*   beta :
*   0.   pas d'adaptation ;
*   0.5  la moitié des mailles dans les régions où le paramètre de
*        contrôle est grand
*   1.   toutes les mailles dans les régions où le paramètre de
*        contrôle est grand
*   Usuellement, 0.5 < beta < 0.8
*   lissd  : lissage de la dissipation thermique
*   limfdt : limitation de la dissipation thermique
*            on limite les valeurs qui dépassent (moy. fdt) * limfdt
*   limgd  : limitation de la diagonale du tenseur métrique
*            on limite les valeurs qui dépassent limgd
*   delta  : 0.D0 adaptation totalement anisotrope
*            1.D0 adaptation totalement isotrope
*   omi : relaxation de l'incrément vitesse-pression
*   omd : relaxation de l'incrément de déplacement du maillage
*   theta et gamma : paramètres de l'adapteur de DEDU ADAP
omi  = 0.5D0 ;
omd  = 0.5D0 ;
   'OPTI' 'ELEM' 'QUA8' ;
   'SI' complet ;
      nx = 25 ; ny = 25 ;
      cvg = 2.D-3 ; nitmax = 85 ;
      lRe = 'PROG' 100. 400. 1000. 3200. 5000. 7500. 10000. ;
      lerru = 'PROG' 3.E-03  1.E-03  3.E-03  6.E-03
                     6.E-03  7.E-03  8.E-03 ;
      lerrv = 'PROG' 6.E-03  2.E-03  4.E-03  6.E-03
                     6.E-03  5.E-03  1.E-02 ;
      beta = 0.7D0 ; lissd = FAUX ; limfdt = 7.D0 ;
*      beta = 0.8D0 ; lissd = FAUX ; limfdt = 7.D0 ;
*      beta = 0.7D0 ; lissd = FAUX ; limfdt = 5.D0 ;
*      theta = 0.5D0 ; gamma = 2.D0 ;
      theta = 0.5D0 ; gamma = 2.D0 ;
      lissg = FAUX  ; limgd = 15.D0 ;
      delta = 0.75D0 ;
*      delta = 0.5D0 ;
   'SINON' ;
      nx = 10 ; ny = 10 ;
*      nx = 15 ; ny = 15 ;
      cvg = 5.D-3 ; nitmax = 50 ;
      lRe = 'PROG' 100. 400. 1000. ;
*      lRe = 'PROG' 100. 400. 1000. 3200. 5000.  ;
      lerru = 'PROG' 4.E-03  7.E-03 2.E-02 ;
      lerrv = 'PROG' 5.E-03  9.E-03 2.E-02 ;
*      lerru = 'PROG' 4.E-03  7.E-03 2.E-02 1. 1. ;
*      lerrv = 'PROG' 5.E-03  9.E-03 2.E-02 1. 1. ;
      beta = 0.7D0 ; lissd = FAUX ; limfdt = 7.D0 ;
      theta = 0.5D0 ; gamma = 2.D0 ;
      lissg = FAUX ; limgd = 15.D0 ;
      delta = 0.75D0 ;
   'FINSI' ;
   lerruc = 'PROG' ;
   lerrvc = 'PROG' ;
   pA = 0. 0. ; pB = 1. 0. ; pC = 1. 1. ; pD = 0. 1. ;
   bas = 'DROIT' nx pA pB ; dro = 'DROIT' ny pB pC ;
   hau = 'DROIT' nx pC pD ; gau = 'DROIT' ny pD pA ;
   mt = 'DALLER' bas dro hau gau ;
   bor = 'CONTOUR' mt ;
_mt = 'CHANGER' mt 'QUAF' ;
$mt = 'MODE' _mt  'NAVIER_STOKES' 'QUAF' ;
$mb  = 'MODE' ('DOMA' $mt 'MAILLAGE') 'THERMIQUE' ;
mtl = 'CHANGER' mt 'LINEAIRE' ;
*
* Maillage sans les éléments de coin pour la prise des moyennes
*
_mtcoin = 'ELEM' _mt 'APPUYE' 'LARGEMENT' ('ET' pC pD) ;
_mtmoy  = 'DIFF' _mt _mtcoin ;
* Paramètres pour le décentrement
* lsupg : VRAI=decentrement
* csupg : facteur multiplicatif
lsupg  = FAUX ;
lsupgm = FAUX ;
csupg = 0.3D0 ;
*
* discg : discrétisation géométrique
* discv : discrétisation vitesse
* discp : discrétisation pression
* discr : discrétisation pour la mise au sommet du paramètre de contrôle
discg = 'QUAF' ;
discv = 'QUAF' ;
discp = 'LINE' ;
discr = 'LINE' ;
*
methgau = 'GAU7' ;
mxpri = 'MOTS' 'UX' 'UY' ;
mxdua = 'MOTS' 'FX' 'FY' ;
mppri = 'MOTS' 'LX' ;
mpdua = 'MOTS' 'FLX' ;
* Limitation du déplacement
ldmax = FAUX ;
dmax  = 1. ;
echvit = 1. ;
echdx = 1. ;
*
c1  = 'MANUEL' 'CHPO' mt ('MOTS' 'SCAL') ('PROG' 1.) ;
*
lok = VRAI ;
*
ccli = CALCLIM ;
inc = 'COPIER' ccli ;
*
dRe = 'DIME' lRe ;
'REPETER' iiRe dRe ;
   Re = 'EXTRAIRE' lRe &iiRe ;
   iRe = '/' 1. Re ;
* Numérique
   ap= 1.D0 '*' iRe ;
*
* Résumé du cas
*
   'SAUTER' 1 'LIGN' ;
   'MESSAGE' ('CHAINE' '***********************************') ;
   'MESSAGE' ('CHAINE' 'Résumé du cas :                    ') ;
   'MESSAGE' ('CHAINE' 'Nombre de maille  = ' nx ' x ' ny) ;
   'MESSAGE' ('CHAINE' 'Reynolds          = ' Re) ;
   'MESSAGE' ('CHAINE' 'Param. adaptation = ' beta) ;
   'MESSAGE' ('CHAINE' '***********************************') ;
*
* Algorithme
*
   'REPETER' bcl nitmax ;
      'SI' verbose ;
         'MESSAGE' ('CHAINE' 'Itération : ' &bcl ) ;
      'FINSI' ;
* Mise à jour des conditions aux limites
      ccli = CALCLIM ;
* Calcul des champs
      dinc = SOLAPP _mt inc ccli ;
      inc  = inc '+' ('*' dinc omi) ;
      vit = 'EXCO' mxpri inc ;
      pre = 'EXCO' mppri inc ;
      dvit = 'EXCO' mxpri dinc ;
      echdvit = 'MAXIMUM' dvit 'ABS' ;
      'SI' verbose ;
        'MESSAGE' ('CHAINE' '   Echelle increment vitesse : ' echdvit) ;
      'FINSI' ;
*
      'SI' (graph 'ET' debug) ;
         tit = 'CHAINE' 'Vitesse ; i=' &bcl ;
         vvit = 'VECT' ('/' 1.D0 nx) vit 'DEPL' 'JAUN' ;
         'TRACER' vvit mt 'TITR' tit ;
      'FINSI' ;
      'SI' (graph 'ET' debug) ;
         tit = 'CHAINE' 'Pression ; i=' &bcl ;
         'TRACER' pre mtl 'TITR' tit ;
      'FINSI' ;
*
* Calcul du champ de déplacement
*
*    Construction de la métrique
      tdcd fdt = TGDENT _mt vit beta ;
      'SI' graph ;
         rescal = 'KCHA' $mt fdt 'CHAM' ;
         vvit = 'VECT' ('/' 1.D0 nx) vit 'DEPL' 'JAUN' ;
         tit = 'CHAINE' 'Diss. therm. + Vitesse ; i=' &bcl ' ; Re='
                Re ;
         'SI' debug ;
            'TRACER' $mb rescal vvit _mt 'TITR' tit ;
         'SINON' ;
            'TRACER' $mb rescal vvit _mt 'TITR' tit 'NCLK' ;
         'FINSI' ;
      'FINSI' ;
*   Champ de déplacement
      mblox = 'BLOQUE' 'UX' (gau 'ET' dro) ;
      mbloy = 'BLOQUE' 'UY' (bas 'ET' hau) ;
      mblo = mblox 'ET' mbloy ;
      dep = 'DEDU' 'ADAP' _mt mblo 'DISG' discg
                          'METR' tdcd 'CSTE' 'THET' theta 'GAMM' gamma
                          'NITM' 1  'METG' methgau ;
*
      echdep = 'MAXIMUM' dep 'ABS' ;
      'SI' verbose ;
         'MESSAGE' ('CHAINE' '   Echelle des depl. : ' echdep) ;
      'FINSI' ;
*
      'SI' ldmax ;
         'SI' ('>' echdep dmax) ;
            fdep = '/' dmax echdep ;
            dep = '*' dep fdep ;
         'FINSI' ;
         'SI' verbose ;
            'MESSAGE'
              ('CHAINE' '   Echelle des depl. apres lim : ' echdep) ;
         'FINSI' ;
      'FINSI' ;
      dep = '*' dep omd ;
      crit2 = '<' ('/' echdep echdx) cvg ;
      'SI' ('NON' crit2) ;
         'FORME' dep ;
      'FINSI' ;
      ciso = DEADUTIL 'QISO' _mt discg 'GAU7' tdcd 'CSTE' ;
      cequ = DEADUTIL 'QEQU' _mt discg 'GAU7' tdcd 'CSTE' ;
      maciso = 'MAXIMUM' ciso ; miciso = 'MINIMUM' ciso ;
      macequ = 'MAXIMUM' cequ ; micequ = 'MINIMUM' cequ ;
      'SI' verbose ;
         'MESSAGE' ('CHAINE'
            '   CISO : max. = ' maciso '  min. = ' miciso) ;
         'MESSAGE' ('CHAINE'
            '   CEQU : max. = ' macequ '  min. = ' micequ) ;
      'FINSI' ;
      'SI' (graph 'ET' debug) ;
         cliso = 'KCHA' $mt ciso 'CHAM' ;
         tit = 'CHAINE' 'Isotropie ; i=' &bcl ' ; Re=' Re ;
         'TRACER' cliso $mb 'TITR' tit ;
         clequ = 'KCHA' $mt cequ 'CHAM' ;
         tit = 'CHAINE' 'Equidis. ; i=' &bcl ' ; Re=' Re ;
         'TRACER' clequ $mb 'TITR' tit ;
      'FINSI' ;
* Critères de convergence :
* sur les incréments
      crit1 = '<' ('/' echdvit echvit) cvg ;
      crit2 = '<' ('/' echdep echdx) cvg ;
      'SI' ('ET' crit1 crit2) ;
         'QUITTER' bcl ;
      'FINSI' ;
   'FIN' bcl ;
   'SI' ('ET' graph interact) ;
      tit = 'CHAINE' 'Vitesse ; Re=' Re ;
      vvit = 'VECT' ('/' 2.D0 nx) vit 'DEPL' 'JAUN' ;
      'TRACER' vvit mt 'TITR' tit ;
   'FINSI' ;
*
   ly lu lx lv = GHIA Re ;
   lxd = 'PROG' ('DIME' ly) '*' 0.5D0 ;
   lyd = 'PROG' ('DIME' lx) '*' 0.5D0 ;
   lig1 = 'QUELCONQUE' 'SEG2' lxd ly ;
   lig2 = 'QUELCONQUE' 'SEG2' lx lyd ;
*
   chamvit = 'CHANGER' 'CHAM' vit _mt ;
*
* U(y)
*
   lun = PROI lig1 ('EXCO' 'UX' chamvit) ;
   evghia = 'EVOL' 'MANU' ly lu ;
   evnum  = 'EVOL' 'CHPO' lun 'UX' lig1 ;
   'SI' graph ;
      evt = evghia 'ET' evnum ;
      tabt = 'TABLE' ;
      tabt . 1 = 'CHAINE' 'Ghia' ;
      tabt . 2 = 'CHAINE' 'Nous' ;
      tit = 'CHAINE' 'Profil U(y) ; Re=' Re ;
      titx = 'CHAINE' 'y' ;
      tity = 'CHAINE' 'U' ;
      DESSEVOL evt tabt tit titx tity ;
   'FINSI' ;
   erru = 'EXTRAIRE' ('INTG' ('-' evghia evnum) 'ABSO') 1 ;
   'MESSAGE' ('CHAINE' '   erru = ' erru) ;
   lerruc = 'ET' lerruc ('PROG' erru) ;
   verur = 'EXTRAIRE' lerru &iiRe ;
   teru = ('<' erru verur) ;
   'SI' ('NON' teru) ;
      cherr = 'CHAINE' '!!! Erreur, on aurait voulu erru < ' verur ;
     'MESSAGE' cherr ;
   'FINSI' ;
   lok = 'ET' lok teru ;
*
* V(x)
*
   lvn = PROI lig2 ('EXCO' 'UY' chamvit) ;
   evghia = 'EVOL' 'MANU' lx lv ;
   evnum  = 'EVOL' 'CHPO' lvn 'UY' lig2 ;
   'SI' graph ;
      evt = evghia 'ET' evnum ;
      tabt = 'TABLE' ;
      tabt . 1 = 'CHAINE' 'Ghia' ;
      tabt . 2 = 'CHAINE' 'Nous' ;
      tit = 'CHAINE' 'Profil V(x) ; Re=' Re ;
      titx = 'CHAINE' 'x' ;
      tity = 'CHAINE' 'V' ;
      DESSEVOL evt tabt tit titx tity ;
   'FINSI' ;
   errv = 'EXTRAIRE' ('INTG' ('-' evghia evnum) 'ABSO') 1 ;
   'MESSAGE' ('CHAINE' '   errv = ' errv) ;
   lerrvc = 'ET' lerrvc ('PROG' errv) ;
   vervr = 'EXTRAIRE' lerrv &iiRe ;
   terv = ('<' errv vervr) ;
   'SI' ('NON' terv) ;
      cherr = 'CHAINE' '!!! Erreur, on aurait voulu errv < ' vervr ;
     'MESSAGE' cherr ;
   'FINSI' ;
   lok = 'ET' lok terv ;
'FIN' iiRe ;
*
* Fin du jeu de donnees
*
'SAUTER' 2 'LIGNE' ;
'SI' lok ;
   'MESSAGE' 'Tout sest bien passe' ;
'SINON' ;
   'MESSAGE' 'Il y a eu des erreurs' ;
'FINSI' ;
'SAUTER' 2 'LIGNE' ;
'SI' interact ;
   'OPTION' 'DONN' 5 'ECHO' 1 ;
'FINSI' ;
'SI' ('NON' lok) ;
   'ERREUR' 5 ;
'FINSI' ;
*
* End of dgibi file DEDU_GHIA
*
'FIN' ;











