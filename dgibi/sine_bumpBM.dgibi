* fichier :  sine_bumpBM.dgibi
******************************************************************
* CALCUL DE L'ECOULEMENT SUBSONIQUE STATIONNAIRE DANS UN CANAL   *
* AVEC SINE-SHAPED BUMP                                          *
* FORMULATION VF COMPRESSIBLE EXPLICITE/IMPLICIT                 *
*                                                                *
* H. PAILLERE/P. GALON TTMF AOUT 1997                            *
*                                                                *
* MODIF BECCANTINI MARS 97                                       *
*                                                                *
*       BECCANTINI NOVEMBRE  98                                  *
*  Low Mach AUSM+ scheme is used for computation                 *
******************************************************************

 'MESSAGE' 'A mettre a jours' ;
 'FIN' ;

* GRAPH = VRAI ;
 GRAPH = FAUX ;
 COMPLET = FAUX ;

 'SI' complet ;
   NRAFF = 3 ;
 'SINON' ;
   NRAFF = 1 ;
 'FINSI' ;

 ENTERR = 0.00001D0 ;

 TYEL = 'QUA4' ;

 'OPTION'  'DIME' 2  'ELEM' TYEL  'ISOV' 'SULI'
   'ECHO' 1 'TRAC' 'X';

*
*** C.L. et initiales
*

 RO_INF = 1.4D0 ;
 P_INF  = 1.0D0 ;
 U_INF  = 0.001D0 ;
 GAMSCAL    = 1.4D0;


************************************************************************
************************************************************************
***************** PARTIE PROCEDURES ************************************
************************************************************************
************************************************************************
*******************************************************
***** PROCEDURE TO COMPUTE CONSERVATIVE VARIABLES *****
*******************************************************

 'DEBPROC' CONS ;
 'ARGUMENT' RN*'CHPOINT' VN* 'CHPOINT' PN*'CHPOINT' GAMN*'CHPOINT' ;

 RVN  =  RN '*' VN ;
 LMOT = 'MOTS' 'UX' 'UY' ;
 RECIN = 0.5 '*' (RVN 'PSCA' VN LMOT LMOT) ;
 RETER = PN '/' (GAMN '-' 1.0)  ;
 REN = RETER '+' RECIN ;

 'RESPRO' RVN REN ;
 'FINPROC' ;

*****************************************************
*****************************************************
** PROCEDURE EXEX POUR FORMULATION VF COMPRESSIBLE **
*****************************************************
*****************************************************
*
* RV  . 'UN'      = les inconnues
*
* RV . 'CLIM'     = logique qui me dit si existe une procedure pour le
*                   calcul de conditions limits
*
* RV . 'DOMINT'   = (a definir si RV . 'CLIM')
*                   spg des incunnues (sans les cellules fantomes)
*
* RV . 'MAIFAN'   = (a definir si RV . 'CLIM')
*                   les cellules fantomes
*
* RV . 'INST'     = logique qui me dit si on fait un calcul stationaire
*                   ou instationaire. Si FAUX, le temps n'est pas une
*                   variable du probleme
*
* RV . 'CONS'     = (à definir dans le cas d'un calcul instationaire)
*                   logique qui me dit si on fait une correction
*                   conservative à la fin des iterations internes
*
* RV . 'TFINAL'   = (à definir dans le cas d'un calcul instationaire)
*                   le temps final
*
* RV . 'NITMAEX'  = (à definir dans le cas d'un calcul instationaire)
*                   le numero d'iteration externes
*
* N.B. Si RV . 'TFINAL' et RV . 'NITMAEX' sont les deux specifiés, on
*      s'arrete quand un des deux criteres et satisfait
*
* RV . 'FEXT'     = (à definir dans le cas d'un calcul instationaire)
*                   indice de frequence d'impression pour les
*                   iterations externes
*
* RV . 'MATIDE'   = (à definir dans le cas d'un calcul instationaire)
*                   MATRIK identité
*                   N.B. (RV . 'MATIDE') '*' (RV . 'UN') =
*                        (RV . 'UN')
*
* RV . 'LISTOPER' = liste des operateurs (ou des procedures) qui
*                   interviennent dans le calcul (chaque operateur a un
*                   table associée), qui s'appelle &NOMPER ou
*                   & = position de l'operateur dedans cette liste
*                   NOMPER = noms de l'operateur ou de la procedure
*
* RV . 'NITMAIN' =  (à definir dans le cas d'un calcul implicite)
*                   le numero max d'iteration internes
* RV . 'NITMIIN' =  (à definir dans le cas d'un calcul implicite)
*                   le numero min d'iteration internes
*
* RV . 'EPSINT'   = (à definir dans le cas d'un calcul implicite)
*                   l'erreur pour le critere de convergence sur les
*                   iterations internes
*
* RV . 'FINT'     = (à definir dans le cas d'un calcul implicite)
*                   indice de frequence d'impression pour les
*                   iterations internes
*
* RV . 'MATHINV'  = (a definir sans la cas d'un calcul implicite)
*                   table de SOUSTYPE 'TYPINV' pour l'inversion de
*                   MATRIK (pour l'operateur 'KRES')
*
* RV . 'PBASMACH'  = (à definir si on veut faire du preconditionnement
*                     BASMACH)
*                    LOGIQUE = VRAI '/' FAUX
*                    Dans le cas VRAI, il faut utiliser la procedure BMAC
*                    et remplir la table 'BASMACH'.
*
*--------------------------------------------------------------------------


 'DEBPROC'  EXEXIM ;
 'ARGUMENT' RV*TABLE ;

 'MESSAGE' ;
 'MESSAGE' 'PROCEDURE EXEXIM' ;

*
**** Initialisation d'un CHPOINT 'ET' d'une MATRIK vide
*

 CHPVID MATVID = 'KOPS' 'MATRIK' ;


*
**** Les inconnues
*

 'SI' ('NON' ('EXISTE' RV  'UN')) ;
    'MESSAGE' 'UN = ???' ;
    'ERREUR' 21 ;
 'FINSI' ;

*
**** Existence d'une procédure pour imposer le conditions aux limites
*    à chaque iteration (interne ou externe)
*

 'SI' ('NON' ('EXISTE' RV 'CLIM')) ;
    'MESSAGE' 'CLIM = ???' ;
    'ERREUR' 21 ;
 'FINSI' ;

* Par securité, on les impose tout de suite

 'SI' (RV . 'CLIM') ;
    'SI' ('NON' ('EXISTE' RV  'DOMINT')) ;
       'MESSAGE' 'DOMINT = ???' ;
       'ERREUR' 21 ;
    'FINSI' ;
    'SI' ('NON' ('EXISTE' RV  'MAIFAN')) ;
       'MESSAGE' 'MAIFAN = ???' ;
       'ERREUR' 21 ;
    'FINSI' ;
*   On impose une variation de l'incrément nul sur les
*   cellules fantômes
    DUCLIM = 0.0 '*' ('REDU' (RV . 'UN') (RV . 'MAIFAN')) ;
*    'MESS' 'PROLIM at the beginning' ;
    RV . 'UN' = PROLIM RV ;
 'SINON' ;
    DUCLIM = 'COPIER' CHPVID ;
 'FINSI' ;

*
**** Stationnaire ou instationnaire ?
*

 'SI' ('NON' ('EXISTE' RV 'INST')) ;
    'MESSAGE' 'INST = ???' ;
    'ERREUR' 21 ;
 'SINON' ;
    'SI' ('NEG' ('TYPE' (RV . 'INST')) 'LOGIQUE') ;
       'MESSAGE' 'INST = ???' ;
       'ERREUR' 21 ;
    'FINSI' ;
 'FINSI' ;
 LOGINS = RV . 'INST' ;

 'SI' LOGINS ;
    'SI' ('NON' ('EXISTE' RV 'CONS')) ;
       'MESSAGE' 'CONS = ???' ;
       'ERREUR' 21 ;
    'SINON' ;
       LOGCC = RV . 'CONS' ;
    'FINSI' ;
 'SINON' ;
    'SI' ('EXISTE' RV 'CONS') ;
       'SI' (RV . 'CONS') ;
          'MESSAGE' 'Calcul stationnaire' ;
          'MESSAGE' 'Correction conservative impossible !!!' ;
          'MESSAGE' 'CONS = ???' ;
          'ERREUR' 21 ;
       'FINSI' ;
    'FINSI' ;
 'FINSI' ;

*
**** BASMACH?
*

 'SI' ('EXISTE' RV 'PBASMACH') ;
    LOGBM = RV . 'PBASMACH' ;
 'SINON' ;
    LOGBM = FAUX ;
 'FINSI' ;
 'SI' ('EGA' LOGBM  VRAI) ;
    'MESSAGE' ;
    'MESSAGE' 'Dual time stepping avec preconditionnement bas mach' ;
    'MESSAGE' ;
 'FINSI' ;

*
**** Iterations externes et/ou temps final
*    La table 'PASDETPS'
*

 'SI' LOGINS ;

    'MESSAGE' 'Calcul instationnaire' ;
    'MESSAGE' ;

    'SI' ('NON'
       (('EXISTE' RV 'NITMAEX') 'OU' ('EXISTE' RV 'TFINAL'))) ;
       'MESSAGE'  'NITMAEX = ???' ;
       'MESSAGE'     'ou' ;
       'MESSAGE'  'TFINAL = ???' ;
       'ERREUR' 21 ;
    'FINSI' ;


    'SI' ('NON' ('EXISTE' RV 'MATIDE')) ;
       'MESSAGE' 'MATIDE 1 = ???' ;
       'ERREUR' 21 ;
    'SINON' ;
       'SI' ('NON' LOGBM) ;
****** Compatibilité matrice identité - vecteur des inconnues
          CELL = 'KOPS' (RV . 'MATIDE') 'MULT' (RV . 'UN') ;
          CELL = CELL '-' (RV . 'UN') ;
          CELL = 'MAXIMUM' CELL 'ABS' ;
          'SI' (CELL > 1.0D-14) ;
             'MESSAGE' 'MATIDE 2 = ???' ;
             'ERREUR' 21 ;
          'FINSI' ;
       'FINSI' ;
    'FINSI' ;

    'SI' ('NON' ('EXISTE' RV 'PASDETPS')) ;
       RV . 'PASDETPS' = 'TABLE' ;
    'FINSI' ;

    KTPS = RV . 'PASDETPS' ;

* Initialisation éventuelle de la table

    'SI' ('NON' ('EXISTE' KTPS 'NUPASDT')) ;
       KTPS . 'NUPASDT' = 0 ;
       KTPS . 'TPSM' = 0.0D0 ;
       KTPS . 'TPS'  = 0.0D0 ;
    'SINON' ;
       'SI' ('EGA' ( KTPS . 'NUPASDT' ) 0) ;
          KTPS . 'TPSM' = 0.0D0 ;
          KTPS . 'TPS'  = 0.0D0 ;
       'FINSI' ;
    'FINSI' ;

*
* Dans le cas instationnaire, KTPS contient
*
* KTPS . 'NUPASDT' = numero de pas de TPS actuel dans les itérations
* internes
*
* KTPS . 'TPSM'    = le TPS aprés (KTPS . 'NUPASDT'  '-' 2) itérations
* KTPS . 'TPS'     = le TPS aprés (KTPS . 'NUPASDT'  '-' 1) itérations
* KTPS . 'TPSP'    = le TPS aprés (KTPS . 'NUPASDT') itérations, i.e. à
* la fin de l'itération actuelle
*
*
  'SINON' ;

    'MESSAGE' ;
    'MESSAGE' 'Calcul stationnaire' ;
    'MESSAGE' ;

  'FINSI' ;

*
****** Initialisation du CHPOINT DELTAU pour 'KRES'
*

       DELTAU = 'COPIER' CHPVID ;

**************************************************
**************************************************
****   Itérations externes ***********************
**************************************************
**************************************************

 LOGEXP = VRAI ;
* LOGEXP = variable logique qui me dit si on est en explicite ;
*          on l'initialise = VRAI

 LOGQIE = FAUX 'OU' ('NON' LOGINS) ;
*
**** Boucle qui s'arrête quand LOGQIE = VRAI ; i.e.
*
*    -dans le cas instationnaire, quand
*     (KTPS . NUPASDT) = (RV . 'NITMAEX')
*      ou
*     (KTPS . 'TPS') = (RV . 'TFINAL');
*
*    -dans le cas stationnaire on ne fait que une itération
*     externe
*
 ALPDT = 0.0 ;

 'REPETER'  BLEX  -1  ;

    'SI' LOGINS ;
       KTPS . 'NUPASDT' = (KTPS . 'NUPASDT') '+' 1 ;
       'SI' ('EXISTE' RV 'NITMAEX') ;
          'SI' ( (KTPS . 'NUPASDT') '>EG' (RV . 'NITMAEX')) ;
             LOGQIE = VRAI ;
          'FINSI' ;
       'FINSI' ;
*
****** Impression evenctuelle
*

       ICEL = (KTPS . 'NUPASDT') '/' (RV . 'FEXT') ;
       LOGPRI = 'EGA' (ICEL '*' (RV . 'FEXT')) (KTPS . 'NUPASDT') ;
       'SI' (LOGPRI) ;
           'MESSAGE' ('CHAINE' 'PASDETPS = ' (KTPS . 'NUPASDT')
              '  TPS = ' (KTPS . 'TPS') '  DT = ' ALPDT) ;
           'MESSAGE' ;
       'FINSI' ;
    'FINSI' ;

*
*** Objets MATRIK et CHPOINTs vides
*   LISTREEL de DT_i * ALPHA_i
*   UNM = (RV . 'UN') à l'iteration precedente
*

    RESIMP = 'COPIER' CHPVID ;
    MATASS = 'KOPS' 'MULT' 0.0  MATVID ;
    RESEXP = 'COPIER' CHPVID ;
    UNM = ('COPIER' (RV . 'UN')) ;
    LREEDT = 'PROG' ;
*
***********************************************
********* Boucle sur les operateurs ***********
***********************************************
*** On calcule: LREEDT
*               RESEXP
*              (RESIMP)
*              (MATASS)
*

    'REPETER'   BLOP  ('DIME'  (RV . 'LISTOPER')) ;
       NOMPER  = 'EXTRAIRE'  &BLOP  (RV . 'LISTOPER') ;
       NOTABLE = 'MOT'  ('TEXTE'  ('CHAINE'  &BLOP  NOMPER) ) ;
*       'MESSAGE'  ('CHAINE' 'pervaya' NOMPER NOTABLE ) ;
       JACO RESIDU ALPHADT THETA = ('TEXTE'  NOMPER) (RV . NOTABLE) ;
*       'MESSAGE'  ('CHAINE' 'vtoraya' NOMPER NOTABLE ) ;
*
*      JACO    = objet de type MATRIK (éventuellement vide)
*      RESIDU  =     "         RESIDU          "
*      ALPHADT =     "         LISTREEL        "
*      THETA   =     "         REEL
*
******* On controlle la compatibilité E/S (pour chaque &BLEX)
*
       NCOMP = 'DIME' ('EXTRAIRE' RESIDU 'COMP') ;
*      NCOMP = 0 si RESIDU = CHPOINT vide
       'SI' (NCOMP > 0) ;
          LOGEXP = LOGEXP 'ET' ('EGA' THETA 0.0D0) ;
          'SI' (('NON' LOGINS) 'ET' ('NEG' THETA 1.0D0)) ;
              'MESSAGE' 'INST = FAUX ' ;
              'MESSAGE' ('CHAINE' NOMPER ' . THETA != 1') ;
              'ERREUR' 21 ;
          'FINSI' ;
       'FINSI' ;
*
******* On calcule LREEDT
*
       LREEDT = LREEDT 'ET' ALPHADT ;
*
******* On calcule MATASS, RESEXP, RESIMP
*
       MATASS = MATASS 'ET' ('KOPS' 'MULT' (-1.0D0 '*' THETA)
                   JACO ) ;
       RESIMP = RESIMP 'ET' (RESIDU '*' THETA) ;
       RESEXP = RESEXP 'ET' ( RESIDU '*'(1.0D0 '-' THETA)) ;

    'FIN'  BLOP ;

***********************************************
***** Fin  de la boucle sur les operateurs ****
***********************************************

*
******* On controlle la compatibilité E/S (si &BLEX = 1)
*
    'SI' ('EGA' &BLEX 1) ;
*
**** Dans le cas implicite, on verifie l'existence
*    des parametres pour les itérations internes
*
       'SI' ('NON' LOGEXP) ;
          'SI' ('NON' (('EXISTE' RV  'NITMAIN') 'ET'
             ('EXISTE' RV  'EPSINT') 'ET' ('EXISTE' RV  'NITMIIN'))) ;
             'MESSAGE' 'NITMAIN = ??? ' ;
             'MESSAGE' 'NITMIIN = ??? ' ;
             'MESSAGE' 'EPSINT  = ??? ' ;
             'ERREUR' 21 ;
          'FINSI' ;
       'FINSI' ;

    'FINSI' ;
*
******* Fin contrôle compatibilité E/S
*
*
*** Mise a jour de la table RV . 'PASDETPS' au debu du calcul
*

    'SI' LOGINS ;
       ALPDT = 'MINIMUM' LREEDT ;
       ALPDT1 =  (RV . 'TFINAL') '-' (KTPS . 'TPS') ;
       'SI' (ALPDT < ALPDT1) ;
          KTPS . 'TPSP' = (KTPS . 'TPS') '+' ALPDT ;
       'SINON' ;
          KTPS . 'TPSP' =  (RV . 'TFINAL') ;
          ALPDT = ALPDT1 ;
          LOGQIE = VRAI ;
       'FINSI' ;
    'FINSI' ;

*

    'SI' LOGEXP ;
*
****** Explicite
*
       RV . 'UN' = UNM '+' (RESEXP '*' ALPDT) ;
       'SI' (RV . 'CLIM') ;
*          'MESSAGE' 'PROLIM after an explicit iteration' ;
          RV . 'UN' = PROLIM RV ;
       'FINSI' ;

    'SINON' ;
*
****** Implicite
*
       'SI' LOGINS ;
          UNEXP = UNM  '+' (ALPDT '*' RESEXP) ;
          UNIMP = (ALPDT '*' RESIMP) '-' (RV . 'UN') ;
       'SINON' ;
          UNEXP = RESEXP ;
          UNIMP = RESIMP ;
       'FINSI' ;

**********************************************
****** Les iterations internes ***************
**********************************************

       'REPETER' BLINT (RV . 'NITMAIN') ;

          'SI' LOGINS ;
             MATASS = ('KOPS' 'MULT'  ALPDT  MATASS)
               'ET' (RV . 'MATIDE') ;
          'FINSI' ;

          DRESTOT = UNEXP '+' UNIMP ;

*
********* Pour l'inversion de MATRIK
*

          RV . 'MATINV' . 'MATASS' = MATASS ;
          RV . 'MATINV' . 'MAPREC' = MATASS ;
          RV . 'MATINV' . 'XINIT' = DELTAU ;
          RV . 'MATTOT' = 'KOPS' 'MULT' 1.0 MATASS ;

          DELTAU = 'KRES' MATASS
                'TYPI' (RV . 'MATINV')
                'CLIM' DUCLIM
                'SMBR' DRESTOT
                'IMPR' 0 ;

          RV . 'UN' = (RV . 'UN') '+' DELTAU ;

          'SI' (RV . 'CLIM') ;
*             'MESSAGE' 'PROLIM after the matrix inversion' ;
             RV . 'UN' = PROLIM RV ;
          'FINSI' ;

*
********* Boucle sur les operateurs implicites pour calculer RESIMP
*         et MATASS de RV . 'UN'

          RESIMP = 'COPIER' CHPVID ;
          MATASS = 'KOPS' 'MULT' 0.0 MATVID ;
          'REPETER'   BLOP  ('DIME'  (RV . 'LISTOPER')) ;
             NOMPER  = 'EXTRAIRE'  &BLOP  (RV . 'LISTOPER') ;
             NOTABLE = 'MOT'  ('TEXTE'  ('CHAINE'  &BLOP  NOMPER) ) ;
             'SI' (RV . NOTABLE . 'IMPL') ;
                   JACO RESIDU ALPHADT THETA =
                      ('TEXTE'  NOMPER) (RV . NOTABLE) ;
                   MATASS = MATASS 'ET' ('KOPS' 'MULT'
                            (-1.0D0 '*' THETA)
                      JACO ) ;
                   RESIMP = RESIMP 'ET' (RESIDU '*' THETA) ;
             'FINSI' ;
          'FIN'  BLOP ;
*
********* Test de convergence
*
          'SI' LOGINS ;
             UNIMP = (ALPDT '*' RESIMP) '-' (RV . 'UN') ;
          'SINON' ;
             UNIMP = RESIMP ;
          'FINSI' ;

          'SI' (RV . 'CLIM') ;
             ERRN = 'REDU' (UNEXP '+' UNIMP) (RV . 'DOMINT') ;
          'SINON' ;
             ERRN = UNEXP '+' UNIMP ;
          'FINSI' ;

          ERRO = 'MAXIMUM' ERRN 'ABS' ;
*
********* Impression evenctuelle
*
          ICEL = &BLINT '/' (RV . 'FINT') ;
          'SI' ( 'EGA' (ICEL '*' (RV . 'FINT')) &BLINT );
             'SI' LOGINS ;
                'MESSAGE' ('CHAINE' 'PASDETPS = ' (KTPS . 'NUPASDT')
                   '  TPS = ' (KTPS . 'TPS') '  DT = ' ALPDT) ;
              'FINSI' ;
              'MESSAGE'
                 ('CHAINE' 'ITERIN = ' &BLINT ' ERREUR = ' ERRO) ;
              'MESSAGE' ;
          'FINSI' ;
          'SI' ((ERRO '<' (RV . 'EPSINT')) 'ET'
                (&BLINT '>' (RV . 'NITMIIN')))  ;
             'QUITTER' BLINT ;
          'FINSI' ;
       'FIN' BLINT ;

**********************************************
****** Fin boucle iterations internes ********
**********************************************

*
****** Non convergence
*
       'SI' (ERRO > (RV . 'EPSINT')) ;
          'MESSAGE' ;
          'MESSAGE' 'Iteration internes: probleme de convergence' ;
          'SI' LOGINS ;
             'MESSAGE' ('CHAINE' 'PASDETPS = ' (KTPS . 'NUPASDT')
                  '  TPS = ' (KTPS . 'TPS') '  DT = ' ALPDT) ;
          'FINSI' ;
          'MESSAGE' ('CHAINE' 'ITERIN = ' &BLINT ' ERRO = ' ERRO) ;
          'MESSAGE' ;
       'SINON' ;
*
********* Correction conservative
*
          'SI' LOGINS ;
             'SI' LOGCC ;
                RESIMP = 'COPIER' CHPVID ;
                'REPETER'   BLOP  ('DIME'  (RV . 'LISTOPER')) ;
                   NOMPER  = 'EXTRAIRE'  &BLOP  (RV . 'LISTOPER') ;
                   NOTABLE = 'MOT'
                      ('TEXTE'  ('CHAINE'  &BLOP  NOMPER) ) ;
                   'SI' (RV . NOTABLE . 'IMPL') ;
                         JACO RESIDU ALPHADT THETA =
                            ('TEXTE'  NOMPER) (RV . NOTABLE) ;
                         RESIMP = RESIMP 'ET' (RESIDU '*' THETA) ;
                   'FINSI' ;
                'FIN'  BLOP ;
*
                RV . 'UN' = UNEXP '+' (ALPDT '*' RESIMP) ;
                'SI' (RV . 'CLIM') ;
*                   'MESSAGE' 'PROLIM after the conservative correction'
                   ;
                   RV . 'UN' = PROLIM RV ;
                'FINSI' ;
             'FINSI' ;
          'FINSI' ;

*
       'FINSI' ;
*
    'FINSI' ;

*
*** Mise a jour de la table RV . 'PASDETPS' à la fin du calcul
*

    'SI' LOGINS ;
       KTPS . 'TPSM' =  KTPS . 'TPS' ;
       KTPS . 'TPS'  =  KTPS . 'TPSP' ;

    'FINSI' ;

*
**** Dernier commande de BLEX
*
    'SI' LOGQIE ;
       'QUITTER' BLEX ;
    'FINSI' ;

 'FIN' BLEX ;

 'FINPROC'  ;

*****************************************************
*****************************************************
** FIN PROCEDURE EXEX                              **
*****************************************************
*****************************************************

*****************************************************
*****************************************************
** PROCÉDURE PKON                                  **
*****************************************************
*****************************************************
* Il faut définir:
*
* *KKONV . 'EQEX'     = table générale, qui contient toutes les
*                       informations sur le calcul qu'on va faire.
*                       Dans ce table, on ne prend que:
*                       - l'information concernant le pas de temps pour
*                         l'étape de prédiction (dans le cas de prédiction
*                         correction à la van Leer - Hanel);
*                       - les inconnues du problème
*                         (KKONV . 'EQEX' . 'UN'
*
* *KKONV . 'GAZ'      = le modelé de gaz qu'on considère
*                       - si KKONV . 'GAZ' = 'PERFMONO', alors
*                         on considère un gaz parfait mono-espèce
*                         polytropique; dans se cas on doit définir le
*                         gamma , i.e.
*                         KKONV . 'GAMN'
*                       -si KKONV . 'GAZ' = 'PERFTEMP', alors
*                         on considère un gaz parfait; dans se cas on
*                         doit définir la table de proprietés de gaz,
*                         i.e. KKONV . 'PGAZ'
*
* *KKONV . 'DOMA'     = table domaine
*
* *KKONV . 'LISTINCO' = les noms des inconnues
*                       - en 2D (3D)  'PERFMONO'
*                         la première composante est le nom de la densité;
*                         la deuxième, la troisième (la quatrième) sont le
*                         noms des composantes du momentum;
*                         la quatrième (cinquième) est le nom de l'énergie
*                         total.
*                       - en  2D (3D) 'PERFTEMP' on peut avoir aussi:
*                         les especes dans le meme ordre que en
*                         KKONV . 'PGAZ' . 'ESPEULE'
*                         les scalaires passifs dans le meme ordre que en
*                         KKONV . 'PGAZ' . 'SCALPASS'
*
*
* *KKONV . 'METHODE'  = méthode pour le calcul du flux convectif
*
* *KKONV . 'ORDREESP' = ordre en espace (1 ou 2) ;
*
* *KKONV . 'LIMITEUR' = limiteur utilisé
*
* *KKONV . 'PREDCOR'  = logique à définir dans le cas explicite. Si
*                       égal à VRAI, on fait la prediction-correction
*                       de van Leer - Hancock
*
* *KKONV . 'IMPL'     = calcul implicite ou non ?
*
* *KKONV . 'TYPEJACO' = 'VLHJACO1', si implicitation of VLH (1er ordre)
*                       'AUSMJAC1', si implicitation of AUSM+ (1er ordre)
*                       'VLHJACO2', si implicitation of VLH (2em ordre)
*                       'AUSMJAC2', si implicitation of AUSM+ (2em ordre)
*                       'AUSMLMJ1', si implicitation of AUSM+(P)(1st ordre)
*                       'CENJACO1', si implicitation of VLH (1er ordre)*
*
* *KKONV . 'THETA'    = paramètre entre 0 et 1 à définir dans le cas
*                       de calcul implicite.
*                       N.B.
*                       a) Dans le cas explicite, il ne faut pas le
*                          définir.
*                       b) Dans les autre cas:
*                          - si égal à 0, la méthode degenere au cas
*                            explicite;
*                          - si égal à 1, on a le cas implicite
*                          - si égal à 0.5, on a Cranck-Nicholson
*
* *KKONV . 'ALPHA'    = coefficient de securité pour le quel on
*                       multiplie le pas de tps determiné par un
*                       condition de type CFL.
*                       Il peut etre:
*                       - un flottant
*                       - une mot que veut 'INF'
*
* *KKONV . 'GRADRN'
* *KKONV . 'GRADVN'
* *KKONV . 'GRADPN'
* *KKONV . 'GRADYN'
* *KKONV . 'GRADSN' = MCHAMLs pour calculer les gradients de densité,
*                     vitesse, pression, fractions massiques,
*                     scalaires passifs
*
* *KKON . 'FACELIM' = maillage de centres de face ou on compute pas
*                     le flux convectif

 'DEBPROC'  PKON ;
 'ARGUMENT' KKONV * TABLE ;

 METO = KKONV . 'METHODE' ;
 RV = KKONV . 'EQEX' ;

 LOGIMP = KKONV . 'IMPL';
 LOGEXP = 'NON' LOGIMP ;

 'SI' LOGIMP ;
    THETA = KKONV . 'THETA' ;
 'SINON' ;
    THETA = 0.0 ;
 'FINSI' ;

 'SI' ((THETA > 1.0) 'OU' (THETA < 0.0)) ;
    'MESSAGE' 'PKON . THETA = ???' ;
    'ERREUR' 21 ;
 'FINSI' ;

 ORDESP = KKONV . 'ORDREESP' ;
 $DOMA = KKONV . 'DOMA' ;

*
**** Si on ne fait pas de l'explicite, on ne peux
*    pas fair de predictor correcteur
*

 'SI' (LOGEXP 'ET' ('EGA' ORDESP 2)) ;
    'SI' (KKONV . 'PREDCOR') ;
       ORDTPS = 2 ;
    'SINON' ;
       ORDTPS = 1 ;
    'FINSI' ;
 'SINON' ;
    ORDTPS = 1 ;
 'FINSI' ;

 'SI' (('NEG' (KKONV . 'ALPHA') 'INF') 'ET'
    ('NEG' ('TYPE' (KKONV . 'ALPHA')) FLOTTANT)) ;
    'MESSAGE' 'PKON . ALPHA = ???' ;
    'ERREUR' 21 ;
 'FINSI' ;

 UN = 'REDU' (RV . 'UN') ($DOMA . 'CENTRE') ;

 'SI' ('EGA' (KKONV . 'GAZ') 'PERFMONO') ;

***************************************************************************
******** EULER, monoespece, "calorically perfect" (cv = constant) *********
***************************************************************************

*
**** Type de jacobien
*
    'SI' LOGIMP ;

    ITJACO = 0 ;

    'SI' ('EGA' (KKONV . 'TYPEJACO') 'CENJACO1') ;
       ITJACO = 4 ;
    'FINSI' ;

    'SI' ('EGA' (KKONV . 'TYPEJACO') 'VLHJACO1') ;
       ITJACO = 1 ;
    'FINSI' ;

    'SI' ('EGA' (KKONV . 'TYPEJACO') 'VLHJACO2') ;
       ITJACO = -1 ;
    'FINSI' ;

    'SI' ('EGA' (KKONV . 'TYPEJACO') 'AUSMJAC1') ;
       ITJACO = 2 ;
    'FINSI' ;

    'SI' ('EGA' (KKONV . 'TYPEJACO') 'AUSMJAC2') ;
       ITJACO = -2 ;
    'FINSI' ;

    'SI' ('EGA' (KKONV . 'TYPEJACO') 'AUSMLMJ1') ;
       ITJACO = 3 ;
    'FINSI' ;

    'SI' (ITJACO 'EGA' 0) ;
       'MESSAGE' 'KKONV . TYPEJACO ???' ;
       'ERREUR' 21 ;
    'FINSI' ;

    'SI' ((ITJACO '<' 0) 'ET' (ORDESP 'EGA' 1)) ;
       'MESSAGE' 'KKONV . ORDREESP ???' ;
       'MESSAGE' 'KKONV . TYPEJACO ???' ;
       'ERREUR' 21 ;
    'FINSI' ;

    'FINSI' ;

*
***** Les variables conservatives
*

    MOT1 = 'EXTRAIRE' (KKONV . 'LISTINCO') 1 ;

    'SI' ('EGA' ('VALE' DIME) 2) ;
       LMOT1 = 'EXTRAIRE' (KKONV . 'LISTINCO')
         ('LECT' 2 3 ) ;
       LMOT2 = 'MOTS' 'UX' 'UY' ;
       MOT2 = 'EXTRAIRE' (KKONV . 'LISTINCO') 4 ;
    'SINON' ;
       LMOT1 = 'EXTRAIRE' (KKONV . 'LISTINCO')
         ('LECT' 2 3 4) ;
       LMOT2 = 'MOTS' 'UX' 'UY' 'UZ' ;
       MOT2 = 'EXTRAIRE' (KKONV . 'LISTINCO') 5 ;
    'FINSI' ;

    RN = 'EXCO' MOT1 UN ;
    GN = 'EXCO' LMOT1 UN LMOT2 ;
    RETN = 'EXCO' MOT2 UN ;

*
***** On calcule les variables primitive
*

    GAMN = 'COPIER' (KKONV . 'GAMN') ;
    VN PN = 'PRIM' 'PERFMONO' RN GN RETN GAMN ;

*
***** On calcule les variables aux faces
*

    'SI'  (ORDESP 'EGA'  1) ;

*
********* Ordre 1 en espace
*

       ROF VITF PF GAMF  =  'PRET' 'PERFMONO' ORDESP ORDTPS $DOMA
                          RN VN PN GAMN ;

    'SINON' ;

*
********* Ordre 2 en espace
*

       GRADR ALR = 'PENT' $DOMA 'CENTRE' 'EULESCAL' (KKONV . 'LIMITEUR')
                RN  'GRADGEO' (KKONV . 'GRADRN') ;

       GRADP ALP = 'PENT' $DOMA 'CENTRE' 'EULESCAL' (KKONV . 'LIMITEUR')
                PN  'GRADGEO' (KKONV . 'GRADPN') ;

       GRADV ALV = 'PENT' $DOMA 'CENTRE' 'EULEVECT' (KKONV . 'LIMITEUR')
                VN  'CLIM' (KKONV . 'VLIM')
                'GRADGEO' (KKONV . 'GRADVN')  ;

       'SI' ('EXISTE' RV 'MAIFAN') ;

          ALRLEV =  ('REDU' ALR (RV  . 'MAIFAN')) ;
          ALPLEV =  ('REDU' ALP (RV  . 'MAIFAN')) ;
          ALVLEV =  ('REDU' ALV (RV  . 'MAIFAN')) ;

          CELL = ALR ;
          ALR = ALR '-' ALRLEV ;
          'DETR' CELL ;

          CELL = ALP ;
          ALP = ALP '-' ALPLEV ;
          'DETR' CELL ;

          CELL = ALV ;
          ALV = ALV '-' ALVLEV ;
          'DETR' CELL ;

       'FINSI' ;

       'SI' (ORDTPS 'EGA' 1);

*
********* Ordre 1 en temps
*

          ROF VITF PF GAMF   =  'PRET' 'PERFMONO'  ORDESP ORDTPS
                              $DOMA
                              RN  GRADR  ALR
                              VN  GRADV  ALV
                              PN  GRADP  ALP
                              GAMN ;
       'SINON' ;

*
********* Ordre 2 en temps (en explicite)
*

          DELTAM1 = (RV . 'PASDETPS' . 'TPS') '-'
             (RV . 'PASDETPS' . 'TPSM') ;

          ROF VITF PF GAMF   =  'PRET' 'PERFMONO'  ORDESP ORDTPS
                              $DOMA
                              RN  GRADR ALR
                              VN  GRADV ALV
                              PN  GRADP ALP
                              GAMN
                             (DELTAM1 '/' 2.0);
       'FINSI' ;

    'FINSI'  ;

    'SI' LOGIMP ;
       'SI' (ITJACO '>' 0) ;
          JACO RESIDU DELTAT =  'KONV' 'VF' 'PERFMONO' 'RESI' METO
              (KKONV . 'LISTINCO')
               $DOMA ROF VITF PF GAMF
               (KKONV . 'FACELIM') KKONV . 'UINF' KKONV . 'UPRI'
               (KKONV . 'TYPEJACO') RN VN PN GAMN
*               (KKONV . 'FACELIM')
               ;
*        'MESSAGE' ('CHAINE' 'zdes') ;
       'SINON' ;
          JACO RESIDU DELTAT =  'KONV' 'VF' 'PERFMONO' 'RESI' METO
              (KKONV . 'LISTINCO')
               $DOMA ROF VITF PF GAMF
               (KKONV . 'TYPEJACO') RN VN PN GAMN
               GRADR  GRADV  GRADP
               ALR ALV ALP
               (KKONV . 'GRADRN') (KKONV . 'GRADVN') (KKONV . 'GRADPN')
               (KKONV . 'VLIM')
               (KKONV . 'FACELIM')
               ;
       'FINSI' ;
    'SINON' ;
       JACO RESIDU DELTAT =  'KONV' 'VF' 'PERFMONO' 'RESI' METO
            (KKONV . 'LISTINCO')
            $DOMA ROF VITF PF GAMF
            (KKONV . 'FACELIM')
            ;
    'FINSI' ;

*
**** On detrui les choses qui ne servent plus
*
    'DETR' UN ;
    'OUBL' UN ;
    'DETR' RN ;
    'DETR' GN ;
    'DETR' RETN ;
    'DETR' VN ;
    'DETR' PN ;
    'OUBL' RN ;
    'OUBL' GN ;
    'OUBL' RETN ;
    'OUBL'  VN ;
    'OUBL' PN ;

*
**** Les MCHAML faces
*

    'DETR' ROF ;
    'DETR' VITF ;
    'DETR' PF ;
    'DETR' GAMF ;
    'OUBL' ROF ;
    'OUBL' VITF ;
    'OUBL' PF ;
    'OUBL' GAMF ;

*
**** Les pentes et les limiteurs
*

    'SI' (ORDESP 'EGA' 2);

       'DETR' GRADR ;
       'DETR' GRADP ;
       'DETR' GRADV ;
       'DETR' ALR ;
       'DETR' ALP ;
       'DETR' ALV;

       'OUBL' GRADR ;
       'OUBL' GRADP ;
       'OUBL' GRADV ;
       'OUBL' ALR ;
       'OUBL' ALP ;
       'OUBL' ALV;

    'FINSI' ;

 'FINSI' ;

 'SI' ('EGA' (KKONV . 'GAZ') 'PERFMULT') ;

****************************************************************************
******** EULER, multiespece, "calorically perfect" (cv = constant) *********
****************************************************************************

    IPGAZ = KKONV . 'PGAZ' ;
    NESP = 'DIME' (IPGAZ . 'ESPEULE') ;

*
***** Les variables conservatives
*

    MOT1 = 'EXTRAIRE' (KKONV . 'LISTINCO') 1 ;
    IDIM = 'VALE' 'DIME' ;

    'SI' ('EGA' IDIM 2) ;
       LMOT1 = 'EXTRAIRE' (KKONV . 'LISTINCO')
         ('LECT' 2 3 ) ;
       LMOT2 = 'MOTS' 'UX' 'UY' ;
       MOT2 = 'EXTRAIRE' (KKONV . 'LISTINCO') 4 ;
    'SINON' ;
       LMOT1 = 'EXTRAIRE' (KKONV . 'LISTINCO')
         ('LECT' 2 3 4) ;
       LMOT2 = 'MOTS' 'UX' 'UY' 'UZ' ;
       MOT2 = 'EXTRAIRE' (KKONV . 'LISTINCO') 5 ;
    'FINSI' ;
    LMOT3 = 'EXTRAIRE' (KKONV . 'LISTINCO')
        ('LECT' (IDIM '+' 3) 'PAS' 1 (IDIM '+' 2 '+' NESP)) ;

    RN = 'EXCO' MOT1 UN ;
    GN = 'EXCO' LMOT1 UN LMOT2 ;
    RETN = 'EXCO' MOT2 UN ;
    RYN = 'EXCO' LMOT3 UN (IPGAZ . 'ESPEULE') ;

*
***** On calcule les variables primitive
*

    VN PN TN YN GAMN =  'PRIM' 'PERFMULT' IPGAZ
       RN GN RETN RYN ;

*
***** On calcule les variables aux faces
*

    'SI'  (ORDESP 'EGA'  1) ;

*
********* Ordre 1 en espace
*

      ROF VITF PF YF GAMF  =       'PRET' 'PERFMULT'
         1  1 $DOMA RN VN PN YN GAMN ;

    'SINON' ;

*
********* Ordre 2 en espace
*

       GRADR ALR = 'PENT' $DOMA 'CENTRE' 'EULESCAL' (KKONV . 'LIMITEUR')
                RN  'GRADGEO' (KKONV . 'GRADRN') ;

       GRADP ALP = 'PENT' $DOMA 'CENTRE' 'EULESCAL' (KKONV . 'LIMITEUR')
                PN  'GRADGEO' (KKONV . 'GRADPN') ;

       GRADV ALV = 'PENT' $DOMA 'CENTRE' 'EULEVECT' (KKONV . 'LIMITEUR')
                VN  'CLIM' (KKONV . 'VLIM')
                'GRADGEO' (KKONV . 'GRADVN')  ;

       GRADY ALY = 'PENT' $DOMA 'CENTRE' 'EULESCAL' (KKONV . 'LIMITEUR')
                YN  'GRADGEO' (KKONV . 'GRADYN')  ;

       'SI' ('EXISTE' RV 'MAIFAN') ;

          ALRLEV =  ('REDU' ALR (RV  . 'MAIFAN')) ;
          ALPLEV =  ('REDU' ALP (RV  . 'MAIFAN')) ;
          ALVLEV =  ('REDU' ALV (RV  . 'MAIFAN')) ;
          ALYLEV =  ('REDU' ALY (RV  . 'MAIFAN')) ;

          CELL = ALR ;
          ALR = ALR '-' ALRLEV ;
          'DETR' CELL ;

          CELL = ALP ;
          ALP = ALP '-' ALPLEV ;
          'DETR' CELL ;

          CELL = ALV ;
          ALV = ALV '-' ALVLEV ;
          'DETR' CELL ;

          CELL = ALY ;
          ALY = ALY '-' ALYLEV ;
          'DETR' CELL ;

       'FINSI' ;

       'SI' (ORDTPS 'EGA' 1);

*
********* Ordre 1 en temps
*

          ROF VITF PF YF GAMF   =  'PRET' 'PERFMULT'  ORDESP ORDTPS
                              $DOMA IPGAZ
                              RN  GRADR  ALR
                              VN  GRADV  ALV
                              PN  GRADP  ALP
                              YN  GRADY  ALY
                              GAMN ;
       'SINON' ;

*
********* Ordre 2 en temps (en explicite)
*

          DELTAM1 = (RV . 'PASDETPS' . 'TPS') '-'
             (RV . 'PASDETPS' . 'TPSM') ;

          ROF VITF PF YF GAMF   =  'PRET' 'PERFMULT'  ORDESP ORDTPS
                              $DOMA IPGAZ
                              RN  GRADR ALR
                              VN  GRADV ALV
                              PN  GRADP ALP
                              YN  GRADY  ALY
                              GAMN
                             (DELTAM1 '/' 2.0);
       'FINSI' ;

    'FINSI'  ;

    'SI' LOGIMP ;
       JACO RESIDU DELTAT =  'KONV' 'VF' 'PERFMULT' 'RESI' METO
            (KKONV . 'LISTINCO')
            $DOMA ROF VITF PF GAMF YF IPGAZ
            (KKONV . 'TYPEJACO') RN VN PN GAMN IYN ;
    'SINON' ;
       JACO RESIDU DELTAT =  'KONV' 'VF' 'PERFMULT' 'RESI' METO
            (KKONV . 'LISTINCO')
            $DOMA ROF VITF PF GAMF YF IPGAZ ;
    'FINSI' ;

*
**** On detrui les choses qui ne servent plus
*
    'DETR' UN ;
    'OUBL' UN ;
    'DETR' RN ;
    'DETR' GN ;
    'DETR' RETN ;
    'DETR' VN ;
    'DETR' PN ;
    'DETR' YN ;
    'DETR' RYN ;
    'DETR' TN ;
    'DETR' GAMN ;
    'OUBL' RN ;
    'OUBL' GN ;
    'OUBL' RETN ;
    'OUBL' VN ;
    'OUBL' PN ;
    'OUBL' YN ;
    'OUBL' RYN ;
    'OUBL' TN ;
    'OUBL' GAMN ;

*
**** Les MCHAML faces
*

    'DETR' ROF ;
    'DETR' VITF ;
    'DETR' PF ;
    'DETR' GAMF ;
    'DETR' YF ;
    'OUBL' ROF ;
    'OUBL' VITF ;
    'OUBL' PF ;
    'OUBL' GAMF ;
    'OUBL' YF ;

*
**** Les pentes et les limiteurs
*

    'SI' (ORDESP 'EGA' 2);

       'DETR' GRADR ;
       'DETR' GRADP ;
       'DETR' GRADV ;
       'DETR' GRADY ;
       'DETR' ALR ;
       'DETR' ALP ;
       'DETR' ALV;
       'DETR' ALY;

       'OUBL' GRADR ;
       'OUBL' GRADP ;
       'OUBL' GRADV ;
       'OUBL' GRADY ;
       'OUBL' ALR ;
       'OUBL' ALP ;
       'OUBL' ALV;
       'OUBL' ALY;

    'FINSI' ;

 'FINSI' ;


 'SI' ('EGA' (KKONV . 'GAZ') 'PERFTEMP') ;

***************************************************************************
********           EULER, "thermally perfect"                     *********
***************************************************************************

    PGAZ = KKONV . 'PGAZ' ;

    'SI' ('EXISTE' PGAZ 'ESPEULE') ;
       NESP = 'DIME' (PGAZ . 'ESPEULE') ;
       LOGESP = VRAI ;
    'SINON' ;
       NESP = 0 ;
       LOGESP = FAUX ;
    'FINSI' ;

    'SI' ('EXISTE' PGAZ 'SCALPASS') ;
       NSCA = 'DIME' (PGAZ . 'SCALPASS') ;
       LOGSCA = VRAI ;
    'SINON' ;
       NSCA = 0 ;
       LOGSCA = FAUX ;
    'FINSI' ;

*
*** Quatre cas differents
*
*   a) LOGESP 'ET' LOGSCA
*   b) LOGESP 'ET' ('NON' LOGSCA)
*   c) ('NON' LOGESP) 'ET' ('NON' LOGSCA)
*   d) ('NON' LOGESP) 'ET' LOGSCA
*

*   a) LOGESP 'ET' LOGSCA

    'SI' (LOGESP 'ET' LOGSCA) ;

       MOT1 = 'EXTRAIRE' (KKONV . 'LISTINCO') 1 ;
       NDIM = 'VALE' 'DIME' ;
       'SI' ('EGA' NDIM 2) ;
          LMOT1 = 'EXTRAIRE' (KKONV . 'LISTINCO')
            ('LECT' 2 3 ) ;
          LMOT2 = 'MOTS' 'UX' 'UY' ;
          MOT2 = 'EXTRAIRE' (KKONV . 'LISTINCO') 4 ;
       'SINON' ;
          LMOT1 = 'EXTRAIRE' (KKONV . 'LISTINCO')
         ('LECT' 2 3 4) ;
          LMOT2 = 'MOTS' 'UX' 'UY' 'UZ' ;
          MOT2 = 'EXTRAIRE' (KKONV . 'LISTINCO') 5 ;
       'FINSI' ;
        LMOT3 = 'EXTRAIRE' (KKONV . 'LISTINCO')
             ('LECT' (3+NDIM) 'PAS' 1 'NPAS' (NESP '-' 1)) ;
        LMOT4 = (PGAZ . 'ESPEULE') ;
        LMOT5 = 'EXTRAIRE' (KKONV . 'LISTINCO')
             ('LECT' (3+NDIM+NESP) 'PAS' 1 'NPAS'
              (NSCA '-' 1)) ;
        LMOT6 = (PGAZ . 'SCALPASS') ;

        RN = 'EXCO' MOT1 UN ;
        GN = 'EXCO' LMOT1 UN LMOT2 ;
        RETN = 'EXCO' MOT2 UN ;
        RYN = 'EXCO' LMOT3 UN LMOT4 ;
        RSN = 'EXCO' LMOT5 UN LMOT6 ;

*
***** On calcule les variables primitive
*

        VN PN TN YN SN GAMN = 'PRIM' 'PERFTEMP'
           PGAZ RN GN RETN RYN RSN ;

*
***** On calcule les variables aux faces
*

        'SI'  (ORDESP 'EGA'  1) ;

*
********* Ordre 1 en espace
*

           ROF VITF PF YF SF =  'PRET' 'PERFTEMP' ORDESP ORDTPS $DOMA
                          PGAZ RN VN PN YN SN ;

        'SINON' ;

*
********* Ordre 2 en espace
*

           GRADR ALR = 'PENT' $DOMA 'CENTRE' 'EULESCAL'
                (KKONV . 'LIMITEUR') RN  'GRADGEO' (KKONV . 'GRADRN') ;

           GRADP ALP = 'PENT' $DOMA 'CENTRE' 'EULESCAL'
                (KKONV . 'LIMITEUR') PN  'GRADGEO' (KKONV . 'GRADPN') ;

           GRADV ALV = 'PENT' $DOMA 'CENTRE' 'EULEVECT'
                (KKONV . 'LIMITEUR') VN  'CLIM' (KKONV . 'VLIM')
                'GRADGEO' (KKONV . 'GRADVN')  ;

           GRADY ALY = 'PENT' $DOMA 'CENTRE' 'EULESCAL'
               (KKONV . 'LIMITEUR') YN  'GRADGEO' (KKONV . 'GRADYN') ;

           GRADS ALS = 'PENT' $DOMA 'CENTRE' 'EULESCAL'
                (KKONV . 'LIMITEUR') SN  'GRADGEO' (KKONV . 'GRADSN') ;

           'SI' ('EXISTE' RV 'MAIFAN') ;

              ALRLEV =  ('REDU' ALR (RV  . 'MAIFAN')) ;
              ALPLEV =  ('REDU' ALP (RV  . 'MAIFAN')) ;
              ALVLEV =  ('REDU' ALV (RV  . 'MAIFAN')) ;
              ALYLEV =  ('REDU' ALY (RV  . 'MAIFAN')) ;
              ALSLEV =  ('REDU' ALS (RV  . 'MAIFAN')) ;

              CELL = ALR ;
              ALR = ALR '-' ALRLEV ;
              'DETR' CELL ;

              CELL = ALP ;
              ALP = ALP '-' ALPLEV ;
              'DETR' CELL ;

              CELL = ALV ;
              ALV = ALV '-' ALVLEV ;
              'DETR' CELL ;

              CELL = ALY ;
              ALY = ALY '-' ALYLEV ;
              'DETR' CELL ;

              CELL = ALS ;
              ALS = ALS '-' ALSLEV ;
              'DETR' CELL ;

           'FINSI' ;

           'SI' (ORDTPS 'EGA' 1);

*
********* Ordre 1 en temps
*

              ROF VITF PF YF SF =  'PRET' 'PERFTEMP'  ORDESP ORDTPS
                              $DOMA PGAZ
                              RN  GRADR  ALR
                              VN  GRADV  ALV
                              PN  GRADP  ALP
                              YN  GRADY  ALY
                              SN  GRADS  ALS ;

           'SINON' ;

*
********* Ordre 2 en temps (en explicite)
*

              DELTAM1 = (RV . 'PASDETPS' . 'TPS') '-'
                 (RV . 'PASDETPS' . 'TPSM') ;

              ROF VITF PF YF SF   =  'PRET' 'PERFTEMP'  ORDESP ORDTPS
                              $DOMA PGAZ
                              RN  GRADR ALR
                              VN  GRADV ALV
                              PN  GRADP ALP
                              YN  GRADY  ALY
                              SN  GRADS  ALS
                              GAMN (DELTAM1 '/' 2.0);
           'FINSI' ;

        'FINSI'  ;

        'SI' LOGIMP ;
           'ERREUR' 21 ;
        'SINON' ;
           JACO RESIDU DELTAT =  'KONV' 'VF' 'PERFTEMP' 'RESI' METO
               $DOMA PGAZ (KKONV . 'LISTINCO')  ROF VITF PF YF SF ;
        'FINSI' ;


*
**** On detrui les choses qui ne servent plus
*

        'DETR' UN ;
        'OUBL' UN ;

        'DETR' RN ;
        'DETR' GN ;
        'DETR' RETN ;
        'DETR' RYN ;
        'DETR' RSN ;
        'DETR' VN ;
        'DETR' PN ;
        'DETR' YN ;
        'DETR' SN ;
        'DETR' GAMN ;

        'OUBL' RN ;
        'OUBL' GN ;
        'OUBL' RETN ;
        'OUBL' RYN ;
        'OUBL' RSN ;
        'OUBL' VN ;
        'OUBL' PN ;
        'OUBL' YN ;
        'OUBL' SN ;
        'OUBL' GAMN ;

*
**** Les MCHAML faces
*

        'DETR' ROF ;
        'DETR' VITF ;
        'DETR' PF ;
        'DETR' YF ;
        'DETR' SF ;

        'OUBL' ROF ;
        'OUBL' VITF ;
        'OUBL' PF ;
        'OUBL' YF ;
        'OUBL' SF ;

*
**** Les pentes et les limiteurs
*

        'SI' (ORDESP 'EGA' 2);

           'DETR' GRADR ;
           'DETR' GRADP ;
           'DETR' GRADV ;
           'DETR' GRADY ;
           'DETR' GRADS ;
           'DETR' ALR ;
           'DETR' ALP ;
           'DETR' ALV ;
           'DETR' ALY ;
           'DETR' ALS ;

           'OUBL' GRADR ;
           'OUBL' GRADP ;
           'OUBL' GRADV ;
           'OUBL' GRADY ;
           'OUBL' GRADS ;
           'OUBL' ALR ;
           'OUBL' ALP ;
           'OUBL' ALV;
           'OUBL' ALY ;
           'OUBL' ALS ;

        'FINSI' ;

     'FINSI' ;

*   b) LOGESP 'ET' ('NON' LOGSCA)


    'SI' (LOGESP 'ET' ('NON' LOGSCA)) ;

       MOT1 = 'EXTRAIRE' (KKONV . 'LISTINCO') 1 ;
       NDIM = 'VALE' 'DIME' ;
       'SI' ('EGA' NDIM 2) ;
          LMOT1 = 'EXTRAIRE' (KKONV . 'LISTINCO')
            ('LECT' 2 3 ) ;
          LMOT2 = 'MOTS' 'UX' 'UY' ;
          MOT2 = 'EXTRAIRE' (KKONV . 'LISTINCO') 4 ;
       'SINON' ;
          LMOT1 = 'EXTRAIRE' (KKONV . 'LISTINCO')
         ('LECT' 2 3 4) ;
          LMOT2 = 'MOTS' 'UX' 'UY' 'UZ' ;
          MOT2 = 'EXTRAIRE' (KKONV . 'LISTINCO') 5 ;
       'FINSI' ;
        LMOT3 = 'EXTRAIRE' (KKONV . 'LISTINCO')
             ('LECT' (3+NDIM) 'PAS' 1 'NPAS' (NESP '-' 1)) ;
        LMOT4 = (PGAZ . 'ESPEULE') ;

        RN = 'EXCO' MOT1 UN ;
        GN = 'EXCO' LMOT1 UN LMOT2 ;
        RETN = 'EXCO' MOT2 UN ;
        RYN = 'EXCO' LMOT3 UN LMOT4 ;

*
***** On calcule les variables primitive
*

        VN PN TN YN GAMN = 'PRIM' 'PERFTEMP'
           PGAZ RN GN RETN RYN ;

*
***** On calcule les variables aux faces
*

        'SI'  (ORDESP 'EGA'  1) ;

*
********* Ordre 1 en espace
*

           ROF VITF PF YF  =  'PRET' 'PERFTEMP' ORDESP ORDTPS $DOMA
                          PGAZ RN VN PN YN ;

        'SINON' ;

*
********* Ordre 2 en espace
*

           GRADR ALR = 'PENT' $DOMA 'CENTRE' 'EULESCAL'
                (KKONV . 'LIMITEUR') RN  'GRADGEO' (KKONV . 'GRADRN') ;

           GRADP ALP = 'PENT' $DOMA 'CENTRE' 'EULESCAL'
                (KKONV . 'LIMITEUR') PN  'GRADGEO' (KKONV . 'GRADPN') ;

           GRADV ALV = 'PENT' $DOMA 'CENTRE' 'EULEVECT'
                (KKONV . 'LIMITEUR') VN  'CLIM' (KKONV . 'VLIM')
                'GRADGEO' (KKONV . 'GRADVN')  ;

           GRADY ALY = 'PENT' $DOMA 'CENTRE' 'EULESCAL'
                (KKONV . 'LIMITEUR') YN  'GRADGEO' (KKONV . 'GRADYN') ;

           'SI' ('EXISTE' RV 'MAIFAN') ;

              ALRLEV =  ('REDU' ALR (RV  . 'MAIFAN')) ;
              ALPLEV =  ('REDU' ALP (RV  . 'MAIFAN')) ;
              ALVLEV =  ('REDU' ALV (RV  . 'MAIFAN')) ;
              ALYLEV =  ('REDU' ALY (RV  . 'MAIFAN')) ;

              CELL = ALR ;
              ALR = ALR '-' ALRLEV ;
              'DETR' CELL ;

              CELL = ALP ;
              ALP = ALP '-' ALPLEV ;
              'DETR' CELL ;

              CELL = ALV ;
              ALV = ALV '-' ALVLEV ;
              'DETR' CELL ;

              CELL = ALY ;
              ALY = ALY '-' ALYLEV ;
              'DETR' CELL ;

           'FINSI' ;

           'SI' (ORDTPS 'EGA' 1);

*
********* Ordre 1 en temps
*

              ROF VITF PF YF  =  'PRET' 'PERFTEMP'  ORDESP ORDTPS
                              $DOMA PGAZ
                              RN  GRADR  ALR
                              VN  GRADV  ALV
                              PN  GRADP  ALP
                              YN  GRADY  ALY ;

           'SINON' ;

*
********* Ordre 2 en temps (en explicite)
*

              DELTAM1 = (RV . 'PASDETPS' . 'TPS') '-'
                 (RV . 'PASDETPS' . 'TPSM') ;

              ROF VITF PF YF   =  'PRET' 'PERFTEMP'  ORDESP ORDTPS
                              $DOMA PGAZ
                              RN  GRADR ALR
                              VN  GRADV ALV
                              PN  GRADP ALP
                              YN  GRADY  ALY
                              GAMN (DELTAM1 '/' 2.0);
           'FINSI' ;

        'FINSI'  ;

        'SI' LOGIMP ;
           'ERREUR' 21 ;
        'SINON' ;
           JACO RESIDU DELTAT =  'KONV' 'VF' 'PERFTEMP' 'RESI' METO
               $DOMA PGAZ (KKONV . 'LISTINCO')  ROF VITF PF YF ;
        'FINSI' ;


*
**** On detrui les choses qui ne servent plus
*

        'DETR' UN ;
        'OUBL' UN ;

        'DETR' RN ;
        'DETR' GN ;
        'DETR' RETN ;
        'DETR' RYN ;
        'DETR' VN ;
        'DETR' PN ;
        'DETR' YN ;
        'DETR' GAMN ;

        'OUBL' RN ;
        'OUBL' GN ;
        'OUBL' RETN ;
        'OUBL' RYN ;
        'OUBL' VN ;
        'OUBL' PN ;
        'OUBL' YN ;
        'OUBL' GAMN ;

*
**** Les MCHAML faces
*

        'DETR' ROF ;
        'DETR' VITF ;
        'DETR' PF ;
        'DETR' YF ;

        'OUBL' ROF ;
        'OUBL' VITF ;
        'OUBL' PF ;
        'OUBL' YF ;

*
**** Les pentes et les limiteurs
*

        'SI' (ORDESP 'EGA' 2);

           'DETR' GRADR ;
           'DETR' GRADP ;
           'DETR' GRADV ;
           'DETR' GRADY ;
           'DETR' ALR ;
           'DETR' ALP ;
           'DETR' ALV ;
           'DETR' ALY ;

           'OUBL' GRADR ;
           'OUBL' GRADP ;
           'OUBL' GRADV ;
           'OUBL' GRADY ;
           'OUBL' ALR ;
           'OUBL' ALP ;
           'OUBL' ALV;
           'OUBL' ALY ;

        'FINSI' ;

     'FINSI' ;



*   c) ('NON' LOGESP) 'ET' ('NON' LOGSCA)


    'MESSAGE' ;
    'MESSAGE' 'Ciao' ;

    'SI' (('NON' LOGESP) 'ET' ('NON' LOGSCA)) ;

       MOT1 = 'EXTRAIRE' (KKONV . 'LISTINCO') 1 ;
       NDIM = 'VALE' 'DIME' ;
       'SI' ('EGA' NDIM 2) ;
          LMOT1 = 'EXTRAIRE' (KKONV . 'LISTINCO')
            ('LECT' 2 3 ) ;
          LMOT2 = 'MOTS' 'UX' 'UY' ;
          MOT2 = 'EXTRAIRE' (KKONV . 'LISTINCO') 4 ;
       'SINON' ;
          LMOT1 = 'EXTRAIRE' (KKONV . 'LISTINCO')
         ('LECT' 2 3 4) ;
          LMOT2 = 'MOTS' 'UX' 'UY' 'UZ' ;
          MOT2 = 'EXTRAIRE' (KKONV . 'LISTINCO') 5 ;
       'FINSI' ;

        RN = 'EXCO' MOT1 UN ;
        GN = 'EXCO' LMOT1 UN LMOT2 ;
        RETN = 'EXCO' MOT2 UN ;

*
***** On calcule les variables primitive
*

        VN PN TN  GAMN = 'PRIM' 'PERFTEMP'
           PGAZ RN GN RETN  ;

*
***** On calcule les variables aux faces
*

        'SI'  (ORDESP 'EGA'  1) ;

*
********* Ordre 1 en espace
*

           ROF VITF PF  =  'PRET' 'PERFTEMP' ORDESP ORDTPS $DOMA
                          PGAZ RN VN PN ;

        'SINON' ;

*
********* Ordre 2 en espace
*

           GRADR ALR = 'PENT' $DOMA 'CENTRE' 'EULESCAL'
                (KKONV . 'LIMITEUR') RN  'GRADGEO' (KKONV . 'GRADRN') ;

           GRADP ALP = 'PENT' $DOMA 'CENTRE' 'EULESCAL'
                (KKONV . 'LIMITEUR') PN  'GRADGEO' (KKONV . 'GRADPN') ;

           GRADV ALV = 'PENT' $DOMA 'CENTRE' 'EULEVECT'
                (KKONV . 'LIMITEUR') VN  'CLIM' (KKONV . 'VLIM')
                'GRADGEO' (KKONV . 'GRADVN')  ;

           'SI' ('EXISTE' RV 'MAIFAN') ;

              ALRLEV =  ('REDU' ALR (RV  . 'MAIFAN')) ;
              ALPLEV =  ('REDU' ALP (RV  . 'MAIFAN')) ;
              ALVLEV =  ('REDU' ALV (RV  . 'MAIFAN')) ;

              CELL = ALR ;
              ALR = ALR '-' ALRLEV ;
              'DETR' CELL ;

              CELL = ALP ;
              ALP = ALP '-' ALPLEV ;
              'DETR' CELL ;

              CELL = ALV ;
              ALV = ALV '-' ALVLEV ;
              'DETR' CELL ;

           'FINSI' ;

           'SI' (ORDTPS 'EGA' 1);

*
********* Ordre 1 en temps
*

              ROF VITF PF  =  'PRET' 'PERFTEMP'  ORDESP ORDTPS
                              $DOMA PGAZ
                              RN  GRADR  ALR
                              VN  GRADV  ALV
                              PN  GRADP  ALP ;

           'SINON' ;

*
********* Ordre 2 en temps (en explicite)
*

              DELTAM1 = (RV . 'PASDETPS' . 'TPS') '-'
                 (RV . 'PASDETPS' . 'TPSM') ;

              ROF VITF PF   =  'PRET' 'PERFTEMP'  ORDESP ORDTPS
                              $DOMA PGAZ
                              RN  GRADR ALR
                              VN  GRADV ALV
                              PN  GRADP ALP
                              GAMN (DELTAM1 '/' 2.0);
           'FINSI' ;

        'FINSI'  ;

        'SI' LOGIMP ;
           'ERREUR' 21 ;
        'SINON' ;
           JACO RESIDU DELTAT =  'KONV' 'VF' 'PERFTEMP' 'RESI' METO
               $DOMA PGAZ (KKONV . 'LISTINCO')  ROF VITF PF  ;
        'FINSI' ;


*
**** On detrui les choses qui ne servent plus
*

        'DETR' UN ;
        'OUBL' UN ;

        'DETR' RN ;
        'DETR' GN ;
        'DETR' RETN ;
        'DETR' VN ;
        'DETR' PN ;
        'DETR' GAMN ;

        'OUBL' RN ;
        'OUBL' GN ;
        'OUBL' RETN ;
        'OUBL' VN ;
        'OUBL' PN ;
        'OUBL' GAMN ;

*
**** Les MCHAML faces
*

        'DETR' ROF ;
        'DETR' VITF ;
        'DETR' PF ;

        'OUBL' ROF ;
        'OUBL' VITF ;
        'OUBL' PF ;

*
**** Les pentes et les limiteurs
*

        'SI' (ORDESP 'EGA' 2);

           'DETR' GRADR ;
           'DETR' GRADP ;
           'DETR' GRADV ;
           'DETR' ALR ;
           'DETR' ALP ;
           'DETR' ALV ;

           'OUBL' GRADR ;
           'OUBL' GRADP ;
           'OUBL' GRADV ;
           'OUBL' GRADY ;
           'OUBL' ALR ;
           'OUBL' ALP ;
           'OUBL' ALV;

        'FINSI' ;

     'FINSI' ;


*   d) ('NON' LOGESP) 'ET' LOGSCA

    'SI' (('NON' LOGESP) 'ET' LOGSCA) ;

       MOT1 = 'EXTRAIRE' (KKONV . 'LISTINCO') 1 ;
       NDIM = 'VALE' 'DIME' ;
       'SI' ('EGA' NDIM 2) ;
          LMOT1 = 'EXTRAIRE' (KKONV . 'LISTINCO')
            ('LECT' 2 3 ) ;
          LMOT2 = 'MOTS' 'UX' 'UY' ;
          MOT2 = 'EXTRAIRE' (KKONV . 'LISTINCO') 4 ;
       'SINON' ;
          LMOT1 = 'EXTRAIRE' (KKONV . 'LISTINCO')
         ('LECT' 2 3 4) ;
          LMOT2 = 'MOTS' 'UX' 'UY' 'UZ' ;
          MOT2 = 'EXTRAIRE' (KKONV . 'LISTINCO') 5 ;
       'FINSI' ;
        LMOT5 = 'EXTRAIRE' (KKONV . 'LISTINCO')
             ('LECT' (3+NDIM) 'PAS' 1 'NPAS'
              (NSCA '-' 1)) ;
        LMOT6 = (PGAZ . 'SCALPASS') ;

        RN = 'EXCO' MOT1 UN ;
        GN = 'EXCO' LMOT1 UN LMOT2 ;
        RETN = 'EXCO' MOT2 UN ;
        RSN = 'EXCO' LMOT5 UN LMOT6 ;

*
***** On calcule les variables primitive
*

        VN PN TN SN GAMN = 'PRIM' 'PERFTEMP'
           PGAZ RN GN RETN RSN ;

*
***** On calcule les variables aux faces
*

        'SI'  (ORDESP 'EGA'  1) ;

*
********* Ordre 1 en espace
*

           ROF VITF PF SF =  'PRET' 'PERFTEMP' ORDESP ORDTPS $DOMA
                          PGAZ RN VN PN SN ;

        'SINON' ;

*
********* Ordre 2 en espace
*

           GRADR ALR = 'PENT' $DOMA 'CENTRE' 'EULESCAL'
               (KKONV . 'LIMITEUR') RN  'GRADGEO' (KKONV . 'GRADRN') ;

           GRADP ALP = 'PENT' $DOMA 'CENTRE' 'EULESCAL'
               (KKONV . 'LIMITEUR') PN  'GRADGEO' (KKONV . 'GRADPN') ;

           GRADV ALV = 'PENT' $DOMA 'CENTRE' 'EULEVECT'
               (KKONV . 'LIMITEUR') VN  'CLIM' (KKONV . 'VLIM')
                'GRADGEO' (KKONV . 'GRADVN')  ;

           GRADS ALS = 'PENT' $DOMA 'CENTRE' 'EULESCAL'
               (KKONV . 'LIMITEUR') SN  'GRADGEO' (KKONV . 'GRADSN') ;

           'SI' ('EXISTE' RV 'MAIFAN') ;

              ALRLEV =  ('REDU' ALR (RV  . 'MAIFAN')) ;
              ALPLEV =  ('REDU' ALP (RV  . 'MAIFAN')) ;
              ALVLEV =  ('REDU' ALV (RV  . 'MAIFAN')) ;
              ALSLEV =  ('REDU' ALS (RV  . 'MAIFAN')) ;

              CELL = ALR ;
              ALR = ALR '-' ALRLEV ;
              'DETR' CELL ;

              CELL = ALP ;
              ALP = ALP '-' ALPLEV ;
              'DETR' CELL ;

              CELL = ALV ;
              ALV = ALV '-' ALVLEV ;
              'DETR' CELL ;

              CELL = ALS ;
              ALS = ALS '-' ALSLEV ;
              'DETR' CELL ;

           'FINSI' ;

           'SI' (ORDTPS 'EGA' 1);

*
********* Ordre 1 en temps
*

              ROF VITF PF SF =  'PRET' 'PERFTEMP'  ORDESP ORDTPS
                              $DOMA PGAZ
                              RN  GRADR  ALR
                              VN  GRADV  ALV
                              PN  GRADP  ALP
                              SN  GRADS  ALS ;

           'SINON' ;

*
********* Ordre 2 en temps (en explicite)
*

              DELTAM1 = (RV . 'PASDETPS' . 'TPS') '-'
                 (RV . 'PASDETPS' . 'TPSM') ;

              ROF VITF PF SF   =  'PRET' 'PERFTEMP'  ORDESP ORDTPS
                              $DOMA PGAZ
                              RN  GRADR ALR
                              VN  GRADV ALV
                              PN  GRADP ALP
                              SN  GRADS  ALS
                              GAMN (DELTAM1 '/' 2.0);
           'FINSI' ;

        'FINSI'  ;

        'SI' LOGIMP ;
           'ERREUR' 21 ;
        'SINON' ;
           JACO RESIDU DELTAT =  'KONV' 'VF' 'PERFTEMP' 'RESI' METO
               $DOMA PGAZ (KKONV . 'LISTINCO')  ROF VITF PF SF ;
        'FINSI' ;


*
**** On detrui les choses qui ne servent plus
*

        'DETR' UN ;
        'OUBL' UN ;

        'DETR' RN ;
        'DETR' GN ;
        'DETR' RETN ;
        'DETR' RSN ;
        'DETR' VN ;
        'DETR' PN ;
        'DETR' SN ;
        'DETR' GAMN ;

        'OUBL' RN ;
        'OUBL' GN ;
        'OUBL' RETN ;
        'OUBL' RSN ;
        'OUBL' VN ;
        'OUBL' PN ;
        'OUBL' SN ;
        'OUBL' GAMN ;

*
**** Les MCHAML faces
*

        'DETR' ROF ;
        'DETR' VITF ;
        'DETR' PF ;
        'DETR' SF ;

        'OUBL' ROF ;
        'OUBL' VITF ;
        'OUBL' PF ;
        'OUBL' SF ;

*
**** Les pentes et les limiteurs
*

        'SI' (ORDESP 'EGA' 2);

           'DETR' GRADR ;
           'DETR' GRADP ;
           'DETR' GRADV ;
           'DETR' GRADS ;
           'DETR' ALR ;
           'DETR' ALP ;
           'DETR' ALV ;
           'DETR' ALS ;

           'OUBL' GRADR ;
           'OUBL' GRADP ;
           'OUBL' GRADV ;
           'OUBL' GRADS ;
           'OUBL' ALR ;
           'OUBL' ALP ;
           'OUBL' ALV;
           'OUBL' ALS ;

        'FINSI' ;

     'FINSI' ;

 'FINSI' ;

 'SI' ('EGA' ('TYPE' (KKONV . 'ALPHA')) FLOTTANT) ;
    ALPDT = 'PROG' ((KKONV . 'ALPHA') '*' DELTAT) ;
 'SINON' ;
    ALPDT = 'PROG' ;
 'FINSI' ;

 KKONV . 'DT' = DELTAT ;

 'FINPROC' JACO RESIDU ALPDT THETA  ;


*****************************************************
*****************************************************
** FIN PROCEDURE PKON                              **
*****************************************************
*****************************************************



*****************************************************
*****************************************************
***** PROCEDURE PROLIM                          *****
*****************************************************
*****************************************************
*
*
**** Cas Euler mono-espèce
*

 'DEBPROC'  PROLIM ;
 'ARGUMENT'  RV * TABLE ;

 UN =  RV . 'UN' ;
 UNLIM =  RV . 'UNLIM' ;
 MAILLIM = 'EXTRAIRE' UNLIM 'MAILLAGE' ;
 UNLEV = 'REDU' UN MAILLIM '*' (-1.0) ;

 UN = UN '+' UNLEV '+' UNLIM ;

 'FINPROC' UN ;


*****************************************************
*****************************************************
***** FIN PROCEDURE PROLIM                      *****
*****************************************************
*****************************************************

*********************************************************************
**** Procedure CALC *************************************************
*********************************************************************
*
* Cette procédure, utilisée comme un opérateur, calcule la différence
* entre deux pas de temps toutes les (RVX . 'FCALC')  itérations.
* L'evolution de cette différence (erreur absolue) au cours du temps
* est conservée en vue d'un post-traitement.
*
*
 'DEBP' CALC ;
 'ARGU' RVX*'TABLE' ;
*
 RV  = RVX . 'EQEX' ;
 UN = RV . 'UN' ;
 RN = 'EXCO' UN 'RN' ;
 RUX = 'EXCO' UN 'RUX' ;
 RUY = 'EXCO' UN 'RUY' ;
 MOMSQ = (RUX '*' RUX) '+' (RUY '*' RUY) ;
 MOM = MOMSQ '**' 0.5 ;
*
 'SI' ( 'EXIS' RVX 'COMPT') ;
    RVX . 'COMPT' = RVX . 'COMPT' + 1 ;
 'SINON' ;
    RVX . 'COMPT' = 1 ;
    RVX . 'IT'   = 'PROG' ;
    RVX . 'TPS'  = 'PROG' ;
    RVX . 'ER'   = 'PROG' ;
    RVX . 'RN0'  = 'COPI' RN ;
 'FINSI' ;
*******************************************
 DD = RVX . 'COMPT' ;
 COMBIEN = RVX . 'FCALC' ;
 NN = DD '/'  COMBIEN ;
 LO = (DD '-' (COMBIEN '*' NN)) 'EGA' 0 ;
 'SI' LO ;
    ERR    = MOM '-' (RVX . 'RN0') ;
    RVX . 'RN0' = 'COPI' MOM ;
    ERRINF = 'MAXI' ERR 'ABS' ;
    ELI    = ('LOG' (ERRINF + 1.0E-50))/('LOG' 10.) ;
   'MESSAGE' ;
   'MESSAGE' 'Erreur de convergence' ;
   'MESS' 'ITERATION ' (RVX . 'COMPT') '   LOG10 ERREUR ' ELI ;
   'MESSAGE' ;
    IT = 'PROG' RVX . 'COMPT' ;
    ER = 'PROG' ELI ;
    TPS = 'PROG' (RV . 'PASDETPS' . 'TPS') ;
    RVX . 'IT' = (RVX . 'IT') 'ET' IT ;
    RVX . 'ER' = (RVX . 'ER') 'ET' ER ;
    RVX . 'TPS'  = (RVX . 'TPS') 'ET' TPS ;
 'FINS' ;
 IRESU IJACO ='KOPS' 'MATRIK' ;
 IALPDT = 'PROG' ;
 THETA = 0.0 ;
***************************************************
 RV . 'MATIDE' = 'KOPS' 'MATIDE' ('MOTS' 'RN' 'RUX' 'RUY' 'RETN')
    ($DOMTOT . 'CENTRE') 'MATRIK' ;
***************************************************
*****************************************************************
 LMOT = 'MOTS' 'RN' 'RUX' 'RUY' 'RETN' ;

 RN = 'EXCO' 'RN' (RV . 'UN') ;
 GN = 'EXCO' ('MOTS'  'RUX' 'RUY')  (RV . 'UN') ('MOTS' 'UX' 'UY') ;
 RETN = 'EXCO' 'RETN'   (RV . 'UN') ;
****************
 VN PN =   'PRIM' 'PERFMONO'
           RN GN RETN GAMN ;
***************************************************
 'MENAGE' ;

 'RESPRO' IJACO IRESU IALPDT THETA ;

 'FINP' ;

************************************************************************
************************************************************************
***************** FIN PARTIE PROCEDURES ********************************
************************************************************************
************************************************************************
**********************************************************************
* CALCUL DE L'ECOULEMENT SUBSONIQUE ISENTROPIQUE STATIONNAIRE DANS  *
* UN CANAL  MAILLAGE --------  MAILLAGE -----                                   *-------------------------------------------------------------------
* GRAPH = VRAI ;

******************
**** MAILLAGE ****
******************

 NY = 4 ;
 NX1 = NY ;
 NX2 = 2 '*' NX1 ;
 NX3 = NX1 ;
 NX = NX1 '+' NX2 '+' NX3 ;
 DX = 4.0 '/' NX ;
* NRAFF = 2 ;

 A0 = -2.0 0.0 ;
 A1 = -1.0 0.0 ;
 A2 = 1.0 0.0 ;
 A3 = 2.0 0.0 ;
 A4 = 2.0 1.0 ;
 A5 = -2.0 1.0 ;

*
**** LIGB
*

 LIGB1 = A0 'DROIT' NX1 A1 ;

* LIGB2 (On utilise un propriete de 'ET' ; si 'ET' change ?)

 xcel = ('COORDONNEE' 1 A1) '+' DX ;
 ycel = 0.1 '*' ( 1.0 '+' ('COS' (180 '*' xcel)));
 ACEL = xcel ycel ;
 LIGB2 = A1 'DROIT' 1 ACEL ;
 'REPETER' BL1 (NX2 '-' 2) ;
    ACEL0 = ACEL ;
    xcel = xcel '+' DX ;
    ycel = 0.1 '*' ( 1.0 '+' ('COS' (180 '*' xcel)));
    ACEL = xcel ycel ;
    LIGB2 = LIGB2 'ET' (ACEL0 'DROIT' 1 ACEL) ;
 'FIN' BL1;
 LIGB2 = LIGB2 'ET' (ACEL 'DROIT' 1 A2) ;


 LIGB3 = A2 'DROIT' NX3 A3 ;

 LIGB = LIGB1 'ET' LIGB2 'ET' LIGB3 ;

*
**** LIGH
*

 LIGH = A4 'DROIT' NX A5 ;

*
*** LIGG
*

 LIGG = A5 'DROIT' NY A0 ;

*
**** LIGD
*

 LIGD = A3 'DROIT' NY A4 ;

 LIGT = LIGB 'ET' LIGD 'ET' LIGH 'ET' LIGG ;

*
**** Le domaine
*
 DOMINT = LIGT 'SURFACE' 'PLANE' ;
 DOMINT = 'DEDU'  DOMINT  LIGT LIGT 'REGU' ;

*
**** Le rafinement
*
*
**** C'est la Perle qui a fait ça quand il etait encore tres brillant!!!
*    (Avant la lettre de l'Arme!!!)
*    Mais il va bientot etre un vrai homme!!!
*


 DOMCEL = DOMINT ;

 'SI' (nraff > 0) ;
    'REPETER' bcl nraff ;
        mttemp = 'CHANGER' DOMCEL 'QUADRATIQUE' ;
        $mtt   = 'DOMA' mttemp 'MACRO' ;
        DOMCEL = ($mtt . 'MAILLAGE') ;
        'OUBLIER' mttemp ;
        'OUBLIER' $mtt ;
        DOMINT = DOMCEL ;
        LIGCON = 'CONTOUR' DOMINT ;

*
**** Je doit transler le points du BUMP (operateur FORME)
*

        NLIGB2 = LIGCON 'ELEM' 'COMPRIS' A1 A2 ;
        MAILB = 'CHANGER' NLIGB2 'POI1';
        MAILB0 = MAILB 'PLUS' (0.0D0 0.0D0);

*       Listreels des deplacements

        NP = 'NBNO' MAILB ;
        LISTX = 'PROG' NP '*' 0.0 ;
        LISTY = 'PROG' NP '*' 0.0 ;

        'REPETER' BL1 ('NBNO' MAILB) ;
           xcel ycel0 = 'COORDONNEE' (MAILB 'POIN' &BL1);
           ycel = 0.1 '*' ( 1.0 '+' ('COS' (180 '*' xcel)));
        'REMPLACER' LISTY &BL1 (ycel '-' ycel0) ;

    'FIN' BL1 ;

    DEPCH = 'MANUEL' 'CHPO' MAILB 2 'UX' LISTX 'UY' LISTY ;
    'FORME' DEPCH ;

    'FIN' bcl ;
    DX = DX '/' (NRAFF '*' 2.0 ) ;
 'SINON' ;
    LIGCON = 'CONTOUR' DOMINT ;
 'FINSI' ;
 'MENAGE' ;

*
**** Les C.L.
*

 NLIGD = LIGCON 'ELEM' 'COMPRIS' A3 A4 ;
 NLIGG = LIGCON 'ELEM' 'COMPRIS' A5 A0 ;

 'OPTION' 'ELEM' 'QUA4' ;
 FG = (NLIGG 'TRANSLATION' 1 ((-1.0 '*' DX) 0.0)) 'COULEUR' 'ROUGE' ;
 FD = (NLIGD 'TRANSLATION' 1 (DX 0.0)) 'COULEUR' 'ROUGE' ;
 FRONT = FG 'ET' FD ;

*
**** Domaine '+' CL
*

 DOMTOT = DOMINT 'ET' FG 'ET' FD ;
'ELIMINATION' DOMTOT 0.0001 ;

*********************
*** TABLE DOMAINE ***
*********************

 $DOMTOT = 'DOMA' DOMTOT  ;
 $DOMINT = 'DOMA' DOMINT 'INCL' $DOMTOT ;
 $FG     = 'DOMA' FG     'INCL' $DOMTOT ;
 $FD     = 'DOMA' FD     'INCL' $DOMTOT ;
 $FRONT  = 'DOMA' FRONT  'INCL' $DOMTOT ;
 'DOMA' $DOMINT 'XXNORMAF' ;

 CHPONOR = $DOMINT . 'XXNORMAF' ;

 MOD1    =  'MODELISER'  ($DOMTOT . 'MAILLAGE' ) 'THERMIQUE';

*
**** On doit imposer un'entree subsonic (u>0 i.e. 3 condition a imposer) et une
*    sortie subsonic (1 condition)
*

*
**** Maillage entree subsonic
*

 POIN0 =  NLIGG 'POIN' 1;
 X1 Y1 = 'COORDONNEE' POIN0;
 'REPETER' BLLIM (('NBNO' NLIGG) '-' 1) ;
    X0 = X1 ;
    Y0 = Y1 ;
    POIN0 = NLIGG 'POIN' (&BLLIM '+' 1) ;
    X1 Y1 = 'COORDONNEE' POIN0 ;
    XFAC = (X0 '+' X1) '/' 2 ;
    YFAC = (Y0 '+' Y1) '/' 2 ;
    PFAC = ($DOMINT . 'FACE') 'POIN' 'PROC' (XFAC YFAC);
    GEOFAC1 = ($DOMINT . 'FACEL') 'ELEM' 'APPUYE'
             'LARGEMENT' PFAC ;
    GEOFAC2 = ($FG . 'FACEL') 'ELEM' 'APPUYE'
             'LARGEMENT' PFAC ;
*
**** Tranformation en POI1
*
    GEO1POI1 = 'CHANGER' 'POI1' GEOFAC1 ;
    PCEL11 = GEO1POI1 'POIN'  1 ;
    PCEL12 = GEO1POI1 'POIN'  2 ;
    GEO2POI1 = 'CHANGER' 'POI1' GEOFAC2 ;
    PCEL21 = GEO2POI1 'POIN' 1 ;
    PCEL22 = GEO2POI1 'POIN' 2 ;
*
**** Il faur verifier que PFAC = PCEL12 = PCEL22
*    ('NBEL' GEO1POI1) = ('NBEL' GEO2POI1) = 2
*
   'SI'  ( ('NBEL' GEO1POI1) 'NEG' 2);
       'MESSAGE' ;
       'MESSAGE'
          'Probleme dans la creation du domaine entree subsonique';
       'MESSAGE' ;
       'ERREUR' 21 ;
   'FINSI' ;
   'SI'  ( ('NBEL' GEO2POI1) 'NEG' 2);
       'MESSAGE' ;
       'MESSAGE'
          'Probleme dans la creation du domaine entree subsonique';
       'MESSAGE' ;
       'ERREUR' 21 ;
   'FINSI' ;
   'SI'  ( PCEL12 'NEG' PFAC);
       'MESSAGE' ;
       'MESSAGE'
          'Probleme dans la creation du domaine entree subsonique';
       'MESSAGE' ;
       'ERREUR' 21 ;
   'FINSI' ;
   'SI'  ( PCEL22 'NEG' PFAC);
       'MESSAGE' ;
       'MESSAGE'
          'Probleme dans la creation du domaine entree subsonique';
       'MESSAGE' ;
       'ERREUR' 21 ;
   'FINSI' ;
*
*** Creation d'un maillage SEG2
*
   'SI' (&BLLIM 'EGA' 1);
       BONCONNE = 'MANUEL' 'SEG2' PCEL11 PCEL21 'COULEUR'  'ROUGE' ;
       MAILNOR = 'MANUEL' PCEL21 'POI1' ;
       LISTVX = 'PROG' ('EXTRAIRE' CHPONOR PCEL12 'UX') ;
       LISTVY = 'PROG' ('EXTRAIRE' CHPONOR PCEL12 'UY') ;
    'SINON' ;
       BONCONNE = BONCONNE 'ET'
          ( 'MANUEL' 'SEG2' PCEL11 PCEL21 'COULEUR'  'ROUGE' );
       MAILNOR = MAILNOR 'ET' PCEL21 ;
       LISTVX = LISTVX 'ET' ('PROG' ('EXTRAIRE' CHPONOR PCEL12
          'UX')) ;
       LISTVY = LISTVY 'ET' ('PROG' ('EXTRAIRE' CHPONOR PCEL12
           'UY')) ;
    'FINSI' ;
 'FIN' BLLIM ;


*
**** Maillage sortie subsonic
*

 POIN0 =  NLIGD 'POIN' 1;
 X1 Y1 = 'COORDONNEE' POIN0;
 'REPETER' BLLIM (('NBNO' NLIGD) '-' 1) ;
    X0 = X1 ;
    Y0 = Y1 ;
    POIN0 = NLIGD 'POIN' (&BLLIM '+' 1) ;
    X1 Y1 = 'COORDONNEE' POIN0 ;
    XFAC = (X0 '+' X1) '/' 2 ;
    YFAC = (Y0 '+' Y1) '/' 2 ;
    PFAC = ($DOMINT . 'FACE') 'POIN' 'PROC' (XFAC YFAC);
    GEOFAC1 = ($DOMINT . 'FACEL') 'ELEM' 'APPUYE'
             'LARGEMENT' PFAC ;
    GEOFAC2 = ($FD . 'FACEL') 'ELEM' 'APPUYE'
             'LARGEMENT' PFAC ;
*
**** Tranformation en POI1
*
    GEO1POI1 = 'CHANGER' 'POI1' GEOFAC1 ;
    PCEL11 = GEO1POI1 'POIN'  1 ;
    PCEL12 = GEO1POI1 'POIN'  2 ;
    GEO2POI1 = 'CHANGER' 'POI1' GEOFAC2 ;
    PCEL21 = GEO2POI1 'POIN' 1 ;
    PCEL22 = GEO2POI1 'POIN' 2 ;
*
**** Il faur verifier que PFAC = PCEL12 = PCEL22
*    ('NBEL' GEO1POI1) = ('NBEL' GEO2POI1) = 2
*
   'SI'  ( ('NBEL' GEO1POI1) 'NEG' 2);
       'MESSAGE' ;
       'MESSAGE'
          'Probleme dans la creation du domaine entree subsonique';
       'MESSAGE' ;
       'ERREUR' 21 ;
   'FINSI' ;
   'SI'  ( ('NBEL' GEO2POI1) 'NEG' 2);
       'MESSAGE' ;
       'MESSAGE'
          'Probleme dans la creation du domaine entree subsonique';
       'MESSAGE' ;
       'ERREUR' 21 ;
   'FINSI' ;
   'SI'  ( PCEL12 'NEG' PFAC);
       'MESSAGE' ;
       'MESSAGE'
          'Probleme dans la creation du domaine entree subsonique';
       'MESSAGE' ;
       'ERREUR' 21 ;
   'FINSI' ;
   'SI'  ( PCEL22 'NEG' PFAC);
       'MESSAGE' ;
       'MESSAGE'
          'Probleme dans la creation du domaine entree subsonique';
       'MESSAGE' ;
       'ERREUR' 21 ;
   'FINSI' ;
*
*** Creation d'un maillage SEG2
*
    BONCONNE = BONCONNE 'ET'
          ( 'MANUEL' 'SEG2' PCEL11 PCEL21 'COULEUR'  'ROUGE' );
    MAILNOR = MAILNOR 'ET' PCEL21 ;
    LISTVX = LISTVX 'ET' ('PROG' ('EXTRAIRE' CHPONOR PCEL12
          'UX')) ;
    LISTVY = LISTVY 'ET' ('PROG' ('EXTRAIRE' CHPONOR PCEL12
           'UY')) ;
 'FIN' BLLIM ;

 CHNORM = 'MANUEL' 'CHPO' MAILNOR 2 'UX' LISTVX 'UY' LISTVY ;
*
* N.B.:
* CHNORM = normales sortantes du domaine!!!
*

 TITOLO =  ('CHAINE'
 'Maillage et con. aux bords (+ norm. sort.). NBEL = '
  ('NBNO' ($DOMTOT . 'CENTRE'))) ;
 'SI' GRAPH ;
    VECTN  = 'VECTEUR'  CHNORM  .1 'UX' 'UY' 'BLEU' ;
    'TRACER' VECTN (DOMTOT 'ET' BONCONNE)
    'TITRE' TITOLO ;
 'FINSI' ;

*******************************************
****** LIGNE de Post-traitement ***********
*******************************************

 LIGB = LIGCON 'ELEM' 'COMPRIS' A0 A3 ;
 POIN0 =  LIGB 'POIN' 1;
 X1 Y1 = 'COORDONNEE' POIN0 ;
 'REPETER' BLLIM (('NBNO' LIGB) '-' 1) ;
    X0 = X1 ;
    Y0 = Y1 ;
    POIN0 = LIGB 'POIN' (&BLLIM '+' 1) ;
    X1 Y1 = 'COORDONNEE' POIN0 ;
    XFAC = (X0 '+' X1) '/' 2 ;
    YFAC = (Y0 '+' Y1) '/' 2 ;
    PFAC = ($DOMINT . 'FACE') 'POIN' 'PROC' (XFAC YFAC);
    GEOFAC1 = ($DOMINT . 'FACEL') 'ELEM' 'APPUYE'
             'LARGEMENT' PFAC ;
*
**** Tranformation en POI1
*
    GEO1POI1 = 'CHANGER' 'POI1' GEOFAC1 ;
    PCEL11 = GEO1POI1 'POIN'  1 ;
    PCEL12 = GEO1POI1 'POIN'  2 ;
*
**** Il faur verifier que PFAC = PCEL12 = PCEL22
*    ('NBEL' GEO1POI1) = ('NBEL' GEO2POI1) = 2
*
   'SI'  ( ('NBEL' GEO1POI1) 'NEG' 2);
       'MESSAGE' ;
       'MESSAGE'
          'Probleme dans la creation de la ligne pour le post.';
       'MESSAGE' ;
       'ERREUR' 21 ;
   'FINSI' ;
   'SI'  ( PCEL12 'NEG' PFAC);
       'MESSAGE' ;
       'MESSAGE'
          'Probleme dans la creation de la ligne pour le post.';
       'MESSAGE' ;
       'ERREUR' 21 ;
   'FINSI' ;
*
*** Creation d'un maillage SEG2
*
   'SI' (&BLLIM 'EGA' 1);
       PCEN0 = PCEL11 ;
    'SINON' ;
      'SI' (&BLLIM 'EGA' 2);
          LIGPOST = 'MANUEL' 'SEG2' PCEN0 PCEL11 ;
          PCEN0 = PCEL11 ;
      'SINO' ;
          LIGPOST = LIGPOST 'ET' ('MANUEL' 'SEG2' PCEN0 PCEL11) ;
          PCEN0 = PCEL11 ;
      'FINSI' ;
    'FINSI' ;
 'FIN' BLLIM ;

*****************************************************
* CALCUL DE L'ECOULEMENT SUBSONIQUE ISENTROPIQUE STATIONNAIRE DANS  *
* UN CANAL                                                          *
*                                                                   *
*   INITIAL CONDITIONS ------ INITIAL CONDITIOINS
*********************************************************************
* GRAPH = VRAI ;

***************************************************************
***** PROCEDURE POUR CALCULER LES VARIABLES CONSERVATIVES *****
***************************************************************

 'DEBPROC' CONS ;
 'ARGUMENT' RN*'CHPOINT' VN*'CHPOINT' PN*'CHPOINT' GAMN*'CHPOINT' ;

 RVN  =  RN '*' VN ('MOTS' 'SCAL' 'SCAL') ('MOTS' 'UX' 'UY')
    ('MOTS' 'UX' 'UY') ;
 CELL = 'PSCAL' RVN VN ('MOTS' 'UX' 'UY') ('MOTS' 'UX' 'UY') ;
 RECIN = 0.5 '*' CELL ;
 REIN = PN '/' (GAMN '-' 1.0) ;
 RETN = RECIN '+' REIN ;

 DETR CELL ;
 DETR RECIN ;
 DETR REIN ;
 'RESPRO' RVN RETN ;

 'FINPROC' ;

***************************************************************
***************************************************************
***************************************************************


 RN0  = 'MANU' 'CHPO' ($DOMTOT . 'CENTRE') 1 'SCAL' RO_INF
        'NATURE' 'DISCRET' ;
 VN0  = 'MANU' 'CHPO' ($DOMTOT . 'CENTRE') 2 'UX' U_INF
        'UY' 0.0 'NATURE' 'DISCRET' ;
 PN0  = 'MANU' 'CHPO' ($DOMTOT . 'CENTRE') 1 'SCAL' P_INF
        'NATURE' 'DISCRET' ;
 GAMN =  'MANU' 'CHPO' ($DOMTOT . 'CENTRE') 1 'SCAL' GAMSCAL
        'NATURE' 'DISCRET' ;

 GN0 RETN0 = CONS RN0 VN0 PN0 GAMN  ;

 VN20 = 'PSCAL' VN0 VN0 ('MOTS' 'UX' 'UY') ('MOTS' 'UX' 'UY') ;
 CN20 = GAMSCAL '*' (PN0 '/' RN0) ;
 MACHN20 = VN20 '/' CN20 ;
 MACHN0 = MACHN20 '**' 0.5 ;


 MOD1  =  'MODELISER'  ($DOMTOT . 'MAILLAGE' ) 'THERMIQUE';

 'SI' GRAPH ;

    CHM_RN   =  'KCHA' $DOMTOT 'CHAM' RN0 ;
    CHM_PN   =  'KCHA' $DOMTOT 'CHAM' PN0 ;
    CHM_VN  =  'KCHA' $DOMTOT 'CHAM'  VN0 ;
    CHM_MACH =   'KCHA' $DOMTOT 'CHAM' MACHN0 ;

    'TRACER'  CHM_RN  MOD1
       'TITR'  ('CHAINE'  'RN at t='  0.0);
    'TRACER'  CHM_PN  MOD1
       'TITR'  ('CHAINE'  'PN at t='  0.0);
    'TRACER'  CHM_MACH MOD1
       'TITR'  ('CHAINE' 'MACHN at t='  0.0);
    'TRACER'  CHM_VN  MOD1
       'TITR'  ('CHAINE'  'VN at t='  0.0);

 'FINSI' ;

 UN =
   ('NOMC' 'RN' RN0 'NATURE' 'DISCRET') 'ET'
   ('EXCO' ('MOTS' 'UX' 'UY') GN0 ('MOTS' 'RUX' 'RUY')
      'NATURE' 'DISCRET') 'ET'
   ('NOMC' 'RETN' RETN0 'NATURE' 'DISCRET') ;

 UNLIM0 = 'REDU' UN ($FRONT . 'CENTRE') ;

*****************************************************
*****************************************************
*****************************************************
*****************************************************
**************** La table RV   **********************
*****************************************************
*****************************************************
*****************************************************
*****************************************************
 UINF  = 'MANU' 'CHPO' ($DOMTOT . 'CENTRE') 1 'SCAL' U_INF
        'NATURE' 'DISCRET' ;

 UPRI  = 'MANU' 'CHPO' ($DOMTOT . 'CENTRE') 1 'SCAL' 0.0
        'NATURE' 'DISCRET' ;

 RV = 'TABLE' ;

 RV . 'UN' = UN ;

**** Le domaine interne
 RV . 'DOMINT' = $DOMINT . 'CENTRE' ;
*
 RV . 'CLIM' = VRAI ;
*
 RV . 'INST' = VRAI ;
 RV . 'CONS' = FAUX ;
*
 RV . 'TFINAL' = 1.D6 ;
 RV . 'NITMAEX' = 40 ;
*
 RV . 'NITMAIN' = 2 ;
 RV . 'NITMIIN' = 1 ;
 RV . 'EPSINT' = 1.0D-3 ;
***********************************
*****************************************************************
 LMOT = 'MOTS' 'RN' 'RUX' 'RUY' 'RETN' ;

 RN = 'EXCO' 'RN' (RV . 'UN') ;
 GN = 'EXCO' ('MOTS'  'RUX' 'RUY')  (RV . 'UN') ('MOTS' 'UX' 'UY') ;
 RETN = 'EXCO' 'RETN'   (RV . 'UN') ;
****************
 VN PN =   'PRIM' 'PERFMONO'
           RN GN RETN GAMN ;
**************************************
  RV . 'MATIDE' = 'KOPS' 'MATIDE' ('MOTS' 'RN' 'RUX' 'RUY' 'RETN')
    ($DOMTOT . 'CENTRE') 'MATRIK' ;
******************************************************************
*
 RV . 'FEXT' = 20 ;
 RV . 'FINT' = 1 ;
*
 RV . 'LISTOPER' = 'MOTS'  'CALC' 'PKON' ;
*
**** Parametres de la procedure PROLIM
*

 RV . 'MAIFAN' = $FRONT . 'CENTRE' ;
 RV . 'UNLIM' = 'REDU' UNLIM0 ($FRONT . 'CENTRE')  ;
******************************************************
**   Here is the information for the BC
******************************************************
 RV . 'CONNECT' = BONCONNE ;
 RV . 'NORM' = CHNORM ;
 RV . 'GAMSCAL' =  GAMSCAL ;

*

 VITFAN = 'MANUEL' 'CHPO' ($FRONT . 'CENTRE') 2
    'UX' U_INF 'UY' 0.0 ;
 VNORMFAN = 'PSCAL' VITFAN CHNORM ('MOTS' 'UX' 'UY')
   ('MOTS' 'UX' 'UY') ;
 SIGNVN = (2.0 '*' ('MASQUE' VNORMFAN 'SUPERIEUR' 0.0))
   '-' 1.0 ;
 SN_INF = P_INF '/' (RO_INF '**' GAMSCAL) ;
 CELL_INF = (2.0 '/' (GAMSCAL '-' 1.0)) '*'
   ((GAMSCAL '*' P_INF '/' RO_INF) '**' 0.5) ;

 RV . 'R1INF' = (VNORMFAN '*' SIGNVN) '-' CELL_INF ;
 RV . 'R3INF' = (VNORMFAN '*' SIGNVN) '+' CELL_INF ;
 RV . 'R2INF' = SN_INF ;
 RV . 'UTINF' = 'MANUEL' 'CHPO'  ($FRONT . 'CENTRE')
 1  'SCAL' 0.0 ;
********************************************************
***  End of the information for the BC
********************************************************

*****************
** CALCUL *******
*****************

 RV . '1CALC' = 'TABLE' ;
 RV . '1CALC' . 'EQEX' = RV ;
 RV . '1CALC' . 'FCALC' = RV . 'NITMAIN' ;
 RV . '1CALC' . 'IMPL' = VRAI ;
*****************
* PKON **********
*****************

 RV . '2PKON' = 'TABLE' ;
****************************************
* Alberto's strange things.....
****************************************
 ACEL = 0.0 0.0 ;
 M1 = 'MANU' 'POI1' ACEL ;
 M2 = 'MANU' 'POI1' ACEL ;
 RV . '2PKON' . 'FACELIM' = 'DIFF' M1 M2 ;
***************************************
 RV . '2PKON' . 'UINF' = UINF ;
 RV . '2PKON' . 'UPRI' = UPRI ;
 RV . '2PKON' . 'EQEX' = RV ;
 RV . '2PKON' . 'GAZ' = 'PERFMONO' ;
 RV . '2PKON' . 'GAMN' = GAMN ;
 RV . '2PKON' . 'DOMA' = $DOMTOT ;
 RV . '2PKON' . 'LISTINCO' = 'MOTS' 'RN' 'RUX' 'RUY' 'RETN' ;
 RV . '2PKON' . 'METHODE' = AUSMPLM ;
 RV . '2PKON' . 'IMPL' =  VRAI ;
 RV . '2PKON' . 'TYPEJACO' = 'AUSMLMJ1' ;
 RV . '2PKON' . 'THETA' = 1.0 ;
*
*
 RV . '2PKON' . 'ORDREESP' = 2 ;
 RV . '2PKON' . 'LIMITEUR' = 'NOLIMITE' ;
 RV . '2PKON' . 'PREDCOR' = FAUX ;
 RV . '2PKON' . 'ALPHA' = 1000000.0 ;

*
**** Dans le cas explicite, on doit faire beaucoup
*    plus d'iterations
*
 'SI' ('NON' ( RV . '2PKON' . 'IMPL' )) ;
    RV . 'NITMAEX' = (RV . 'NITMAEX') '*' 1 ;
 'FINSI' ;
*
*
**** Les gradients
*

 'SI' ((RV . '2PKON' . 'ORDREESP') 'EGA' 2) ;
 CACCA PIPI = 'KOPS' 'MATRIK' ;

 RN = 'EXCO' 'RN' UN ;
 GN = 'EXCO' ('MOTS' 'RUX' 'RUY') UN ('MOTS' 'UX' 'UY') ;
 RETN = 'EXCO' 'RETN' UN ;

 VN PN = 'PRIM' 'PERFMONO' RN GN RETN GAMN ;
 GRADR ALR COEFR = 'PENT' $DOMTOT 'CENTRE' 'EULESCAL' 'NOLIMITE'
                RN  ;
 GRADP ALP COEFP = 'PENT' $DOMTOT 'CENTRE' 'EULESCAL' 'NOLIMITE'
                PN  ;
 GRADV ALV COEFV = 'PENT' $DOMTOT 'CENTRE' 'EULEVECT' 'NOLIMITE'
                VN  'CLIM' CACCA ;

 RV . '2PKON' . 'GRADRN' = COEFR ;
 RV . '2PKON' . 'GRADPN' = COEFP ;
 RV . '2PKON' . 'GRADVN' = COEFV ;
 RV . '2PKON' . 'VLIM' = CACCA ;
 'FINSI' ;

***********************************
* Inversion de la matrice *********
***********************************

 RV . 'MATINV' = 'TABLE' 'METHINV' ;
 MATTAB = RV . 'MATINV' ;
 MATTAB .  'TYPINV' = 5 ;
 MATTAB .  'IMPINV' = 0 ;
*
* Matrice pour assurer que la matrice à inverser est correctement
* assemblé
*
*  MATTAB  . 'MATASS'  definie en EXEXIM
*  MATTAB  . 'MAPREC'         "
*  MATTAB  . 'XINIT'          "
*

* Methode de numerotation de DDL
  MATTAB . 'TYRENU' = 'SLOA' ;
  MATTAB . 'PCMLAG' = 'APR2' ;
  MATTAB . 'GMRESTRT' = 50 ;
* ILU
  MATTAB . 'PRECOND' = 3 ;
  MATTAB . 'NITMAX' = 3000 ;
  MATTAB . 'RESID' = 1.D-6 ;

******************************************************************
******************************************************************
******************************************************************
******************************************************************
******************************************************************
******************************************************************
******************************************************************
******************************************************************


*
**** Exexcution EXEXIM
*

 'TEMPS' 'ZERO' ;


 EXEXIM RV ;
 'TEMPS'  ;

 'MENAGE' ;

 'SI' ('NON' (RV . 'INST')) ;
    CELL = 'INF' ;
 'SINON' ;
    CELL = ((RV . '2PKON' . 'ALPHA'))  ;
 'FINSI' ;

********************************************************************
**********  POSTTREATMENT-------------------------------------------
********************************************************************

* GRAPH = VRAI ;

*****************************************************
*************** SOLUTIONS ***************************
*****************************************************
*****************************************************

*
**** Le noms de la procedure PKON
*

 LISTOPER = RV . 'LISTOPER' ;
 'REPETER' BL1 ('DIME' LISTOPER) ;
    NOMPER  = 'EXTRAIRE' LISTOPER &BL1  ;
    'SI' ('EGA' NOMPER 'PKON') ;
      KKON = RV . ('MOT'  ('TEXTE'  ('CHAINE'  &BL1  NOMPER) )) ;
    'FINSI' ;
 'FIN' BL1 ;

 ORD_ESP = KKON . 'ORDREESP' ;

 'SI' (RV . 'INST') ;
    ALPDT = KKON . 'ALPHA' ;
    TFIN = RV . 'PASDETPS' . 'TPS' ;
 'SINON' ;
    ALPDT = 'INF' ;
    TFIN = 'INF' ;
 'FINSI' ;

 NTOTEL = 'NBNO' ($DOMINT . 'CENTRE') ;

*
**** Les variables conservatives
*


 RN = 'EXCO' 'RN' (RV . 'UN') ;
 GN = 'EXCO' ('MOTS'  'RUX' 'RUY')  (RV . 'UN') ('MOTS' 'UX' 'UY') ;
 RETN = 'EXCO' 'RETN'   (RV . 'UN') ;

*
**** Les variables primitives
*

 VN PN =   'PRIM' 'PERFMONO'
           RN GN RETN GAMN ;

 CSON2 = (GAMN '*' PN) '/' RN ;
 VN2 = 'PSCAL' VN VN ('MOTS' 'UX' 'UY') ('MOTS' 'UX' 'UY') ;
 MACHN2 = VN2 '/' CSON2 ;
 MACHN = MACHN2 '**' 0.5 ;

*
*** GRAPHIQUE DES SOLUTIONS
*

 MOD1 = 'MODELISER' $DOMTOT 'THERMIQUE';
 'SI' GRAPH ;

  'TRACER' DOMTOT 'TITRE' ('CHAINE' 'Maillage, NBEL =' NTOTEL) ;
  'FINSI' ;
 TITOLO =  ('CHAINE' METO ', OE = ' ORD_ESP ', ALPDT =' ALPDT
    ', TFIN =' TFIN ', NBEL = ' NTOTEL) ;

* 'SI' GRAPH ;

    CHM_RN   =  'KCHA' $DOMTOT 'CHAM' RN ;
    CHM_PN   =  'KCHA' $DOMTOT 'CHAM' PN ;
    CHM_VN  =  'KCHA' $DOMTOT 'CHAM'  VN ;
    CHM_MACH =   'KCHA' $DOMTOT 'CHAM' MACHN ;

    SN = (PN '/' (RN '**' GAMSCAL)) ;
    ERSN = 'ABS' (SN '-' ((P_INF '/' (RO_INF '**' GAMSCAL)))) ;
    CHM_ERSN =   'KCHA' $DOMTOT 'CHAM' ERSN ;

  'SI' GRAPH ;

    'TRACER'  CHM_RN  MOD1 ('CONTOUR' DOMTOT)
       'TITR'  ('CHAINE' 'RN : ' TITOLO) ;
    'TRACER'  CHM_PN  MOD1  ('CONTOUR' DOMTOT)
       'TITR'  ('CHAINE' 'PN : ' TITOLO) ;
    'TRACER'  CHM_MACH MOD1  ('CONTOUR' DOMTOT)
       'TITR'  ('CHAINE' 'MACHN : ' TITOLO);
    'TRACER'  CHM_VN  MOD1  ('CONTOUR' DOMTOT)
       'TITR'  ('CHAINE'  'VN : ' TITOLO) ;
    'TRACER'  CHM_ERSN MOD1  ('CONTOUR' DOMTOT)
       'TITR'  ('CHAINE'  'ERSN : ' TITOLO) ;

    'SI' (RV . 'INST') ;
       TITOLO1 = 'CHAINE' 'Convergence : ' TITOLO ;
       EVER = 'EVOL' 'MANU' 'Niter' (RV . '1CALC' . 'IT') 'Log_10(Linf)'
         (RV . '1CALC' . 'ER') ;
       'DESSIN' EVER 'TITRE' TITOLO1 ;
       EVER1 = 'EVOL' 'MANU' 'tps' (RV . '1CALC' . 'TPS') 'Log_10(Linf)'
         (RV . '1CALC' . 'ER') ;
       'DESSIN' EVER1 'TITRE' TITOLO1 ;
    'FINSI' ;

    MNC = 'ELNO' $DOMINT ('KCHT' $DOMINT 'SCAL' 'CENTRE' MACHN) ;
    'OPTION' 'ISOV' 'LIGN' ;
    'TRACER' DOMINT MNC ('CONTOUR' DOMINT)
           'TITR'  ('CHAINE' 'MACHN : ' TITOLO) 55 ;



 'FINSI' ;

 XLIGPOST = 'COORDONNEE' 1 LIGPOST ;
 EVCOOR = 'EVOL' 'CHPO' XLIGPOST 'SCAL' LIGPOST ;
 LISTX = 'EXTRAIRE' EVCOOR 'ORDO' ;

 EVMACH =  'EVOL' 'CHPO' MACHN 'SCAL' LIGPOST ;
 LISTMACH = 'EXTRAIRE' EVMACH 'ORDO' ;
 EVMACH = 'EVOL' 'MANU' 'x' LISTX 'Mach' LISTMACH ;
 'SI' GRAPH ;
   'DESSIN' EVMACH 'MIMA' 'TITRE' TITOLO ;
 'FINSI' ;
*
**** Entropie
*

 EVSN =  'EVOL' 'CHPO' SN 'SCAL' LIGPOST ;
 LISTSN = 'EXTRAIRE' EVSN 'ORDO' ;
 EVSN = 'EVOL' 'MANU' 'x' LISTX 'SN' LISTSN ;
 'SI' GRAPH ;
   'DESSIN' EVSN 'MIMA' 'TITRE' TITOLO ;
 'FINSI' ;
 EVERSN = 'EVOL' 'CHPO' ERSN 'SCAL' LIGPOST ;
 LISTERSN = 'EXTRAIRE' EVERSN 'ORDO' ;
 EVERSN = 'EVOL' 'MANU' 'x' LISTX 'SN' LISTERSN ;
 EVMAX = 'MAXIMUM' LISTERSN ;
 'SI' ( EVMAX  > ENTERR ) ;
    'ERREUR' 5 ;
 'FINSI' ;
 'SI' GRAPH ;
   'DESSIN' EVERSN 'MIMA' 'TITRE' TITOLO ;
 'FINSI' ;

 PCEL1 = -2.0 0.99 ;
 PCEL2 = 2.0 0.99 ;

 LIGTRA = PCEL1 'DROIT' (2 '*' NRAFF '*' ('NBNO' LIGH)) PCEL2 ;

 PCEL12 = ($DOMINT . 'CENTRE') 'POIN' 'PROC' PCEL1 ;
 LIGNEW = ('MANUEL' 'POI1' PCEL12) ;

 'REPETER' BL1 (('NBNO' LIGTRA) '-' 1) ;
    PCEL11= PCEL12 ;
    PCEL13 = LIGTRA 'POIN' (&BL1 '+' 1) ;
    PCEL13 = ($DOMINT . 'CENTRE') 'POIN' 'PROC' PCEL13 ;
    'SI' (PCEL13 'NEG' PCEL11) ;
       PCEL12 = PCEL13 ;
       LIGNEW = LIGNEW 'ET' ('MANUEL' 'POI1' PCEL12) ;
    'FINSI' ;
 'FIN' BL1 ;

 LIGNEW = 'QUELCONQUE' 'SEG2' LIGNEW ;

 EVRN1 = 'EVOL' 'CHPO' MACHN 'SCAL' LIGNEW ;
 LISTRN1 = 'EXTRAIRE' EVRN1 'ORDO' ;
 LISTX1 = 'EVOL' 'CHPO' ('COORDONNEE' 1 LIGNEW) 'SCAL' LIGNEW ;
 LISTX1 = 'EXTRAIRE' LISTX1 'ORDO' ;
 EVERRN1 = 'EVOL' 'MANU' 'x' LISTX1 'RN' LISTRN1 ;
 'SI' GRAPH ;
   'DESSIN' EVERRN1 'MIMA' 'TITRE' TITOLO ;
 'FINSI' ;


 'FIN' ;









