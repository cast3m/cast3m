* fichier : trainee_3d.dgibi
'OPTION' 'ECHO' 0 ;
'MESSAGE' ('CHAINE' 'Execution de trainee_3d.dgibi') ;
*BEGINPROCEDUR calcul3d
************************************************************************
* NOM         : CALCUL3D
* DESCRIPTION :
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 10/10/2006, version initiale
* HISTORIQUE : v1, 10/10/2006, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' CALCUL3D ;
'ARGUMENT' tymesh*'ENTIER' ;
'ARGUMENT' reproj*'ENTIER' ;
'ARGUMENT' irig*'ENTIER' ;
'ARGUMENT' iden*'FLOTTANT' ;
'ARGUMENT' debug/'LOGIQUE' ;
*
'SI' ('NON' ('EXISTE' debug)) ;
   debug = FAUX ;
'FINSI' ;
*
tabgeo = CMAIL3D Ar Az discg tymesh reproj iden ;
_mt = tabgeo . 'mt' . 'QUAF' ;
titgeo = 'CHAINE' 'mt ' 'NBPO=' ('NBNO' _mt)
                     ' NBELEM=' ('NBEL' _mt) ;
'SI' debug ;
   'TRACER' _mt 'TITRE' titgeo ;
'FINSI' ;
*
* Solution exacte
*
mvit = tabgeo . 'mt' . discv ;
mvitq = tabgeo . 'mt' . 'QUAF' ;
solx = SOLEX mvit ;
vsolx = 'VECTEUR' solx 'DEPL' 'JAUN' ;
*debug 'TRACER' 'CACH' vsolx mvitq ;
*
* Conditions aux limites
*
mu  = (tabgeo . 'emt' . discv) ;
muz = mu ;
ppres  = 'POIN'  (tabgeo . 'bot' . discv)
                 'PROC' (('*' Ar 0.75) ('*' Ar 0.75) 0.) ;
*lpres  = 'ELEM' mvclim 'APPUYE' 'LARGEMENT' ppres ;
*mvclim = 'DIFF' mvclim lpres ;
lpres  = 'MANUEL' 'POI1' ppres ;
muz    = 'DIFF' ('CHANGER' muz 'POI1') lpres ;
'SI' debug ;
   'TRACER' muz 'TITR' 'Maillage clim' ;
'FINSI' ;
cclim  = ('REDU' ('EXCO' 'UX' solx 'UX') mu) '+'
         ('REDU' ('EXCO' 'UY' solx 'UY') mu) '+'
         ('REDU' ('EXCO' 'UZ' solx 'UZ') muz) ;
mblo   = ('BLOQUE' 'UX' mu) 'ET' ('BLOQUE' 'UY' mu)
  'ET'   ('BLOQUE' 'UZ' muz) ;
*cclim  = ('REDU' ('EXCO' 'UX' solx 'UX') mu) ;
*mblo   = ('BLOQUE' 'UX' mu) ;
fblo   = 'DEPIMPOSE' mblo cclim ;
*
* Matrice de rigidité
*
mrig = GRIG _mt discg discv lvip lvid 1. ;
*
'SI' ('EGA' irig 1) ;
   mrigt = mrig ;
'FINSI' ;
'SI' ('EGA' irig 2) ;
   mrig2 = GRIG2 _mt discg discv lvip lvid ;
   mrigt = mrig 'ET' mrig2 ;
'FINSI' ;
'SI' ('EGA' irig 3) ;
   mrig3 = GRIG3 _mt discg discv lvip lvid ;
   mrigt = mrig 'ET' mrig3 ;
'FINSI' ;
*
* Matrice de contrainte div u = 0
*
mbbt = GBBT2 _mt discg discv lvip lvid discp lpip lpid 1. ;
*
* Matrice masse de pression nulle
*
mmasp = GMASP _mt discg lpip discp lpid discp 1. ;
mmasp = '*' mmasp 0. ;
*
*toto = 'MODELISER' _mt 'NAVIER_STOKES' 'LINE' ;
*mid = 'KOPS' 'MATIDE' ('MOTS' 'UX') _mt ;
*mid = 'KOPS' 'MATIDE' ('MOTS' 'UX') ('DOMA' toto 'MAILLAGE') ;
*mmas = GMASS _mt discg 'UX' discv 'UX' discv 1. ;
mtot = ('*' mrigt -1.D0)  'ET' mblo 'ET' mmasp 'ET' ('*' mbbt -1.) ;
*mtot = ('*' mrigt -1.D0)  'ET' mmasp 'ET' ('*' mbbt -1.) ;
*mtot =  mrigt  'ET' mblo ;
*mtot = ('*' mrigt 1.) 'ET' mblo ;
*mtot = mrigt ;
*mtot = mid ;
ftot = fblo ;
*'LISTE' mtot 5 ;
*'LISTE' cclim ;
*
*sola = 'RESOUD' mtot ftot ;
sola = 'KRES' mtot ftot 'TYPINV' 2 'IMPR' 0 ;
*sola = 'KRES' mtot ftot 'TYPINV' 2 'IMPR' 3 ;
*sola = 'KRES' mtot 'CLIM' cclim 'TYPINV' 2 'IMPR' 3 ;
*sola = 'KRES' mtot ;
*'LISTE' sola ;
dsol = 'EXCO' lvip ('-' sola solx) ;
*
* Post-traitement
*
'SI' debug ;
   vsola = 'VECTEUR' sola 'DEPL' 'ROUG' ;
   vdsol = 'VECTEUR' dsol 'DEPL' 'JAUN' ;
   'TRACER' (vsolx 'ET' vsola) mvitq  ;
'FINSI' ;
*'ERREUR' 1 ;
*'OPTION' 'DONN' 5 ;
*'TRACER' vdsol mvitq  ;
*
* Erreur L2 avec poids entre vitesse approchée
* et interpolé de la vitesse exacte
*
mmass = GMASS _mt discg 'SCAL' discv 'SCAL' discv 1. ;
ms = 'MOTS' 'SCAL' ;
mux = 'EXTRAIRE' lvip ('LECT' 1) ;
mfx = 'EXTRAIRE' lvid ('LECT' 1) ;
muy = 'EXTRAIRE' lvip ('LECT' 2) ;
mfy = 'EXTRAIRE' lvid ('LECT' 2) ;
muz = 'EXTRAIRE' lvip ('LECT' 3) ;
mfz = 'EXTRAIRE' lvid ('LECT' 3) ;
mmasx = 'CHANGER' 'INCO' mmass ms mux ms mfx ;
mmasy = 'CHANGER' 'INCO' mmass ms muy ms mfy ;
mmasz = 'CHANGER' 'INCO' mmass ms muz ms mfz ;
mmas = mmasx 'ET' mmasy 'ET' mmasz ;
dsol = 'EXCO' lvip ('-' sola solx) ;
errl2 = '**' (xtmx dsol mmas) 0.5D0 ;
errli = 'MAXIMUM' dsol 'ABS' ;
*
* Force de traînée de Stokes
*
ft = 'REAC' mblo sola ;
fts = 'REDU' ft (tabgeo . 'sph' . discv) ;
rft = 'RESULT' fts ;
*
fstox = '*' PI 6.D0 ;
* On a calculé sur 1/8eme de sphère
fstoa = '*' ('MAXIMUM' ('EXCO' 'FZ' rft) 'ABS') 8. ;
errfst = '/' ('ABS' ('-' fstox fstoa)) fstox ;
*
'SI' debug ;
   'MESSAGE' ('CHAINE' 'Résultante de la force de trainee =' fstoa) ;
*   'LISTE' rft ;
   'MESSAGE' ('CHAINE' 'Force de Stokes = ' fstox) ;
   'MESSAGE' ('CHAINE' 'Err rel. trainee  = ' errfst) ;
   'MESSAGE' ('CHAINE' 'Erreur L2 = ' errl2) ;
   'MESSAGE' ('CHAINE' 'Maxi sola - solex = ' errli) ;
'FINSI' ;
*
'RESPRO' errl2 errli errfst ;
*
* End of procedure file CALCUL3D
*
'FINPROC' ;
*ENDPROCEDUR calcul3d
*BEGINPROCEDUR cmail3d
************************************************************************
* NOM         : CMAIL3D
* DESCRIPTION : Maillages pour le cas-test Stokes
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 11/04/2006, version initiale
* HISTORIQUE : v1, 11/04/2006, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' CMAIL3D ;
'ARGUMENT' Ar*'FLOTTANT' ;
'ARGUMENT' Az*'FLOTTANT' ;
'ARGUMENT' discg*'MOT' ;
'ARGUMENT' tymesh*'ENTIER' ;
'ARGUMENT' reproj*'ENTIER' ;
'ARGUMENT' iden*'FLOTTANT' ;
*
'DENS' iden ;
*
'SI' ('EGA' tymesh 1) ;
   ell = 'TET4' ; elq = 'TE10' ;
'FINSI' ;
'SI' ('EGA' tymesh 2) ;
   ell = 'TET4' ; elq = 'TE10' ;
'FINSI' ;
'SI' ('EGA' tymesh 3) ;
   ell = 'CUB8' ; elq = 'CU20' ;
'FINSI' ;
disq = 'OU' ('EGA' discg 'QUAF') ('EGA' discg 'QUAD') ;
'OPTION' 'ELEM' elq ;
* Points
pA = 1. 0. 0. ; pB = 0. 1. 0. ; pC = 0. 0. 1. ;
pD = Ar 0. 0. ; pE = Ar Ar 0. ; pF = 0. Ar 0. ;
p0 = 0. 0. 0. ; pG = 0. 0. Az ;
pH = Ar 0. Az ; pI = Ar Ar Az ; pJ = 0. Ar Az ;
* Lignes
dAD = 'DROIT' pA pD ; dDH = 'DROIT' pD pH ;
dHG = 'DROIT' pH pG ; dGC = 'DROIT' pG pC ;
*
dDE = 'DROIT' pD pE ; dEI = 'DROIT' pE pI ; dIH = 'DROIT' pI pH ;
*
dEF = 'DROIT' pE pF ; dFJ = 'DROIT' pF pJ ; dJI = 'DROIT' pJ pI ;
*
dFB = 'DROIT' pF pB ; dCG = 'INVERSE' dGC ; dGJ = 'DROIT' pG pJ ;
*
'SI' ('EGA' tymesh 1) ;
   'SI' ('NON' disq) ;
      'OPTION' 'ELEM' ell ;
      cAB = 'CERCLE' pA p0 pB ; cBC = 'CERCLE' pB p0 pC ;
      cCA = 'CERCLE' pC p0 pA ;
      cAB = 'CHANGER' cAB 'QUADRATIQUE' ;
      cBC = 'CHANGER' cBC 'QUADRATIQUE' ;
      cCA = 'CHANGER' cCA 'QUADRATIQUE' ;
      'OPTION' 'ELEM' elq ;
   'SINON' ;
      cAB = 'CERCLE' pA p0 pB ; cBC = 'CERCLE' pB p0 pC ;
      cCA = 'CERCLE' pC p0 pA ;
   'FINSI' ;
* Surfaces
   csph = cAB 'ET' cBC 'ET' cCA ;
   sph = 'SURFACE' csph 'SPHERIQUE' p0 ;
   cfro = dAD 'ET' dDH 'ET' dHG 'ET' dGC 'ET' cCA ;
   fro  = 'SURFACE' cfro 'PLANE' ;
   cdro = dDE 'ET' dEI 'ET' dIH 'ET' ('INVERSE' dDH) ;
   dro  = 'SURFACE' cdro 'PLANE' ;
   crea = dEF 'ET' dFJ 'ET' dJI 'ET' ('INVERSE' dEI) ;
   rea  = 'SURFACE' crea 'PLANE' ;
   cgau = dFB 'ET' cBC 'ET' dCG 'ET' dGJ 'ET' ('INVERSE' dFJ) ;
   gau  = 'SURFACE' cgau 'PLANE' ;
   cbot = dAD 'ET' dDE 'ET' dEF 'ET' dFB 'ET' ('INVERSE' cAB) ;
   bot  = 'SURFACE' cbot 'PLANE' ;
   ctop = 'INVERSE' (dHG 'ET' dGJ 'ET' dJI 'ET' dIH) ;
   top  = 'SURFACE' ctop 'PLANE' ;
* Volume
   emt = sph 'ET' fro 'ET' dro 'ET' rea 'ET' gau 'ET' bot 'ET' top ;
*'TRACER' emt 'CACH' ;
   mt = 'VOLUME' emt ;
'FINSI' ;
*
'SI' ('OU' ('EGA' tymesh 2) ('EGA' tymesh 3)) ;
   'SI' ('NON' disq) ;
      'OPTION' 'ELEM' ell ;
      ctop = 'INVERSE' (dHG 'ET' dGJ 'ET' dJI 'ET' dIH) ;
      top  = 'SURFACE' ctop 'PLANE' ;
      cdro = dDE 'ET' dEI 'ET' dIH 'ET' ('INVERSE' dDH) ;
      dro  = 'SURFACE' cdro 'PLANE' ;
      crea = dEF 'ET' dFJ 'ET' dJI 'ET' ('INVERSE' dEI) ;
      rea  = 'SURFACE' crea 'PLANE' ;
      ext = top 'ET' dro 'ET' rea ;
      sph = 'PROJETER' ext 'CONI' p0 'SPHE' p0 pA ;
*      sph = 'HOMOTHETIE'  ext 0.5 p0 ;
      mt = 'VOLUME' sph ext ;
* debug     'TRACER' sph 'TITRE' 'Lineaire' 'NOEU' ;
      sph = 'CHANGER' sph 'QUADRATIQUE' ;
* debug     'TRACER' sph 'TITRE' 'Quadratique' 'NOEU' ;
      top = 'CHANGER' top 'QUADRATIQUE' ;
      dro = 'CHANGER' dro 'QUADRATIQUE' ;
      rea = 'CHANGER' rea 'QUADRATIQUE' ;
      mt  = 'CHANGER' mt  'QUADRATIQUE' ;
      ext = top 'ET' dro 'ET' rea ;
      'OPTION' 'ELEM' elq ;
   'SINON' ;
      ctop = 'INVERSE' (dHG 'ET' dGJ 'ET' dJI 'ET' dIH) ;
      top  = 'SURFACE' ctop 'PLANE' ;
      cdro = dDE 'ET' dEI 'ET' dIH 'ET' ('INVERSE' dDH) ;
      dro  = 'SURFACE' cdro 'PLANE' ;
      crea = dEF 'ET' dFJ 'ET' dJI 'ET' ('INVERSE' dEI) ;
      rea  = 'SURFACE' crea 'PLANE' ;
      ext = top 'ET' dro 'ET' rea ;
*      sph = 'HOMOTHETIE'  ext 0.5 p0 ;
      sph = 'PROJETER' ext 'CONI' p0 'SPHE' p0 pA ;
      mt = 'VOLUME' sph ext ;
   'FINSI' ;
* Volume
   'SI' debug ;
      'TRACER' mt 'CACH' ;
   'FINSI' ;
   emt = 'ENVELOPPE' mt ;
   bid = 'MANUEL' 'CHML' emt 'SCAL' 1. ;
   zbid = 'COORDONNEE' 3 bid ;
   bot = 'ELEM' zbid 'INFERIEUR' ('/' iden 100.) ;
'FINSI' ;
*
_mt  = 'CHANGER' mt  'QUAF' ;
_bot = 'CHANGER' bot 'QUAF' ;
_sph = 'CHANGER' sph 'QUAF' ;
*_top = 'CHANGER' top 'QUAF' ;
*_gau = 'CHANGER' gau 'QUAF' ;
*_dro = 'CHANGER' dro 'QUAF' ;
*_fro = 'CHANGER' fro 'QUAF' ;
*_rea = 'CHANGER' rea 'QUAF' ;
_emt = 'CHANGER' emt 'QUAF' ;
'ELIMINATION' (_mt 'ET' _bot 'ET' _sph 'ET' _emt) ('/' iden 100.) ;
*debug 'TRACER' (_mt 'ET' ('COULEUR' _sph 'ROUG')) ;
'SI' ('EGA' reproj 1) ;
   'DEPLACER' _sph 'PROJ' 'CONI' p0 'SPHE' p0 pA ;
'FINSI' ;
*
tabgeo = 'TABLE' ;
tabgeo . 'mt' = 'TABLE' ;
tabgeo . 'mt' . 'QUAF' = _mt ;
tabgeo . 'mt' . 'QUAD' = _mt ;
tabgeo . 'mt' . 'QUAI' = mt ;
tabgeo . 'mt' . 'LINM' = 'DOMA'
  ('MODELISER' _mt 'NAVIER_STOKES' 'QUAF') 'CENTRE' ;
tabgeo . 'mt' . 'LINE' = 'CHANGER' mt 'LINEAIRE' ;
tabgeo . 'mt' . 'LINC' =  'DOMA'
  ('MODELISER' _mt 'NAVIER_STOKES' 'QUAF') 'FACE' ;
tabgeo . 'mt' . 'CSTE' = tabgeo . 'mt' . 'LINM' ;
tabgeo . 'bot' = 'TABLE' ;
tabgeo . 'bot' . 'QUAF' = _bot ;
tabgeo . 'bot' . 'QUAD' = _bot ;
tabgeo . 'bot' . 'QUAI' = bot ;
tabgeo . 'bot' . 'LINE' = 'CHANGER' bot 'LINEAIRE' ;
tabgeo . 'bot' . 'LINC' =  'DOMA'
  ('MODELISER' _bot 'NAVIER_STOKES' 'QUAF') 'CENTRE' ;
tabgeo . 'sph' = 'TABLE' ;
tabgeo . 'sph' . 'QUAF' = _sph ;
tabgeo . 'sph' . 'QUAD' = _sph ;
tabgeo . 'sph' . 'QUAI' = sph ;
tabgeo . 'sph' . 'LINE' = 'CHANGER' sph 'LINEAIRE' ;
tabgeo . 'sph' . 'LINC' =  'DOMA'
  ('MODELISER' _sph 'NAVIER_STOKES' 'QUAF') 'CENTRE' ;
tabgeo . 'emt' = 'TABLE' ;
tabgeo . 'emt' . 'QUAF' = _emt ;
tabgeo . 'emt' . 'QUAD' = _emt ;
tabgeo . 'emt' . 'QUAI' = emt ;
tabgeo . 'emt' . 'LINE' = 'CHANGER' emt 'LINEAIRE' ;
tabgeo . 'emt' . 'LINC' =  'DOMA'
  ('MODELISER' _emt 'NAVIER_STOKES' 'QUAF') 'CENTRE' ;
'RESPRO' tabgeo ;
*
* End of procedure file CMAIL3D
*
'FINPROC' ;
*ENDPROCEDUR cmail3d
*BEGINPROCEDUR solex
************************************************************************
* NOM         : SOLEX
* DESCRIPTION : Solution exacte de l'équation de Stokes
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 04/10/2006, version initiale
* HISTORIQUE : v1, 04/10/2006, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' SOLEX ;
'ARGUMENT' mail*'MAILLAGE' ;
vdim = 'VALEUR' 'DIME' ;
vmod = 'VALEUR' 'MODE' ;
'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'AXIS')) ;
   rho z = 'COORDONNEE' mail ;
   r = '**' ('+' ('**' rho 2) ('**' z 2)) 0.5 ;
   cphi = '/' z r ;
   sphi = '/' rho r ;
   unsr = 'INVERSE' r ;
   unsr3 = '**' unsr 3 ;
   vrho = cphi '*' sphi '*' ('-' ('*' unsr 0.75) ('*' unsr3 0.75)) ;
   vz   = '+' ('*' ('**' cphi 2) ('-' ('*' unsr 1.5) ('*' unsr3 0.5)))
           ('*' ('**' sphi 2) ('+' ('*' unsr 0.75) ('*' unsr3 0.25))) ;
   solv = '+' ('NOMC' 'UR' vrho) ('NOMC' 'UZ' vz) ;
'FINSI' ;
'SI' ('EGA' vdim 3) ;
   x y z = 'COORDONNEE' mail ;
   r2    = ('**' x 2) '+' ('**' y 2) '+' ('**' z 2) ;
   rho2  = ('**' x 2) '+' ('**' y 2) ;
   r     = '**' r2 0.5 ;
   unsr = 'INVERSE' r ;
   unsr2 = 'INVERSE' r2 ;
   unsr3 = '**' unsr 3 ;
   alpha = '-' ('*' unsr 1.5) ('*' unsr3 0.5) ;
   beta  = '+' ('*' unsr 0.75) ('*' unsr3 0.25) ;
   amb   = '-' alpha beta ;
   vx    = amb '*' x '*' z '*' unsr2 ;
   vy    = amb '*' y '*' z '*' unsr2 ;
   vz    = ('+' (alpha '*' z '*' z)
                (beta  '*' rho2)) '*' unsr2 ;
   solv = ('NOMC' 'UX' vx) '+' ('NOMC' 'UY' vy) '+' ('NOMC' 'UZ' vz) ;
'FINSI' ;
'RESPRO' solv ;
*
* End of procedure file SOLEX
*
'FINPROC' ;
*ENDPROCEDUR solex
*BEGINPROCEDUR gmass
************************************************************************
* NOM         : GMASS
* DESCRIPTION : Une matrice de masse
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v2, 14/03/2006, mise à jour NLIN évolué
* VERSION    : v1, 13/05/2004, version initiale
* HISTORIQUE : v1, 13/05/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' GMASS ;
'ARGUMENT'     _mt*'MAILLAGE' ;
'ARGUMENT'     _smt/'MAILLAGE' ;
'ARGUMENT'   gdisc*'MOT     ' ;
'ARGUMENT'    nomt*'MOT     ' ;
'ARGUMENT'   disct*'MOT     ' ;
'ARGUMENT'    nomq*'MOT     ' ;
'ARGUMENT'   discq*'MOT     ' ;
'ARGUMENT' coef/'FLOTTANT' ;
   'SI' ('NON' ('EXISTE' coef)) ;
      'ARGUMENT' coef2/'CHPOINT ' ;
      'SI' ('NON' ('EXISTE' coef2)) ;
         'ERREUR' 'Il faut donner un coef FLOTTANT ou CHPOINT' ;
      'SINON' ;
         coef = coef2 ;
         'ARGUMENT' discc*'MOT     ' ;
      'FINSI' ;
   'SINON' ;
      discc = 'CSTE' ;
   'FINSI' ;
'ARGUMENT' methgau/'MOT     ' ;
   'SI' ('NON' ('EXISTE' methgau)) ;
      methgau = 'GAU7' ;
   'FINSI' ;
'ARGUMENT' chpop/'CHPOINT' ;
'ARGUMENT' chpod/'CHPOINT' ;
*
   vdim = 'VALEUR' 'DIME' ;
   vmod = 'VALEUR' 'MODE' ;
   idim = 0 ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'PLANDEFO')) ;
      idim = 2 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'AXIS')) ;
      idim = 2 ;
      iaxi = VRAI ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 3) ('EGA' vmod 'TRID')) ;
      idim = 3 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' vdim 1) ;
      idim = 1 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' idim 0) ;
      'ERREUR' ('CHAINE' 'vmod=' vmod ' et vdim=' vdim ' non prevu') ;
   'FINSI' ;
   'SI' iaxi ;
      dprmt = '*' ('COORDONNEE' 1 _mt) ('*' PI 2.D0) ;
   'FINSI' ;
   numop  = 1 ;
   numder = idim ;
   mmt = 'MOTS' nomt ;
   mmq = 'MOTS' nomq ;
   numvar = 1 ;
   numdat = 1 ;
   numcof = 1 ;
*
   A = ININLIN numop numvar numdat numcof numder ;
   A . 'VAR' . 1 . 'NOMDDL' = mmt ;
   A . 'VAR' . 1 . 'DISC'   = disct ;
   'SI' ('EXISTE' chpop) ;
      A . 'VAR' . 1 . 'VALEUR'   = chpop ;
   'FINSI' ;
   A . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
   A . 'DAT' . 1 . 'DISC'   = discc ;
   A . 'DAT' . 1 . 'VALEUR' = coef ;
   A . 'COF' . 1 . 'COMPOR' = 'IDEN' ;
   A . 'COF' . 1 . 'LDAT'   = 'LECT' 1 ;
*
   A . 1 . 1 . 0 = 'LECT' 1 ;
*
   'SI' iaxi ;
      numdat = 1 ;
      numcof = 1 ;
   'SINON' ;
      numdat = 0 ;
      numcof = 0 ;
   'FINSI' ;
   B = ININLIN numop numvar numdat numcof numder ;
   B . 'VAR' . 1 . 'NOMDDL' = mmq ;
   B . 'VAR' . 1 . 'DISC'   = discq ;
   'SI' ('EXISTE' chpod) ;
      B . 'VAR' . 1 . 'VALEUR'   = chpod ;
   'FINSI' ;
*
   'SI' iaxi ;
      B . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
      B . 'DAT' . 1 . 'DISC'   = gdisc ;
      B . 'DAT' . 1 . 'VALEUR' = dprmt ;
      B . 'COF' . 1 . 'COMPOR' = 'IDEN' ;
      B . 'COF' . 1 . 'LDAT'   = 'LECT' 1 ;
   'FINSI' ;
   'SI' iaxi ;
      B . 1 . 1 . 0 = 'LECT' 1 ;
   'SINON' ;
      B . 1 . 1 . 0 = 'LECT' ;
   'FINSI' ;
*
   'SI' ('EXISTE' _smt) ;
       mgmass = 'NLIN' gdisc _mt _smt A B methgau ;
   'SINON' ;
       mgmass = 'NLIN' gdisc _mt A B methgau ;
   'FINSI' ;
*
'RESPRO' mgmass ;
'FINPROC' ;
*
* End of procedure file GMASS
*
*ENDPROCEDUR gmass
*BEGINPROCEDUR gmasp
************************************************************************
* NOM         : GMASP
* DESCRIPTION : Une matrice de masse
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v2, 14/03/2006, mise à jour NLIN évolué
* VERSION    : v1, 13/05/2004, version initiale
* HISTORIQUE : v1, 13/05/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' GMASP ;
'ARGUMENT'     _mt*'MAILLAGE' ;
'ARGUMENT'     _smt/'MAILLAGE' ;
'ARGUMENT'   gdisc*'MOT     ' ;
'ARGUMENT'    nomt*'LISTMOTS' ;
'ARGUMENT'   disct*'MOT     ' ;
'ARGUMENT'    nomq*'LISTMOTS' ;
'ARGUMENT'   discq*'MOT     ' ;
'ARGUMENT' coef/'FLOTTANT' ;
   'SI' ('NON' ('EXISTE' coef)) ;
      'ARGUMENT' coef2/'CHPOINT ' ;
      'SI' ('NON' ('EXISTE' coef2)) ;
         'ERREUR' 'Il faut donner un coef FLOTTANT ou CHPOINT' ;
      'SINON' ;
         coef = coef2 ;
         'ARGUMENT' discc*'MOT     ' ;
      'FINSI' ;
   'SINON' ;
      discc = 'CSTE' ;
   'FINSI' ;
'ARGUMENT' methgau/'MOT     ' ;
   'SI' ('NON' ('EXISTE' methgau)) ;
      methgau = 'GAU7' ;
   'FINSI' ;
'ARGUMENT' chpop/'CHPOINT' ;
'ARGUMENT' chpod/'CHPOINT' ;
*
   vdim = 'VALEUR' 'DIME' ;
   vmod = 'VALEUR' 'MODE' ;
   idim = 0 ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'PLANDEFO')) ;
      idim = 2 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'AXIS')) ;
      idim = 2 ;
      iaxi = VRAI ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 3) ('EGA' vmod 'TRID')) ;
      idim = 3 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' vdim 1) ;
      idim = 1 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' idim 0) ;
      'ERREUR' ('CHAINE' 'vmod=' vmod ' et vdim=' vdim ' non prevu') ;
   'FINSI' ;
   'SI' iaxi ;
      dprmt = '*' ('COORDONNEE' 1 _mt) ('*' PI 2.D0) ;
   'FINSI' ;
   numop  = 1 ;
   numder = idim ;
   mmt = nomt ;
   mmq = nomq ;
   numvar = 1 ;
   numdat = 1 ;
   numcof = 1 ;
*
   A = ININLIN numop numvar numdat numcof numder ;
   A . 'VAR' . 1 . 'NOMDDL' = mmt ;
   A . 'VAR' . 1 . 'DISC'   = disct ;
   'SI' ('EXISTE' chpop) ;
      A . 'VAR' . 1 . 'VALEUR'   = chpop ;
   'FINSI' ;
   A . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
   A . 'DAT' . 1 . 'DISC'   = discc ;
   A . 'DAT' . 1 . 'VALEUR' = coef ;
   A . 'COF' . 1 . 'COMPOR' = 'IDEN' ;
   A . 'COF' . 1 . 'LDAT'   = 'LECT' 1 ;
*
   A . 1 . 1 . 0 = 'LECT' 1 ;
*
   'SI' iaxi ;
      numdat = 1 ;
      numcof = 1 ;
   'SINON' ;
      numdat = 0 ;
      numcof = 0 ;
   'FINSI' ;
   B = ININLIN numop numvar numdat numcof numder ;
   B . 'VAR' . 1 . 'NOMDDL' = mmq ;
   B . 'VAR' . 1 . 'DISC'   = discq ;
   'SI' ('EXISTE' chpod) ;
      B . 'VAR' . 1 . 'VALEUR'   = chpod ;
   'FINSI' ;
*
   'SI' iaxi ;
      B . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
      B . 'DAT' . 1 . 'DISC'   = gdisc ;
      B . 'DAT' . 1 . 'VALEUR' = dprmt ;
      B . 'COF' . 1 . 'COMPOR' = 'IDEN' ;
      B . 'COF' . 1 . 'LDAT'   = 'LECT' 1 ;
   'FINSI' ;
   'SI' iaxi ;
      B . 1 . 1 . 0 = 'LECT' 1 ;
   'SINON' ;
      B . 1 . 1 . 0 = 'LECT' ;
   'FINSI' ;
*
   'SI' ('EXISTE' _smt) ;
       mgmasp = 'NLIN' gdisc _mt _smt A B methgau ;
   'SINON' ;
       mgmasp = 'NLIN' gdisc _mt A B methgau ;
   'FINSI' ;
*
'RESPRO' mgmasp ;
'FINPROC' ;
*
* End of procedure file GMASP
*
*ENDPROCEDUR gmasp
*BEGINPROCEDUR grig
************************************************************************
* NOM         : GRIG
* DESCRIPTION : Matrice de rigidité axisymétrique
*               sous forme (gradu . gradv)
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 13/05/2004, version initiale
* HISTORIQUE : v1, 13/05/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' GRIG ;
'ARGUMENT'     _mt*'MAILLAGE' ;
'ARGUMENT'   gdisc*'MOT     ' ;
'ARGUMENT'   discv*'MOT     ' ;
'ARGUMENT'   lvp*'LISTMOTS' ;
'ARGUMENT'   lvd*'LISTMOTS' ;
'ARGUMENT' coef/'FLOTTANT' ;
'SI' ('NON' ('EXISTE' coef)) ;
   'ARGUMENT' coef2/'CHPOINT ' ;
   'SI' ('NON' ('EXISTE' coef2)) ;
      'ERREUR' 'Il faut donner un coef FLOTTANT ou CHPOINT' ;
   'SINON' ;
      coef = coef2 ;
      'ARGUMENT' discc*'MOT     ' ;
   'FINSI' ;
'SINON' ;
   discc = 'CSTE' ;
'FINSI' ;
'ARGUMENT' methgau/'MOT     ' ;
'SI' ('NON' ('EXISTE' methgau)) ;
    methgau = 'GAU7' ;
'FINSI' ;
'ARGUMENT' chpop/'CHPOINT' ;
'ARGUMENT' chpod/'CHPOINT' ;
*
   vdim = 'VALEUR' 'DIME' ;
   vmod = 'VALEUR' 'MODE' ;
   idim = 0 ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'PLANDEFO')) ;
      idim = 2 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'AXIS')) ;
      idim = 2 ;
      iaxi = VRAI ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 3) ('EGA' vmod 'TRID')) ;
      idim = 3 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' vdim 1) ;
      idim = 1 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' idim 0) ;
      'ERREUR' ('CHAINE' 'vmod=' vmod ' et vdim=' vdim ' non prevu') ;
   'FINSI' ;
   'SI' iaxi ;
      rmt = 'COORDONNEE' 1 _mt ;
      deupi = ('*' PI 2.D0) ;
   'FINSI' ;
* Test bête...
   'SI' ('EGA' ('TYPE' coef) 'CHPOINT ') ;
      mincoef = 'MINIMUM' coef ;
   'SINON' ;
      mincoef = coef ;
   'FINSI' ;
   'SI' ('<' mincoef 0.D0) ;
      'ERREUR' 'Le coef (une viscosité) doit etre positive' ;
   'FINSI' ;
*
'SI' iaxi ;
   numop  = 5 ;
   numder = idim ;
   numvar = 2 ;
   numdat = 2 ;
   numcof = 2 ;
*
   A = ININLIN numop numvar numdat numcof numder ;
   'REPETER' iidim idim ;
      lnom = 'EXTRAIRE' lvp &iidim ;
      A . 'VAR' . &iidim . 'NOMDDL' = 'MOTS' lnom ;
      A . 'VAR' . &iidim . 'DISC'   = discv ;
      'SI' ('EXISTE' chpop) ;
         A . 'VAR' . &iidim . 'VALEUR'  = 'EXCO' lnom chpop lnom ;
      'FINSI' ;
   'FIN' iidim ;
*
   A . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
   A . 'DAT' . 1 . 'DISC'   = gdisc ;
   A . 'DAT' . 1 . 'VALEUR' = rmt ;
   A . 'DAT' . 2 . 'NOMDDL' = 'MOTS' 'SCAL' ;
   A . 'DAT' . 2 . 'DISC'   = discc ;
   A . 'DAT' . 2 . 'VALEUR' = coef ;
   A . 'COF' . 1 . 'COMPOR' = 'IDEN' ;
   A . 'COF' . 1 . 'LDAT'   = 'LECT' 1 ;
   A . 'COF' . 2 . 'COMPOR' = 'IDEN' ;
   A . 'COF' . 2 . 'LDAT'   = 'LECT' 2 ;
*
   A . 1 . 1 . 1 = 'LECT' 2 ;
   A . 2 . 1 . 2 = 'LECT' 2 ;
   A . 3 . 1 . 0 = 'LECT' -1 2 ;
   A . 4 . 2 . 1 = 'LECT' 2 ;
   A . 5 . 2 . 2 = 'LECT' 2 ;
*
   numdat = 2 ;
   numcof = 2 ;
*
   B = ININLIN numop numvar numdat numcof numder ;
   'REPETER' iidim idim ;
      lnom = 'EXTRAIRE' lvd &iidim ;
      B . 'VAR' . &iidim . 'NOMDDL' = 'MOTS' lnom ;
      B . 'VAR' . &iidim . 'DISC'   = discv ;
      'SI' ('EXISTE' chpod) ;
         B . 'VAR' . &iidim . 'VALEUR'  = 'EXCO' lnom chpod lnom ;
      'FINSI' ;
   'FIN' iidim ;
*
   B . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
   B . 'DAT' . 1 . 'DISC'   = gdisc ;
   B . 'DAT' . 1 . 'VALEUR' = rmt ;
   B . 'DAT' . 2 . 'NOMDDL' = 'MOTS' 'SCAL' ;
   B . 'DAT' . 2 . 'DISC'   = 'CSTE' ;
   B . 'DAT' . 2 . 'VALEUR' = deupi ;
   B . 'COF' . 1 . 'COMPOR' = 'IDEN' ;
   B . 'COF' . 1 . 'LDAT'   = 'LECT' 1 ;
   B . 'COF' . 2 . 'COMPOR' = 'IDEN' ;
   B . 'COF' . 2 . 'LDAT'   = 'LECT' 2 ;
*
   B . 1 . 1 . 1 = 'LECT' 1 2 ;
   B . 2 . 1 . 2 = 'LECT' 1 2 ;
   B . 3 . 1 . 0 = 'LECT' 2 ;
   B . 4 . 2 . 1 = 'LECT' 1 2 ;
   B . 5 . 2 . 2 = 'LECT' 1 2 ;
'SINON' ;
   numop  = '**' idim 2 ;
*!   numop  = idim ;
   numder = idim ;
   numvar = idim ;
   numdat = 1 ;
   numcof = 1 ;
*
   A = ININLIN numop numvar numdat numcof numder ;
   'REPETER' iidim idim ;
      lnom = 'EXTRAIRE' lvp &iidim ;
      A . 'VAR' . &iidim . 'NOMDDL' = 'MOTS' lnom ;
      A . 'VAR' . &iidim . 'DISC'   = discv ;
      'SI' ('EXISTE' chpop) ;
         A . 'VAR' . &iidim . 'VALEUR'  = 'EXCO' lnom chpop lnom ;
      'FINSI' ;
   'FIN' iidim ;
*
   A . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
   A . 'DAT' . 1 . 'DISC'   = discc ;
   A . 'DAT' . 1 . 'VALEUR' = coef ;
*
   A . 'COF' . 1 . 'COMPOR' = 'IDEN' ;
   A . 'COF' . 1 . 'LDAT'   = 'LECT' 1 ;
*
   iop = 0 ;
   'REPETER' iidim idim ;
*   'REPETER' iidim 1 ;
      'REPETER' jidim idim ;
         iop = '+' iop 1 ;
         A . iop . &iidim . &jidim = 'LECT' 1 ;
      'FIN' jidim ;
   'FIN' iidim ;
*
   numdat = 0 ;
   numcof = 0 ;
*
   B = ININLIN numop numvar numdat numcof numder ;
   'REPETER' iidim idim ;
      lnom = 'EXTRAIRE' lvd &iidim ;
      B . 'VAR' . &iidim . 'NOMDDL' = 'MOTS' lnom ;
      B . 'VAR' . &iidim . 'DISC'   = discv ;
      'SI' ('EXISTE' chpod) ;
         B . 'VAR' . &iidim . 'VALEUR'  = 'EXCO' lnom chpod lnom ;
      'FINSI' ;
   'FIN' iidim ;
*
   iop = 0 ;
   'REPETER' iidim idim ;
*!   'REPETER' iidim 1 ;
      'REPETER' jidim idim ;
         iop = '+' iop 1 ;
         B . iop . &iidim . &jidim = 'LECT' ;
      'FIN' jidim ;
   'FIN' iidim ;
'FINSI' ;
*
   mgrig = 'NLIN' gdisc _mt A B methgau ;
* Integration par parties
   mgrig = '*' mgrig -1.D0 ;
*
'RESPRO' mgrig ;
'FINPROC' ;
*
* End of procedure file GRIG
*
*ENDPROCEDUR grig
*BEGINPROCEDUR grig2
************************************************************************
* NOM         : GRIG2
* DESCRIPTION : Additif à la matrice de rigidité axisymétrique
*               de forme (tgradu . gradv)
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 13/05/2004, version initiale
* HISTORIQUE : v1, 13/05/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' GRIG2 ;
'ARGUMENT'     _mt*'MAILLAGE' ;
'ARGUMENT'   gdisc*'MOT     ' ;
'ARGUMENT'   discv*'MOT     ' ;
'ARGUMENT'   lvp*'LISTMOTS' ;
'ARGUMENT'   lvd*'LISTMOTS' ;
'ARGUMENT' methgau/'MOT     ' ;
'SI' ('NON' ('EXISTE' methgau)) ;
    methgau = 'GAU7' ;
'FINSI' ;
*
   vdim = 'VALEUR' 'DIME' ;
   vmod = 'VALEUR' 'MODE' ;
   idim = 0 ;
*   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'PLANDEFO')) ;
*      idim = 2 ;
*      iaxi = FAUX ;
*   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'AXIS')) ;
      idim = 2 ;
      iaxi = VRAI ;
   'FINSI' ;
*   'SI' ('ET' ('EGA' vdim 3) ('EGA' vmod 'TRID')) ;
*      idim = 3 ;
*      iaxi = FAUX ;
**      vcomp = 'MOTS' 'UX' 'UY' 'UZ' ;
*   'FINSI' ;
*   'SI' ('EGA' vdim 1) ;
*      idim = 1 ;
*      iaxi = FAUX ;
*   'FINSI' ;
   'SI' ('EGA' idim 0) ;
      'ERREUR' ('CHAINE' 'vmod=' vmod ' et vdim=' vdim ' non prevu') ;
   'FINSI' ;
   'SI' iaxi ;
      rmt = 'COORDONNEE' 1 _mt ;
      deupi = ('*' PI 2.D0) ;
   'FINSI' ;
*
   numop  = 5 ;
   numder = idim ;
   numvar = 2 ;
   numdat = 1 ;
   numcof = 1 ;
*
   A = ININLIN numop numvar numdat numcof numder ;
   'REPETER' iidim idim ;
      A . 'VAR' . &iidim . 'NOMDDL' = 'MOTS' ('EXTRAIRE' lvp &iidim) ;
      A . 'VAR' . &iidim . 'DISC'   = discv ;
   'FIN' iidim ;
*
   A . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
   A . 'DAT' . 1 . 'DISC'   = gdisc ;
   A . 'DAT' . 1 . 'VALEUR' = rmt ;
   A . 'COF' . 1 . 'COMPOR' = 'IDEN' ;
   A . 'COF' . 1 . 'LDAT'   = 'LECT' 1 ;
*
   A . 1 . 1 . 1 = 'LECT' ;
   A . 2 . 2 . 1 = 'LECT' ;
   A . 3 . 1 . 0 = 'LECT' -1 ;
   A . 4 . 1 . 2 = 'LECT' ;
   A . 5 . 2 . 2 = 'LECT' ;
*
   numdat = 2 ;
   numcof = 2 ;
*
   B = ININLIN numop numvar numdat numcof numder ;
   'REPETER' iidim idim ;
      B . 'VAR' . &iidim . 'NOMDDL' = 'MOTS' ('EXTRAIRE' lvd &iidim) ;
      B . 'VAR' . &iidim . 'DISC'   = discv ;
   'FIN' iidim ;
*
   B . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
   B . 'DAT' . 1 . 'DISC'   = gdisc ;
   B . 'DAT' . 1 . 'VALEUR' = rmt ;
   B . 'DAT' . 2 . 'NOMDDL' = 'MOTS' 'SCAL' ;
   B . 'DAT' . 2 . 'DISC'   = 'CSTE' ;
   B . 'DAT' . 2 . 'VALEUR' = deupi ;
   B . 'COF' . 1 . 'COMPOR' = 'IDEN' ;
   B . 'COF' . 1 . 'LDAT'   = 'LECT' 1 ;
   B . 'COF' . 2 . 'COMPOR' = 'IDEN' ;
   B . 'COF' . 2 . 'LDAT'   = 'LECT' 2 ;
*
   B . 1 . 1 . 1 = 'LECT' 1 2 ;
   B . 2 . 1 . 2 = 'LECT' 1 2 ;
   B . 3 . 1 . 0 = 'LECT' 2 ;
   B . 4 . 2 . 1 = 'LECT' 1 2 ;
   B . 5 . 2 . 2 = 'LECT' 1 2 ;
*
   mgrig = 'NLIN' gdisc _mt A B methgau ;
* Integration par parties
   mgrig = '*' mgrig -1.D0 ;
*
'RESPRO' mgrig ;
'FINPROC' ;
*
* End of procedure file GRIG2
*
*ENDPROCEDUR grig2
*BEGINPROCEDUR grig3
************************************************************************
* NOM         : GRIG3
* DESCRIPTION : Additif à la matrice de rigidité axisymétrique
*               de forme (div u . div v)
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 13/05/2004, version initiale
* HISTORIQUE : v1, 13/05/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' GRIG3 ;
'ARGUMENT'     _mt*'MAILLAGE' ;
'ARGUMENT'   gdisc*'MOT     ' ;
'ARGUMENT'   discv*'MOT     ' ;
'ARGUMENT'   lvp*'LISTMOTS' ;
'ARGUMENT'   lvd*'LISTMOTS' ;
'ARGUMENT' methgau/'MOT     ' ;
'SI' ('NON' ('EXISTE' methgau)) ;
    methgau = 'GAU7' ;
'FINSI' ;
*
   vdim = 'VALEUR' 'DIME' ;
   vmod = 'VALEUR' 'MODE' ;
   idim = 0 ;
*   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'PLANDEFO')) ;
*      idim = 2 ;
*      iaxi = FAUX ;
*   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'AXIS')) ;
      idim = 2 ;
      iaxi = VRAI ;
   'FINSI' ;
*   'SI' ('ET' ('EGA' vdim 3) ('EGA' vmod 'TRID')) ;
*      idim = 3 ;
*      iaxi = FAUX ;
**      vcomp = 'MOTS' 'UX' 'UY' 'UZ' ;
*   'FINSI' ;
*   'SI' ('EGA' vdim 1) ;
*      idim = 1 ;
*      iaxi = FAUX ;
*   'FINSI' ;
   'SI' ('EGA' idim 0) ;
      'ERREUR' ('CHAINE' 'vmod=' vmod ' et vdim=' vdim ' non prevu') ;
   'FINSI' ;
   'SI' iaxi ;
      rmt = 'COORDONNEE' 1 _mt ;
      deupi = ('*' PI 2.D0) ;
   'FINSI' ;
*
   numop  = 1 ;
   numder = idim ;
   numvar = 2 ;
   numdat = 1 ;
   numcof = 1 ;
*
   A = ININLIN numop numvar numdat numcof numder ;
   'REPETER' iidim idim ;
      A . 'VAR' . &iidim . 'NOMDDL' = 'MOTS' ('EXTRAIRE' lvp &iidim) ;
      A . 'VAR' . &iidim . 'DISC'   = discv ;
   'FIN' iidim ;
*
   A . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
   A . 'DAT' . 1 . 'DISC'   = gdisc ;
   A . 'DAT' . 1 . 'VALEUR' = rmt ;
   A . 'COF' . 1 . 'COMPOR' = 'IDEN' ;
   A . 'COF' . 1 . 'LDAT'   = 'LECT' 1 ;
*
   A . 1 . 1 . 0 = 'LECT' -1 ;
   A . 1 . 1 . 1 = 'LECT' ;
   A . 1 . 2 . 2 = 'LECT' ;
*
   numdat = 2 ;
   numcof = 2 ;
*
   B = ININLIN numop numvar numdat numcof numder ;
   'REPETER' iidim idim ;
      B . 'VAR' . &iidim . 'NOMDDL' = 'MOTS' ('EXTRAIRE' lvd &iidim) ;
      B . 'VAR' . &iidim . 'DISC'   = discv ;
   'FIN' iidim ;
*
   B . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
   B . 'DAT' . 1 . 'DISC'   = gdisc ;
   B . 'DAT' . 1 . 'VALEUR' = rmt ;
   B . 'DAT' . 2 . 'NOMDDL' = 'MOTS' 'SCAL' ;
   B . 'DAT' . 2 . 'DISC'   = 'CSTE' ;
   B . 'DAT' . 2 . 'VALEUR' = deupi ;
   B . 'COF' . 1 . 'COMPOR' = 'IDEN' ;
   B . 'COF' . 1 . 'LDAT'   = 'LECT' 1 ;
   B . 'COF' . 2 . 'COMPOR' = 'IDEN' ;
   B . 'COF' . 2 . 'LDAT'   = 'LECT' 2 ;
*
   B . 1 . 1 . 0 = 'LECT' 2 ;
   B . 1 . 1 . 1 = 'LECT' 1 2 ;
   B . 1 . 2 . 2 = 'LECT' 1 2 ;
*
   mgrig = 'NLIN' gdisc _mt A B methgau ;
* Integration par parties
   mgrig = '*' mgrig -1.D0 ;
*
'RESPRO' mgrig ;
'FINPROC' ;
*
* End of procedure file GRIG3
*
*ENDPROCEDUR grig3
*BEGINPROCEDUR gbbt2
************************************************************************
* NOM         : GBBT2
* DESCRIPTION : Copie de GBBT
*               Version customisée pour la sphère
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 05/10/2006, version initiale
* HISTORIQUE : v1, 05/10/2006, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' GBBT2 ;
'ARGUMENT'     _mt*'MAILLAGE' ;
'ARGUMENT'   gdisc*'MOT     ' ;
'ARGUMENT'   discv*'MOT     ' ;
'ARGUMENT'   lvp*'LISTMOTS' ;
'ARGUMENT'   lvd*'LISTMOTS' ;
'ARGUMENT'   discp*'MOT     ' ;
'ARGUMENT'   lpp*'LISTMOTS' ;
'ARGUMENT'   lpd*'LISTMOTS' ;
'ARGUMENT' coef/'FLOTTANT' ;
   'SI' ('NON' ('EXISTE' coef)) ;
      'ARGUMENT' coef2/'CHPOINT ' ;
      'SI' ('NON' ('EXISTE' coef2)) ;
         'ERREUR' 'Il faut donner un coef FLOTTANT ou CHPOINT' ;
      'SINON' ;
         coef = coef2 ;
         'ARGUMENT' discc*'MOT     ' ;
      'FINSI' ;
   'SINON' ;
      discc = 'CSTE' ;
   'FINSI' ;
'ARGUMENT' methgau/'MOT     ' ;
   'SI' ('NON' ('EXISTE' methgau)) ;
      methgau = 'GAU7' ;
   'FINSI' ;
*
   vdim = 'VALEUR' 'DIME' ;
   vmod = 'VALEUR' 'MODE' ;
   idim = 0 ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'PLANDEFO')) ;
      idim = 2 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 2) ('EGA' vmod 'AXIS')) ;
      idim = 2 ;
      iaxi = VRAI ;
   'FINSI' ;
   'SI' ('ET' ('EGA' vdim 3) ('EGA' vmod 'TRID')) ;
      idim = 3 ;
      iaxi = FAUX ;
   'FINSI' ;
   'SI' ('EGA' idim 0) ;
      'ERREUR' ('CHAINE' 'vmod=' vmod ' et vdim=' vdim ' non prevu') ;
   'FINSI' ;
   'SI' iaxi ;
      dp = ('*' PI 2.D0) ;
      rmt = 'COORDONNEE' 1 _mt ;
   'FINSI' ;
*
   numop  = 2 ;
   numder = idim ;
   mmp = 'MOTS' nomp ;
   idim1 = '+' idim 1 ;
   numvar = idim1 ;
   'SI' iaxi ;
      numdat = 3 ;
      numcof = 3 ;
   'SINON' ;
      numdat = 1 ;
      numcof = 1 ;
   'FINSI' ;
*
   A = ININLIN numop numvar numdat numcof numder ;
   'REPETER' iidim idim ;
      A . 'VAR' . &iidim . 'NOMDDL' = 'MOTS' ('EXTRAIRE' lvp &iidim) ;
      A . 'VAR' . &iidim . 'DISC'   = discv ;
   'FIN' iidim ;
   A . 'VAR' . idim1 . 'NOMDDL' = lpp ;
   A . 'VAR' . idim1 . 'DISC'   = discp ;
   A . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
   A . 'DAT' . 1 . 'DISC'   = discc ;
   A . 'DAT' . 1 . 'VALEUR' = coef ;
   A . 'COF' . 1 . 'COMPOR' = 'IDEN' ;
   A . 'COF' . 1 . 'LDAT'   = 'LECT' 1 ;
*
   'SI' iaxi ;
      A . 'DAT' . 2 . 'NOMDDL' = 'MOTS' 'SCAL' ;
      A . 'DAT' . 2 . 'DISC'   = 'CSTE' ;
      A . 'DAT' . 2 . 'VALEUR' = dp ;
      A . 'COF' . 2 . 'COMPOR' = 'IDEN' ;
      A . 'COF' . 2 . 'LDAT'   = 'LECT' 2 ;
      A . 'DAT' . 3 . 'NOMDDL' = 'MOTS' 'SCAL' ;
      A . 'DAT' . 3 . 'DISC'   = gdisc ;
      A . 'DAT' . 3 . 'VALEUR' = rmt ;
      A . 'COF' . 3 . 'COMPOR' = 'IDEN' ;
      A . 'COF' . 3 . 'LDAT'   = 'LECT' 3 ;
   'FINSI' ;
*
   'SI' iaxi ;
      'REPETER' iidim idim ;
         A . 1 . &iidim . &iidim  = 'LECT' 1 2 3 ;
      'FIN' iidim ;
      A . 1 . 1 . 0 = 'LECT' 1 2 ;
   'SINON' ;
      'REPETER' iidim idim ;
         A . 1 . &iidim . &iidim  = 'LECT' 1 ;
      'FIN' iidim ;
   'FINSI' ;
   A . 2 . idim1 . 0 = 'LECT' ;
*
   'SI' iaxi ;
      numdat = 3 ;
      numcof = 3 ;
   'SINON' ;
      numdat = 1 ;
      numcof = 1 ;
   'FINSI' ;
   B = ININLIN numop numvar numdat numcof numder ;
   'REPETER' iidim idim ;
      B . 'VAR' . &iidim . 'NOMDDL' = 'MOTS' ('EXTRAIRE' lvd &iidim) ;
      B . 'VAR' . &iidim . 'DISC'   = discv ;
   'FIN' iidim ;
   B . 'VAR' . idim1 . 'NOMDDL' = lpd ;
   B . 'VAR' . idim1 . 'DISC'   = discp ;
   B . 'DAT' . 1 . 'NOMDDL' = 'MOTS' 'SCAL' ;
   B . 'DAT' . 1 . 'DISC'   = discc ;
   B . 'DAT' . 1 . 'VALEUR' = coef ;
   B . 'COF' . 1 . 'COMPOR' = 'IDEN' ;
   B . 'COF' . 1 . 'LDAT'   = 'LECT' 1 ;
*
   'SI' iaxi ;
      B . 'DAT' . 2 . 'NOMDDL' = 'MOTS' 'SCAL' ;
      B . 'DAT' . 2 . 'DISC'   = 'CSTE' ;
      B . 'DAT' . 2 . 'VALEUR' = dp ;
      B . 'COF' . 2 . 'COMPOR' = 'IDEN' ;
      B . 'COF' . 2 . 'LDAT'   = 'LECT' 2 ;
      B . 'DAT' . 3 . 'NOMDDL' = 'MOTS' 'SCAL' ;
      B . 'DAT' . 3 . 'DISC'   = gdisc ;
      B . 'DAT' . 3 . 'VALEUR' = rmt ;
      B . 'COF' . 3 . 'COMPOR' = 'IDEN' ;
      B . 'COF' . 3 . 'LDAT'   = 'LECT' 3 ;
   'FINSI' ;
*
   'SI' iaxi ;
      'REPETER' iidim idim ;
         B . 2 . &iidim . &iidim  = 'LECT' 1 2 3 ;
      'FIN' iidim ;
      B . 2 . 1 . 0 = 'LECT' 1 2 ;
   'SINON' ;
      'REPETER' iidim idim ;
         B . 2 . &iidim . &iidim  = 'LECT' 1 ;
      'FIN' iidim ;
   'FINSI' ;
   B . 1 . idim1 . 0 = 'LECT' ;
*
   mgbbt2 = 'NLIN' gdisc _mt A B methgau ;
*
'RESPRO' mgbbt2 ;
'FINPROC' ;
*
* End of procedure file GBBT2
*
*ENDPROCEDUR gbbt2
*BEGINPROCEDUR log10
************************************************************************
* NOM         : LOG10
* DESCRIPTION : Log_10
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 18/02/2003, version initiale
* HISTORIQUE : v1, 18/02/2003, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' LOG10 ;
'REPETER' bouc ;
   ok = FAUX ;
   'ARGUMENT' fl/'FLOTTANT' ;
   'ARGUMENT' lr/'LISTREEL' ;
   'ARGUMENT' cp/'CHPOINT ' ;
   'ARGUMENT' cm/'MCHAML  ' ;
   'SI' ('EXISTE' fl) ;
      ok = VRAI ;
      'RESPRO' ('/' ('LOG' fl) ('LOG' 10.D0)) ;
   'FINSI' ;
   'SI' ('EXISTE' lr) ;
      ok = VRAI ;
      'RESPRO' ('/' ('LOG' lr) ('LOG' 10.D0)) ;
   'FINSI' ;
   'SI' ('EXISTE' cp) ;
      ok = VRAI ;
      'RESPRO' ('/' ('LOG' cp) ('LOG' 10.D0)) ;
   'FINSI' ;
   'SI' ('EXISTE' cm) ;
      ok = VRAI ;
      'RESPRO' ('/' ('LOG' cm) ('LOG' 10.D0)) ;
   'FINSI' ;
   'SI' ('NON' ok) ;
      'QUITTER' bouc ;
   'FINSI' ;
'FIN' bouc ;
*
* End of procedure file LOG10
*
'FINPROC' ;
*ENDPROCEDUR log10
*BEGINPROCEDUR dessevol
************************************************************************
* NOM         : DESSEVOL
* DESCRIPTION : Dessine des évolutions : choisit automatiquement
*               les options, marqueurs, couleurs...
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 16/11/2004, version initiale
* HISTORIQUE : v1, 16/11/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' DESSEVOL ;
'ARGUMENT' evtot*'EVOLUTION' ;
'ARGUMENT' tabt*'TABLE' ;
'ARGUMENT' tit*'MOT' ;
'ARGUMENT' tix*'MOT' ;
'ARGUMENT' tiy*'MOT' ;
'ARGUMENT' lnclk/'LOGIQUE' ;
'ARGUMENT' nb/'ENTIER' ;
*
'SI' ('NON' ('EXISTE' lnclk)) ;
   lnclk = FAUX ;
'FINSI' ;
*
'SI' ('NON' ('EXISTE' nb)) ;
   nb = 3 ;
'FINSI' ;
*
nt  = 'DIME' tabt ;
nev = 'DIME' evtot ;
*
* Attention, dans evtot, il y a une évolution avec des noms de points ?
*
*'SI' ('NEG' nev nt) ;
*   cherr = 'CHAINE' 'Evolution and title table : not same dim.' ;
*   'ERREUR' cherr ;
*'FINSI' ;
*
tev = 'TABLE' ;
tev . 'TITRE' = tabt ;
*
toto = 'TABLE' ;
*
lcoul = 'MOTS' 'TURQ' 'VERT' 'JAUN' 'ROSE' 'ROUG' 'BLEU' ;
lmarq = 'MOTS' 'TRIB' 'TRIA' 'LOSA' 'CARR' 'ETOI' 'PLUS' 'CROI' ;
ltirr = 'MOTS' 'TIRR' 'TIRC' 'TIRL' 'TIRM' ;
*
'SI' ('EGA' nb 0) ;
   ev2 = evtot ;
'SINON' ;
   icou = 0 ;
   'REPETER' iev nev ;
      ii = &iev ;
      evi = 'EXTRAIRE' evtot 'COUR' ii ;
      'SI' ('NEG' ('TYPE' ('EXTRAIRE' evi 'ORDO')) 'LISTMOTS') ;
         icou = '+' icou 1 ;
      'FINSI' ;
*      ii2 = '/' ('+' ii 1) 2 ;
*      ci  = EXMOMOD lcoul ii2 ;
*      ci  = EXMOMOD lcoul ii ;
      ci  = EXMOMOD lcoul icou ;
      APPEND toto 'EVOLUTION' ('COULEUR' evi ci) ;
   'FIN' iev ;
   ev2 = toto . 'EVOLUTION' ;
'FINSI' ;
*
'REPETER' iev nev ;
   ii = &iev ;
   mi = EXMOMOD lmarq ii ;
   ti = EXMOMOD ltirr ii ;
   'SI' ('>' nb 2) ;
      tev . ii = 'CHAINE' 'MARQ ' mi ' ' ti ;
   'FINSI' ;
   'SI' ('>' nb 1) ;
      tev . ii = 'CHAINE' 'MARQ ' mi ;
   'FINSI' ;
'FIN' iev ;
*
'SI' lnclk ;
   'DESSIN' ev2 'TITR' tit 'TITX' tix 'TITY' tiy 'LEGE' 'MIMA' tev
   'NCLK' ;
'SINON' ;
   'DESSIN' ev2 'TITR' tit 'TITX' tix 'TITY' tiy 'LEGE' 'MIMA' tev ;
'FINSI' ;
*
* End of procedure file DESSEVOL
*
'FINPROC' ;
*ENDPROCEDUR dessevol
*BEGINPROCEDUR exmomod
************************************************************************
* NOM         : EXMOMOD
* DESCRIPTION : Extraction d'un mot d'un listmots
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 23/06/2003, version initiale
* HISTORIQUE : v1, 23/06/2003, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' EXMOMOD ;
'ARGUMENT' lm*'LISTMOTS' i*'ENTIER' ;
j = 'DIME' lm ;
k = '+' (MODULO ('-' i 1) j) 1 ;
lemot = 'EXTRAIRE' lm k ;
* Usage de l'opérateur text pour éviter que lemot
* ne soit interprété comme un opérateur
'RESPRO' 'TEXTE' lemot ;
*
* End of procedure file EXMOMOD
*
'FINPROC' ;
*ENDPROCEDUR exmomod
*BEGINPROCEDUR modulo
************************************************************************
* NOM         : MODULO
* DESCRIPTION : Calcule un entier modulo un autre...
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 15/10/2002, version initiale
* HISTORIQUE : v1, 15/10/2002, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' MODULO ;
'ARGUMENT' i*'ENTIER' j*'ENTIER' ;
'SI' ('EGA' j 0) ;
  'MESSAGE' 'Impossible de faire modulo 0' ;
  'ERREUR' 5 ;
'SINON' ;
  k=i '/' j ;
  mod=i '-' ( k '*'j ) ;
  'RESPRO' mod ;
'FINSI' ;
*
* End of procedure file MODULO
*
'FINPROC' ;
*ENDPROCEDUR modulo
*BEGINPROCEDUR append
************************************************************************
* NOM         : APPEND
* DESCRIPTION : Rajoute :
*               - un entier à un listentier
*               - un réel   à un listreel
*               - un objet (liste, evolution, matrice ou chpoint)
*                 à un indice de table ('MOT' ou 'ENTIER')
*                    * si l'indice n'existe pas
*                    * 'ET' si l'indice existe
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 10/09/2004, version initiale
* HISTORIQUE : v1, 10/09/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' APPEND ;
'ARGUMENT' tab/'TABLE' ;
'SI' ('EXISTE' tab) ;
   'ARGUMENT' itab/'MOT' ;
   'SI' ('NON' ('EXISTE' itab)) ;
      'ARGUMENT' itab*'ENTIER' ;
   'FINSI' ;
   lobj = FAUX ;
   'SI' ('NON' lobj) ;
      'ARGUMENT' lr/'LISTREEL' ;
      'SI' ('EXISTE' lr) ;
         obj = lr ; lobj = VRAI ;
      'FINSI' ;
   'FINSI' ;
   'SI' ('NON' lobj) ;
      'ARGUMENT' le/'LISTENTI' ;
      'SI' ('EXISTE' le) ;
         obj = le ; lobj = VRAI ;
      'FINSI' ;
   'FINSI' ;
   'SI' ('NON' lobj) ;
      'ARGUMENT' lev/'EVOLUTION' ;
      'SI' ('EXISTE' lev) ;
         obj = lev ; lobj = VRAI ;
      'FINSI' ;
   'FINSI' ;
   'SI' ('NON' lobj) ;
      'ARGUMENT' lm/'MAILLAGE' ;
      'SI' ('EXISTE' lm) ;
         obj = lm ; lobj = VRAI ;
      'FINSI' ;
   'FINSI' ;
   'SI' ('NON' lobj) ;
      'ARGUMENT' chpo/'CHPOINT' ;
      'SI' ('EXISTE' chpo) ;
         obj = chpo ; lobj = VRAI ;
      'FINSI' ;
   'FINSI' ;
   'SI' ('NON' lobj) ;
      'ARGUMENT' rig/'RIGIDITE' ;
      'SI' ('EXISTE' rig) ;
         obj = rig ; lobj = VRAI ;
      'FINSI' ;
   'FINSI' ;
   'SI' ('NON' lobj) ;
      'ARGUMENT' matk/'MATRIK' ;
      'SI' ('EXISTE' matk) ;
         obj = matk ; lobj = VRAI ;
      'FINSI' ;
   'FINSI' ;
   'SI' ('NON' lobj) ;
      cherr = 'CHAINE'
       'Il faut fournir un objet liste, evolution, matrice ou chpoint.'
        ;
      'ERREUR' cherr ;
   'FINSI' ;
   'SI' ('EXISTE' tab itab) ;
      'SI' ('EGA' ('TYPE' obj) 'CHPOINT') ;
         tab . itab = '+' (tab . itab) obj ;
      'SINON' ;
         tab . itab = 'ET' (tab . itab) obj ;
      'FINSI' ;
   'SINON' ;
      tab . itab = obj ;
   'FINSI' ;
   'RESPRO' tab ;
'FINSI' ;
'ARGUMENT' lenti/'LISTENTI' ;
'ARGUMENT' lreel/'LISTREEL' ;
'SI' ('EXISTE' lenti) ;
   'ARGUMENT' enti*'ENTIER' ;
   lenti = 'ET' lenti ('LECT' enti) ;
   'RESPRO' lenti ;
'FINSI' ;
'SI' ('EXISTE' lreel) ;
   'ARGUMENT' reel*'FLOTTANT' ;
   lreel = 'ET' lreel ('PROG' reel) ;
   'RESPRO' lreel ;
'FINSI' ;
*
* End of procedure file APPEND
*
'FINPROC' ;
*ENDPROCEDUR append
*BEGINPROCEDUR isinlis
************************************************************************
* NOM         : ISINLIS
* DESCRIPTION : Index d'un mot dans un liste de mots
*               (0 s'il n'y est pas)
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 15/12/2004, version initiale
* HISTORIQUE : v1, 15/12/2004, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' ISINLIS ;
'ARGUMENT' tutu*'MOT' ;
'ARGUMENT' ltoto*'LISTMOTS' ;
'ARGUMENT' lerr/'LOGIQUE' ;
*
'SI' ('NON' ('EXISTE' lerr)) ;
   lerr = FAUX ;
'FINSI' ;
*
isin = 0 ;
ntoto = 'DIME' ltoto ;
'SI' ('>' ntoto 0) ;
   'REPETER' itoto ntoto ;
      mtoto = 'EXTRAIRE' ltoto &itoto ;
      'SI' ('EGA' mtoto tutu) ;
         isin = &itoto ;
         'QUITTER' itoto ;
      'FINSI' ;
   'FIN' itoto ;
'FINSI' ;
'SI' lerr ;
   'SI' ('EGA' isin 0) ;
      cherr = 'CHAINE' ' ne contient pas ' tutu ;
      'LISTE' ltoto ;
      'ERREUR' cherr ;
   'FINSI' ;
'SINON' ;
   'RESPRO' isin ;
'FINSI' ;
*
* End of procedure file ISINLIS
*
'FINPROC' ;
*ENDPROCEDUR isinlis
*BEGINPROCEDUR formar
************************************************************************
* NOM         : FORMAR
* DESCRIPTION : formate un réel de facon courte
*               pratique pour les noms de
*               sauvegarde
*               Exemples :
* 'MESSAGE' ('CHAINE' (formar 2.9e5   1)) ;
* 2.9E5
* 'MESSAGE' ('CHAINE' (formar -2.9e5  1)) ;
* -2.9E5
* 'MESSAGE' ('CHAINE' (formar 2.9e-5  1)) ;
* 2.9E-5
* 'MESSAGE' ('CHAINE' (formar -2.9e-5 1)) ;
* -2.9E-5
* 'MESSAGE' ('CHAINE' (formar 2.9     1)) ;
* 2.9
* 'MESSAGE' ('CHAINE' (formar -2.9    1)) ;
* -2.9
* 'MESSAGE' ('CHAINE' (formar 0       1)) ;
* 0
* 'MESSAGE' ('CHAINE' (formar 0       1)) ;
* 0
* 'MESSAGE' ('CHAINE' (formar 2.9e5   0)) ;
* 3E5
* 'MESSAGE' ('CHAINE' (formar -2.9e5  0)) ;
* -3E5
* 'MESSAGE' ('CHAINE' (formar 2.9e-5  0)) ;
* 3E-5
* 'MESSAGE' ('CHAINE' (formar -2.9e-5 0)) ;
* -3E-5
* 'MESSAGE' ('CHAINE' (formar 2.9     0)) ;
* 3
* 'MESSAGE' ('CHAINE' (formar -2.9    0)) ;
* -3
* 'MESSAGE' ('CHAINE' (formar 0       0)) ;
* 0
* 'MESSAGE' ('CHAINE' (formar 0       0)) ;
* 0
*
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 18/02/2003, version initiale
* HISTORIQUE : v1, 18/02/2003, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
*
'DEBPROC' FORMAR ;
'ARGUMENT' fl*'FLOTTANT' ;
'ARGUMENT' vir/'ENTIER  ' ;
'SI' ('NON' ('EXISTE' vir)) ;
   vir = 1 ;
'SINON' ;
   'SI' ('<' vir 0) ;
      'ERREUR' 'fournir un entier positif' ;
   'FINSI' ;
'FINSI' ;
'SI' ('<' ('ABS' fl) 10.D-100) ;
   chfl = 'CHAINE' '0' ;
'SINON' ;
*! sans le 1.D-10, ca ne fonctionne pas
*! qd on entre pile poil une puissance de 10
   lfl = LOG10 ('ABS' fl) ;
*   lfl = '+' (LOG10 ('ABS' fl)) 1.D-10  ;
   slfl = 'SIGNE' ('ENTIER' lfl) ;
   'SI' ('EGA' slfl 1) ;
      elfl = 'ENTIER' lfl ;
   'SINON' ;
      elfl = '-' ('ENTIER' lfl) 1 ;
   'FINSI' ;
   man = '/' fl ('**' 10.D0 elfl) ;
*
* Une verrue pour des histoires de précision...
*
   'SI' ('EGA' man 10.D0 ('**' 10.D0 ('*' vir -1.D0))) ;
      man  = '/' man 10.D0 ;
      elfl = '+' elfl 1 ;
   'FINSI' ;
*
   sman = 'SIGNE' man ;
   'SI' ('EGA' sman 1) ;
      fman = 'CHAINE' '(F' ('+' vir 2) '.0' vir ')' ;
   'SINON' ;
      fman = 'CHAINE' '(F' ('+' vir 3) '.0' vir ')' ;
   'FINSI' ;
   'SI' ('NEG' vir 0) ;
      'SI' ('NEG' elfl 0) ;
         chfl = 'CHAINE' 'FORMAT' fman man 'E' elfl ;
      'SINON' ;
         chfl = 'CHAINE' 'FORMAT' fman man ;
      'FINSI' ;
   'SINON' ;
      man2 = 'ENTIER' ('+' man ('*' 0.5D0 sman)) ;
      'SI' ('NEG' elfl 0) ;
         chfl = 'CHAINE' man2 'E' elfl ;
      'SINON' ;
         chfl = 'CHAINE' man2 ;
      'FINSI' ;
   'FINSI' ;
'FINSI' ;
'RESPRO' chfl ;
*
* End of procedure file FORMAR
*
'FINPROC' ;
*ENDPROCEDUR formar
************************************************************************
* NOM         : TRAINEE_3D
* DESCRIPTION : Cas-test Traînée de Stokes 3D
*
*
* LANGAGE     : GIBIANE-CAST3M
* AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
*               mél : gounand@semt2.smts.cea.fr
**********************************************************************
* VERSION    : v1, 19/10/2006, version initiale
* HISTORIQUE : v1, 19/10/2006, création
* HISTORIQUE :
* HISTORIQUE :
************************************************************************
* Prière de PRENDRE LE TEMPS de compléter les commentaires
* en cas de modification de ce sous-programme afin de faciliter
* la maintenance !
************************************************************************
*
complet  = FAUX ;
interact = FAUX ;
graph    = FAUX ;
*
'OPTION' 'DIME' 3 'MODE' 'TRID' ;
'OPTION' 'ISOV' 'SURF' ;
'SI' ('NON' interact) ;
  'OPTION' 'TRAC' 'PSC' ;
'SINON' ;
   'OPTION' 'TRAC' 'X' ;
'FINSI' ;
*
* Paramètres maillage
*
Ar = 2. ; Az = 2. ;
ok = VRAI ;
* 1 = tetras
* 2 = prismes
* 3 = cubes
'REPETER' iimesh 2 ;
imesh = &iimesh '+' 1 ;
'SI' ('EGA' imesh 1) ;
   tmesh = 'CHAINE' 'Tetras' ;
'FINSI' ;
'SI' ('EGA' imesh 2) ;
   tmesh = 'CHAINE' 'Prismes' ;
'FINSI' ;
'SI' ('EGA' imesh 3) ;
   tmesh = 'CHAINE' 'Cubes' ;
'FINSI' ;
*
* reproj = 1 remet les points QUAF de la sphère sur la sphère
*
reproj = 0 ;
*
* Paramètres numériques (I)
* Espaces de discrétisation
* idisc = 1 : QUAF + CENTREP1
* idisc = 2 : LINC + CSTE
* discrétisation du terme de divergence des contraintes
* irig = 1 : (grad u . grad v)
* irig = 2 : (grad u . grad v) + (tgradu . tgradv)
* irig = 3 : (grad u . grad v) + (div u . div v)
irig = 1 ;
tabevl2 = 'TABLE' ; tabevli = 'TABLE' ; tabevst = 'TABLE' ;
tabtl2  = 'TABLE' ; tabtli  = 'TABLE' ; tabtst  = 'TABLE' ;
'REPETER' iidisc 2 ;
idisc = &iidisc ;
*idisc = 2 ;
'SI' ('EGA' idisc 1) ;
   tdisc = 'CHAINE' 'QUAF/LINM' ;
   ordvoul = 3. ;
   discg = 'QUAF' ;
   discv = 'QUAF' ;
   lvip  = 'MOTS' 'UX' 'UY' 'UZ' ;
   lvid  = 'MOTS' 'FX' 'FY' 'FZ' ;
   discp = 'LINM' ;
   lpip  = 'MOTS' 'LX1'  'LX2'  'LX3' 'LX4' ;
   lpid  = 'MOTS' 'LX1'  'LX2'  'LX3' 'LX4' ;
   'SI' complet ;
      lisden = 'PROG' 0.5 0.25 0.125 ;
   'SINON' ;
      lisden = 'PROG' 0.5 0.35 ;
   'FINSI' ;
'FINSI' ;
*
'SI' ('EGA' idisc 2) ;
   tdisc = 'CHAINE' 'LINC/CSTE' ;
* On devrait avoir 2. mais il faut raffiner !
   ordvoul = 1.7 ;
   discg = 'LINE' ;
   discv = 'LINC' ;
   lvip  = 'MOTS' 'UX' 'UY' 'UZ' ;
   lvid  = 'MOTS' 'FX' 'FY' 'FZ' ;
   discp = 'CSTE' ;
   lpip  = 'MOTS' 'LXP' ;
   lpid  = 'MOTS' 'LXP' ;
   'SI' complet ;
      lisden = 'PROG'  0.5 0.25 0.125 0.0625 ;
*      lisden = 'PROG'  0.5 0.25 0.125 ;
   'SINON' ;
      lisden = 'PROG'  0.5 0.3 ;
   'FINSI' ;

'FINSI' ;
*
nden = 'DIME' lisden ;
lh  = 'PROG' ; ll2 = 'PROG' ; lli = 'PROG' ; lst = 'PROG' ;
'REPETER' iiden nden ;
   iden = &iiden ;
   den = 'EXTRAIRE' lisden iden ;
*   errl2 errli errfst = CALCUL3D imesh reproj irig den VRAI ;
   errl2 errli errfst = CALCUL3D imesh reproj irig den ;
   lh = APPEND lh den ; ll2 = APPEND ll2 errl2 ;
   lli = APPEND lli errli ; lst = APPEND lst errfst ;
'FIN' iiden ;
*
lh ll2 lli lst = LOG10 lh ll2 lli lst ;
*
* Calcul des ordres de convergence
*
evl2 = 'EVOL' 'MANU' lh ll2 ;
cpl2 dummy = @POMI evl2 1 'IDEM' ;
ordl2 = cpl2 . 1 ;
tabevl2 . idisc = evl2 ;
tabtl2  . idisc = 'CHAINE' 'id=' idisc ';ord=' (formar ordl2 1) ;
*
* Test de l'ordre
*
test = '>EG' ordl2 (ordvoul '*' 0.8) ;
ok = ok 'ET' test ;
titcas = 'CHAINE' 'Maillage : ' tmesh ' Discretisation : ' tdisc ;
'MESSAGE' titcas ;
'MESSAGE' ('CHAINE' ' Ordre de convergence norme L2 sur la vitesse '
                    ordl2) ;
'SI' ('NON' test) ;
   'MESSAGE' ('CHAINE' 'On aurait voulu avoir :' ordvoul) ;
'FINSI' ;
evli = 'EVOL' 'MANU' lh lli ;
cpli dummy = @POMI evli 1 'IDEM' ;
ordli = cpli . 1 ;
tabevli . idisc = evli ;
tabtli  . idisc = 'CHAINE' 'id=' idisc ';ord=' (formar ordli 1) ;
evst = 'EVOL' 'MANU' lh lst ;
cpst dummy = @POMI evst 1 'IDEM' ;
ordst = cpst . 1 ;
tabevst . idisc = evst ;
tabtst  . idisc = 'CHAINE' 'id=' idisc ';ord=' (formar ordst 1) ;
'FIN' iidisc ;
*
'SI' graph ;
evtl2 = @STBL tabevl2 ;
tit = 'CHAINE' 'Ordre de convergence en norme L2 sur la vitesse' ;
tix = 'CHAINE' 'Log10 h' ;
tiy = 'CHAINE' 'Log10 errl2' ;
DESSEVOL evtl2 tabtl2 tit tix tiy ;
*
evtli = @STBL tabevli ;
tit = 'CHAINE' 'Ordre de convergence en norme Linf sur la vitesse' ;
tix = 'CHAINE' 'Log10 h' ;
tiy = 'CHAINE' 'Log10 errli' ;
DESSEVOL evtli tabtli tit tix tiy ;
*
evtst = @STBL tabevst ;
tit = 'CHAINE' 'Ordre de convergence sur la trainee de Stokes' ;
tix = 'CHAINE' 'Log10 h' ;
tiy = 'CHAINE' 'Log10 errst' ;
DESSEVOL evtst tabtst tit tix tiy ;
'FINSI' ;
'FIN' iimesh ;
*
'SI' ('NON' ok) ;
   'MESSAGE' ('CHAINE' 'Il y a eu des erreurs') ;
   'ERREUR' 5 ;
'SINON' ;
   'MESSAGE' ('CHAINE' 'Tout sest bien passe !') ;
'FINSI' ;
*
'SI' interact ;
   'OPTION' 'DONN' 5 ;
   'OPTION' 'ECHO' 1 ;
'FINSI' ;
*
* End of dgibi file TRAINEE_3D
*
'FIN' ;





