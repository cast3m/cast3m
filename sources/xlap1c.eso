C XLAP1C    SOURCE    PV        16/11/17    22:01:49     9180
      SUBROUTINE XLAP1C(ICOGRV,MPROC,MPVITC,
     $     MPVOLU,MPNORM,MPSURF,MELEFL,
     $     KRFACE,KRCENT,LCLIMV,KRVIMP,LCLITO,KRTOIM,
     $     NOMINC,
     $     MPMUC,
     $     IJACO,
     $     IMPR,IRET)
      IMPLICIT INTEGER(I-N)
      IMPLICIT REAL*8 (A-H,O-Z)
C***********************************************************************
C NOM         : XLAP1C
C DESCRIPTION : Calcul de la matrice jacobienne du résidu du laplacien
C               VF 2D.
C               Ici, on ne calcule que les contributions 'simples'
C               à la matrice jacobienne faisant intervenir les
C               coefficients pour le calcul des gradients de vitesse
C               (ICOGRV).
C               (contributions à (d Res_{\rho u} / d var) et (d
C                Res_{\rho v} / d var)
C                var prenant successivement les valeurs :
C                \rho,   \rho u,    \rho v,     \rho e_t )
C
C
C NOTE PERSO  : On pourrait programmer ça plus lisiblement en stockant
C               les contributions dans un tableau de pointeurs (2
C               indices, c'est possible ?) et en effectuant des produits
C               matriciels (coeff. x matrices de dérivées).
C               On n'y coupera pas si on veut regrouper 2D et 3D...
C               On ne va pas le faire.
C
C
C LANGAGE     : ESOPE
C AUTEUR      : Stéphane GOUNAND (CEA/DEN/DM2S/SFME/LTMF)
C               mél : gounand@semt2.smts.cea.fr
C***********************************************************************
C APPELES (UTIL)   : AJMTK : ajoute un objet de type MATSIM (non
C                            standard) à un objet de type MATRIK.
C APPELE PAR       : XLAP1A : Calcul de la matrice jacobienne du
C                    résidu du laplacien VF 2D.
C***********************************************************************
C ENTREES            : ICOGRV (type MCHELM) : coefficients pour le
C                        calcul du gradient de la vitesse aux
C                        interfaces.
C                      MPROC (type MPOVAL) : masse volumique par
C                                            élément.
C                      MPVITC (type MPOVAL) : vitesse par élément.
C                      MPVOLU (type MPOVAL) : volume des éléments.
C                      MPNORM (type MPOVAL) : normale aux faces.
C                      MPSURF (type MPOVAL) : surface des faces.
C                      MELEFL (type MELEME) : connectivités face-(centre
C                                             gauche, centre droit).
C                      KRFACE (type MLENTI) : tableau de repérage dans
C                        le maillage des faces des éléments.
C                      KRCENT (type MLENTI) : tableau de repérage dans
C                        le maillage des centres des éléments.
C                      LCLIMV (type logique) : .TRUE. => CL de Dirichlet
C                        sur la vitesse.
C                      KRVIMP (type MLENTI) : tableau de repérage dans
C                        maillage des CL de Dirichlet sur la
C                        vitesse.
C                      LCLITO (type logique) : .TRUE. => CL de Dirichlet
C                        sur le tenseur des contraintes.
C                      KRTOIM (type MLENTI) : tableau de repérage dans
C                        maillage des CL de Dirichlet sur le tenseur des
C                        contraintes
C                      NOMINC (type MLMOTS) : noms des inconnues.
C                      MPMUC (type MPOVAL) : viscosité dynamique (SI).
C ENTREES/SORTIES    : IJACO (type MATRIK) : matrice jacobienne du
C                        résidu du laplacien VF 2D.
C SORTIES            : -
C CODE RETOUR (IRET) : = 0 si tout s'est bien passé
C***********************************************************************
C VERSION    : v1, 10/12/2001, version initiale
C HISTORIQUE : v1, 10/12/2001, création
C HISTORIQUE :
C HISTORIQUE :
C***********************************************************************
C Prière de PRENDRE LE TEMPS de compléter les commentaires
C en cas de modification de ce sous-programme afin de faciliter
C la maintenance !
C***********************************************************************
-INC CCOPTIO
-INC SMCOORD
-INC SMCHPOI
      POINTEUR MPMUC.MPOVAL
      POINTEUR MPROC.MPOVAL ,MPVITC.MPOVAL
      POINTEUR MPSURF.MPOVAL,MPNORM.MPOVAL,MPVOLU.MPOVAL
-INC SMCHAML
      POINTEUR ICOGRV.MCHELM,JCOGRV.MCHAML
      POINTEUR KDUNDX.MELVAL,KDUNDY.MELVAL
-INC SMELEME
      POINTEUR MELEFL.MELEME
      POINTEUR MCOGRV.MELEME
-INC SMLENTI
      POINTEUR KRVIMP.MLENTI,KRTOIM.MLENTI
      POINTEUR KRCENT.MLENTI,KRFACE.MLENTI
-INC SMLMOTS
      POINTEUR NOMINC.MLMOTS
-INC SMMATRIK
      POINTEUR IJACO.MATRIK
*
* Objet matrice élémentaire simplifié
*
      SEGMENT GMATSI
      INTEGER POIPR1(NPP1,NEL1)
      INTEGER POIDU1(1,NEL1)
      INTEGER POIPR2(NPP2,NEL2)
      INTEGER POIDU2(2,NEL2)
      POINTEUR LMATSI(0).MATSIM
      ENDSEGMENT
*  Contributions simples de la part du gradient de
*  vitesse (CTSGRV)
      POINTEUR CTSGRV.GMATSI
      SEGMENT MATSIM
      CHARACTER*8 NOMPRI,NOMDUA
      REAL*8 VALMA1(1,NPP1,NEL1)
      REAL*8 VALMA2(2,NPP2,NEL2)
      ENDSEGMENT
      POINTEUR ROURHO.MATSIM
      POINTEUR ROVRHO.MATSIM
      POINTEUR ROUROU.MATSIM
      POINTEUR ROUROV.MATSIM
      POINTEUR ROVROU.MATSIM
      POINTEUR ROVROV.MATSIM
*
      REAL*8 MU
*
      INTEGER IMPR,IRET
*
      LOGICAL LCLIMV,LCLITO
      LOGICAL LMUR
      LOGICAL LCTRB1,LCTRB2
*
      INTEGER IELEM,IPD,IPP,ISOUCH,IEL1,IEL2
      INTEGER NELEM,NPD,NPP,NSOUCH,NEL1,NEL2,NPP1,NPP2
      INTEGER NGCDRO,NGCGAU,NGFACE,NPPRIM,NPDUAL
      INTEGER NLCENP,NLCEND,NLFACE,NLCLTO,NLCLV
      INTEGER NPTEL
*
      REAL*8 ALPHAX,ALPHAY,CNX,CNY
      REAL*8 SIGNOR,SURFFA,VOLUEL
      REAL*8 RHOP,UP,VP
      REAL*8 FACTOR
      REAL*8 DUDRHO,DUDROU,DVDRHO,DVDROV
      REAL*8 BROUDU,BROUDV,BROVDU,BROVDV
*
      INTEGER ICOORX,NLCGAU,NLCDRO
      REAL*8 XF,YF,XG,YG,XFMXG,YFMYG,DRG
     &     ,XD,YD,XFMXD,YFMYD,DRD,ALPHA,UMALPH
C
*
* Executable statements
*
      IF (IMPR.GT.2) WRITE(IOIMP,*) 'Entrée dans xlap1c.eso'
*   On calcule les contributions à (d Res_{\rho u} / d var) et (d
*   Res_{\rho v} / d var) ; var prenant successivement les valeurs :
*      \rho,   \rho u,    \rho v,     \rho e_t
*   Note :
*     - (d Res_{\rho u} / d \rho e_t) = 0
*     - (d Res_{\rho v} / d \rho e_t) = 0
*   On dérive les termes : \tens{\tau} \prod \vect{n}
*   Les noms de matrices élémentaires (type MATSIM) associées sont :
*   ROURHO, ROUROU, ROUROV, ROVRHO, ROVROU, ROVROV
      IF (LCLIMV) THEN
         SEGACT KRVIMP
      ENDIF
      IF (LCLITO) THEN
         SEGACT KRTOIM
      ENDIF
      SEGACT NOMINC
      SEGACT KRCENT
      SEGACT KRFACE
      SEGACT MELEFL
      SEGACT MPSURF
      SEGACT MPNORM
      SEGACT MPVOLU
      SEGACT MPMUC
      SEGACT MPROC
      SEGACT MPVITC
      SEGACT ICOGRV
      NSOUCH=ICOGRV.IMACHE(/1)
      DO 1 ISOUCH=1,NSOUCH
         MCOGRV=ICOGRV.IMACHE(ISOUCH)
         JCOGRV=ICOGRV.ICHAML(ISOUCH)
         SEGACT JCOGRV
         KDUNDX=JCOGRV.IELVAL(1)
         KDUNDY=JCOGRV.IELVAL(2)
         SEGDES JCOGRV
         SEGACT KDUNDX
         SEGACT KDUNDY
         SEGACT MCOGRV
         NELEM=MCOGRV.NUM(/2)
         NPTEL=MCOGRV.NUM(/1)
         NPP1=NPTEL-1
         NPP2=NPTEL-1
         NEL1=NELEM
         NEL2=NELEM
         IEL1=1
         IEL2=1
         SEGINI ROURHO
         SEGINI ROVRHO
         SEGINI ROUROU
         SEGINI ROVROU
         SEGINI ROUROV
         SEGINI ROVROV
         SEGINI CTSGRV
         ROURHO.NOMPRI(1:4)=NOMINC.MOTS(1)
         ROURHO.NOMPRI(5:8)='    '
         ROURHO.NOMDUA(1:4)=NOMINC.MOTS(2)
         ROURHO.NOMDUA(5:8)='    '
         ROVRHO.NOMPRI(1:4)=NOMINC.MOTS(1)
         ROVRHO.NOMPRI(5:8)='    '
         ROVRHO.NOMDUA(1:4)=NOMINC.MOTS(3)
         ROVRHO.NOMDUA(5:8)='    '
         ROUROU.NOMPRI(1:4)=NOMINC.MOTS(2)
         ROUROU.NOMPRI(5:8)='    '
         ROUROU.NOMDUA(1:4)=NOMINC.MOTS(2)
         ROUROU.NOMDUA(5:8)='    '
         ROVROU.NOMPRI(1:4)=NOMINC.MOTS(2)
         ROVROU.NOMPRI(5:8)='    '
         ROVROU.NOMDUA(1:4)=NOMINC.MOTS(3)
         ROVROU.NOMDUA(5:8)='    '
         ROUROV.NOMPRI(1:4)=NOMINC.MOTS(3)
         ROUROV.NOMPRI(5:8)='    '
         ROUROV.NOMDUA(1:4)=NOMINC.MOTS(2)
         ROUROV.NOMDUA(5:8)='    '
         ROVROV.NOMPRI(1:4)=NOMINC.MOTS(3)
         ROVROV.NOMPRI(5:8)='    '
         ROVROV.NOMDUA(1:4)=NOMINC.MOTS(3)
         ROVROV.NOMDUA(5:8)='    '
         DO 12 IELEM=1,NELEM
*     Le premier point du support de ICOGRV est un point FACE
            NGFACE=MCOGRV.NUM(1,IELEM)
            NLFACE=KRFACE.LECT(NGFACE)
            IF (NLFACE.EQ.0) THEN
               WRITE(IOIMP,*) 'Erreur de programmation n°1'
               GOTO 9999
            ENDIF
*     On calcule la contribution à la matrice jacobienne IJACO de la face
*     NGFAC (points duaux     : centres à gauche et à droite de la face)
*           (points primaux   : une partie (bicoz conditions aux limites)
*            de ceux du stencil pour le calcul du gradient
*            à la face, ils doivent être des points centres)
*       Si le tenseur des contraintes sur la face est imposé par les
*       conditions aux limites, la contribution de la face à IJACO est
*       nulle.
            LCTRB1=.TRUE.
            IF (LCLITO) THEN
               NLCLTO=KRTOIM.LECT(NGFACE)
               IF (NLCLTO.NE.0) THEN
                  LCTRB1=.FALSE.
               ENDIF
            ENDIF
            IF (LCTRB1) THEN
               NGCGAU=MELEFL.NUM(1,NLFACE)
               NGCDRO=MELEFL.NUM(3,NLFACE)
               NLCGAU=KRCENT.LECT(NGCGAU)
               NLCDRO=KRCENT.LECT(NGCDRO)
               LMUR=(NGCGAU.EQ.NGCDRO)
*     On distingue le cas où la face est un bord du maillage (mur)
*                  du cas où la face est interne au maillage
               IF (.NOT.LMUR) THEN
                  NPD=2
                  ICOORX = ((IDIM + 1) * (NGFACE - 1))+1
                  XF = MCOORD.XCOOR(ICOORX)
                  YF = MCOORD.XCOOR(ICOORX+1)
                  ICOORX = ((IDIM + 1) * (NGCGAU - 1))+1
                  XG = MCOORD.XCOOR(ICOORX)
                  YG = MCOORD.XCOOR(ICOORX+1)
                  XFMXG = XF - XG
                  YFMYG = YF - YG
                  DRG=SQRT((XFMXG*XFMXG)+(YFMYG*YFMYG))
                  ICOORX = ((IDIM + 1) * (NGCDRO - 1))+1
                  XD = MCOORD.XCOOR(ICOORX)
                  YD = MCOORD.XCOOR(ICOORX+1)
                  XFMXD = XF - XD
                  YFMYD = YF - YD
                  DRD=SQRT((XFMXD*XFMXD)+(YFMYD*YFMYD))
                  ALPHA=DRG/(DRG+DRD)
                  UMALPH= 1.0D0 - ALPHA
               ELSE
                  NPD=1
                  ALPHA=0.0D0
                  UMALPH=1.0D0
               ENDIF
               MU=UMALPH*MPMUC.VPOCHA(NLCGAU,1) +
     &              ALPHA*MPMUC.VPOCHA(NLCDRO,1)
               NPP=NPTEL-1
*     IPD=1 : point à gauche du point NGFACE
*     IPD=2 : point à droite du point NGFACE
               DO 122 IPD=1,NPD
                  NPDUAL=MELEFL.NUM((2*IPD)-1,NLFACE)
                  IF (.NOT.LMUR) THEN
                     CTSGRV.POIDU2(IPD,IEL2)=NPDUAL
                  ELSE
                     CTSGRV.POIDU1(IPD,IEL1)=NPDUAL
                  ENDIF
                  NLCEND=KRCENT.LECT(NPDUAL)
                  IF (NLCEND.EQ.0) THEN
                     WRITE(IOIMP,*) 'Erreur grave n°1'
                     GOTO 9999
                  ENDIF
                  DO 124 IPP=1,NPP
                     NPPRIM=MCOGRV.NUM(IPP+1,IELEM)
                     LCTRB2=.TRUE.
                     IF (LCLIMV) THEN
                        NLCLV=KRVIMP.LECT(NPPRIM)
                        IF (NLCLV.NE.0) THEN
                           LCTRB2=.FALSE.
                        ENDIF
                     ENDIF
                     IF (.NOT.LCTRB2) THEN
*     Lorsque une contribution est nulle, on fixe artificiellement le
*     point primal égal au point dual.
                        IF (.NOT.LMUR) THEN
                           CTSGRV.POIPR2(IPP,IEL2)=NPDUAL
                           ROURHO.VALMA2(IPD,IPP,IEL2)=0.D0
                           ROVRHO.VALMA2(IPD,IPP,IEL2)=0.D0
                           ROUROU.VALMA2(IPD,IPP,IEL2)=0.D0
                           ROVROU.VALMA2(IPD,IPP,IEL2)=0.D0
                           ROUROV.VALMA2(IPD,IPP,IEL2)=0.D0
                           ROVROV.VALMA2(IPD,IPP,IEL2)=0.D0
                        ELSE
                           CTSGRV.POIPR1(IPP,IEL1)=NPDUAL
                           ROURHO.VALMA1(IPD,IPP,IEL1)=0.D0
                           ROVRHO.VALMA1(IPD,IPP,IEL1)=0.D0
                           ROUROU.VALMA1(IPD,IPP,IEL1)=0.D0
                           ROVROU.VALMA1(IPD,IPP,IEL1)=0.D0
                           ROUROV.VALMA1(IPD,IPP,IEL1)=0.D0
                           ROVROV.VALMA1(IPD,IPP,IEL1)=0.D0
                        ENDIF
                     ELSE
*     Les contributions valent :
* 1.  (d Res_{\rho u})_d / (d var)_p =
*     +/-1 (normale sortante, rentrante)  (1/V_d) * (S_f) * \mu
*     * [ [ ( 4/3 (n_x * \alpha_x) + (n_y * \alpha_y)) *
*           ((du)_p / (d var)_p)]
*       + [ (-2/3 (n_x * \alpha_y) + (n_y * \alpha_x)) *
*           ((dv)_p / (d var)_p)]
*       ]
* 2.  (d Res_{\rho v})_d / (d var)_p =
*     +/-1 (normale sortante, rentrante)  (1/V_d) * (S_f) * \mu
*     * [ [ (-2/3 (n_y * \alpha_x) + (n_x * \alpha_y)) *
*           ((du)_p / (d var)_p)]
*       + [ ( 4/3 (n_y * \alpha_y) + (n_x * \alpha_x)) *
*           ((dv)_p / (d var)_p)]
*       ]
*
*     avec :
*          (du)_p / (d \rho)_p   = - u / \rho_p
*          (du)_p / (d \rho u)_p =   1 / \rho_p
*          (du)_p / (d \rho v)_p =   0
*          (dv)_p / (d \rho)_p   = - v / \rho_p
*          (dv)_p / (d \rho u)_p =   0
*          (dv)_p / (d \rho v)_p =   1 / \rho_p
*
                        NLCENP=KRCENT.LECT(NPPRIM)
                        IF (NLCENP.EQ.0) THEN
                           WRITE(IOIMP,*) 'Erreur grave n°2'
                           GOTO 9999
                        ENDIF
*       normale sortante pour IPD=1, rentrante pour IPD=2
                        SIGNOR=(-1.D0)**(IPD+1)
                        VOLUEL=MPVOLU.VPOCHA(NLCEND,1)
                        SURFFA=MPSURF.VPOCHA(NLFACE,1)
                        CNX   =MPNORM.VPOCHA(NLFACE,1)
                        CNY   =MPNORM.VPOCHA(NLFACE,2)
                        ALPHAX=KDUNDX.VELCHE(IPP+1,IELEM)
                        ALPHAY=KDUNDY.VELCHE(IPP+1,IELEM)
                        RHOP  =MPROC.VPOCHA(NLCENP,1)
                        UP    =MPVITC.VPOCHA(NLCENP,1)
                        VP    =MPVITC.VPOCHA(NLCENP,2)
                        FACTOR=SIGNOR*(1.D0/VOLUEL)*SURFFA*MU
                        BROUDU=(( 4.D0/3.D0)*(CNX*ALPHAX))
     $                       + (CNY*ALPHAY)
                        BROUDV=((-2.D0/3.D0)*(CNX*ALPHAY))
     $                       + (CNY*ALPHAX)
                        BROVDU=((-2.D0/3.D0)*(CNY*ALPHAX))
     $                       + (CNX*ALPHAY)
                        BROVDV=(( 4.D0/3.D0)*(CNY*ALPHAY))
     $                       + (CNX*ALPHAX)
                        DUDRHO=-UP /RHOP
                        DUDROU=1.D0/RHOP
                        DVDRHO=-VP /RHOP
                        DVDROV=1.D0/RHOP
                        IF (.NOT.LMUR) THEN
                           CTSGRV.POIPR2(IPP,IEL2)=NPPRIM
                           ROURHO.VALMA2(IPD,IPP,IEL2)=
     $                          FACTOR*((BROUDU*DUDRHO)+(BROUDV*DVDRHO))
                           ROVRHO.VALMA2(IPD,IPP,IEL2)=
     $                          FACTOR*((BROVDU*DUDRHO)+(BROVDV*DVDRHO))
                           ROUROU.VALMA2(IPD,IPP,IEL2)=
     $                          FACTOR* (BROUDU*DUDROU)
                           ROVROU.VALMA2(IPD,IPP,IEL2)=
     $                          FACTOR* (BROVDU*DUDROU)
                           ROUROV.VALMA2(IPD,IPP,IEL2)=
     $                          FACTOR* (BROUDV*DVDROV)
                           ROVROV.VALMA2(IPD,IPP,IEL2)=
     $                          FACTOR* (BROVDV*DVDROV)
                        ELSE
                           CTSGRV.POIPR1(IPP,IEL1)=NPPRIM
                           ROURHO.VALMA1(IPD,IPP,IEL1)=
     $                          FACTOR*((BROUDU*DUDRHO)+(BROUDV*DVDRHO))
                           ROVRHO.VALMA1(IPD,IPP,IEL1)=
     $                          FACTOR*((BROVDU*DUDRHO)+(BROVDV*DVDRHO))
                           ROUROU.VALMA1(IPD,IPP,IEL1)=
     $                          FACTOR* (BROUDU*DUDROU)
                           ROVROU.VALMA1(IPD,IPP,IEL1)=
     $                          FACTOR* (BROVDU*DUDROU)
                           ROUROV.VALMA1(IPD,IPP,IEL1)=
     $                          FACTOR* (BROUDV*DVDROV)
                           ROVROV.VALMA1(IPD,IPP,IEL1)=
     $                          FACTOR* (BROVDV*DVDROV)
                        ENDIF
                     ENDIF
 124              CONTINUE
 122           CONTINUE
               IF (.NOT.LMUR) THEN
                  IEL2=IEL2+1
               ELSE
                  IEL1=IEL1+1
               ENDIF
            ENDIF
 12      CONTINUE
         NPP1=NPTEL-1
         NPP2=NPTEL-1
         NEL1=IEL1-1
         NEL2=IEL2-1
         SEGADJ ROURHO
         SEGADJ ROVRHO
         SEGADJ ROUROU
         SEGADJ ROVROU
         SEGADJ ROUROV
         SEGADJ ROVROV
         SEGADJ CTSGRV
         CTSGRV.LMATSI(**)=ROURHO
         CTSGRV.LMATSI(**)=ROVRHO
         CTSGRV.LMATSI(**)=ROUROU
         CTSGRV.LMATSI(**)=ROVROU
         CTSGRV.LMATSI(**)=ROUROV
         CTSGRV.LMATSI(**)=ROVROV
* On accumule les matrices résultantes dans IJACO
         CALL AJMTK(CTSGRV,IJACO,IMPR,IRET)
         IF (IRET.NE.0) GOTO 9999
         SEGSUP ROURHO
         SEGSUP ROVRHO
         SEGSUP ROUROU
         SEGSUP ROVROU
         SEGSUP ROUROV
         SEGSUP ROVROV
         SEGSUP CTSGRV
*
         SEGDES MCOGRV
         SEGDES KDUNDY
         SEGDES KDUNDX
 1    CONTINUE
      SEGDES ICOGRV
      SEGDES MPVITC
      SEGDES MPMUC
      SEGDES MPROC
      SEGDES MPVOLU
      SEGDES MPNORM
      SEGDES MPSURF
      SEGDES MELEFL
      SEGDES KRFACE
      SEGDES KRCENT
      SEGDES NOMINC
      IF (LCLITO) THEN
         SEGDES KRTOIM
      ENDIF
      IF (LCLIMV) THEN
         SEGDES KRVIMP
      ENDIF
*
* Normal termination
*
      IRET=0
      RETURN
*
* Format handling
*
*
* Error handling
*
 9999 CONTINUE
      IRET=1
      WRITE(IOIMP,*) 'An error was detected in subroutine xlap1c'
      RETURN
*
* End of subroutine XLAP1C
*
      END










