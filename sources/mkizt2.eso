C MKIZT2    SOURCE    PV        16/11/17    22:00:49     9180
      SUBROUTINE MKIZT2(MELDUA,MELPRI,IMATEL,
     $     KRINCD,KRINCP,KMINCT,KRSPGT,
     $     PMTOT,IDMATP,IDMATD,
*IDMTOT,
     $     IZATOT,
     $     IMPR,IRET)
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
C***********************************************************************
C NOM         : MKIZT2
C DESCRIPTION : Pareil que mkizat + changement de numérotation (argument
C               d'entrée)
C               Remplissage des valeurs de la Matrice Morse.
C               (dont les colonnes sont supposées ordonnées)
C               quasiment identique à mkiza.
C               pareil que mkizat avec changement de numérotation
C               (IDMTOT.NUAN)
C
C LANGAGE     : ESOPE
C AUTEUR      : Stéphane GOUNAND (CEA/DRN/DMT/SEMT/LTMF)
C               mél : gounand@semt2.smts.cea.fr
C***********************************************************************
C APPELES          : REGMAI, IFIDIC, INIRPM
C APPELE PAR       : PRASEM
C***********************************************************************
C ENTREES            : MELDUA, MELPRI, IMATEL, KRINCD, KRINCP, KMINCT,
C                      KRSPGT, PMTOT, IDMTOT
C ENTREES/SORTIES    : IZATOT
C CODE RETOUR (IRET) : = 0 si tout s'est bien passé
C***********************************************************************
C VERSION    : v1, 16/12/99
C HISTORIQUE : v1, 16/12/99, création
C HISTORIQUE : 05/01/00 : On ne suppose plus les maillages duaux et
C      primaux partitionnés de la même façon que les matrices
C      élémentaires.
C HISTORIQUE : 09/04/04 ajout idmatp idmatd
C HISTORIQUE :
C***********************************************************************
C Prière de PRENDRE LE TEMPS de compléter les commentaires
C en cas de modification de ce sous-programme afin de faciliter
C la maintenance !
C***********************************************************************
-INC CCOPTIO
-INC SMELEME
      POINTEUR MELDUA.MELEME
      POINTEUR ML2DUA.MELEME
      POINTEUR SMLDUA.MELEME
      POINTEUR MELPRI.MELEME
      POINTEUR ML2PRI.MELEME
      POINTEUR SMLPRI.MELEME
-INC SMMATRIK
      POINTEUR IMATEL.IMATRI
      POINTEUR VMATEL.IZAFM
      POINTEUR KMINCT.MINC
      POINTEUR PMTOT.PMORS
      POINTEUR IZATOT.IZA
*      POINTEUR IDMTOT.IDMAT
      POINTEUR IDMATP.IDMAT
      POINTEUR IDMATD.IDMAT
-INC SMLENTI
      POINTEUR KRINCD.MLENTI
      POINTEUR KRINCP.MLENTI
      POINTEUR KRSPGT.MLENTI
      POINTEUR RPMAT.MLENTI
*
      INTEGER IMPR,IRET
*
      LOGICAL LPARTD,LPARTP
      INTEGER IDX,IDXDEB
      INTEGER ISOUM,NBSOUM,NBSOUD,NBSOUP
      INTEGER ITDDLD,ITDDLP,ITIDUA,ITIPRI,ITPODU,ITPOPR
      INTEGER NBCMPD,NBCMPP,NELPRI
      INTEGER ILMAT,JDMAT,IPMAT,IMATL
      INTEGER NLMAT,NDMAT,NPMAT,NBMATL
      INTEGER LONLIG
      INTEGER IELEM
      INTEGER NUELG,OLDISM,ISOUMA,NUELOC
*
* Executable statements
*
      IF (IMPR.GT.1) WRITE(IOIMP,*) 'Entrée dans mkizt2'
* On régularise les maillage pour plus se faire chier si LISOUS(/1).EQ.0
* In REGMAI : IF (.NOT.LPARTD) SEGINI ML2DUA
      CALL REGMAI(MELDUA,ML2DUA,LPARTD,IMPR,IRET)
      IF (IRET.NE.0) GOTO 9999
* In REGMAI : IF (.NOT.LPARTP) SEGINI ML2PRI
      CALL REGMAI(MELPRI,ML2PRI,LPARTP,IMPR,IRET)
      IF (IRET.NE.0) GOTO 9999
*
* Activons les chapeaux (Matrices et supports)
*
      SEGACT ML2DUA
      NBSOUD=ML2DUA.LISOUS(/1)
      SEGACT ML2PRI
      NBSOUP=ML2PRI.LISOUS(/1)
      SEGACT IMATEL
      NBSOUM=NBSOUP
      NBMATL=IMATEL.LIZAFM(/2)
      IF (NBSOUD.NE.NBSOUP) THEN
         WRITE(IOIMP,*) 'Maillage primal, dual :'
         WRITE(IOIMP,*) 'partitionnment différent...'
         WRITE(IOIMP,*) 'NBSOUD=',NBSOUD
         WRITE(IOIMP,*) 'NBSOUP=',NBSOUP
         GOTO 9999
      ENDIF
*
* Tableau de repérage dans la matrice
*
* In INIRPM : SEGINI RPMAT
      CALL INIRPM(IMATEL,RPMAT,IMPR,IRET)
      IF (IRET.NE.0) GOTO 9999
*
* Activons les tableaux de repérage
*
      SEGACT KRINCD
      NBCMPD=KRINCD.LECT(/1)
      SEGACT KRINCP
      NBCMPP=KRINCP.LECT(/1)
      IF (NBCMPD.NE.NBMATL.OR.NBCMPP.NE.NBMATL) THEN
         WRITE(IOIMP,*) 'KRINCD, KRINCP et IMATEL :'
         WRITE(IOIMP,*) 'nb. comp. différents...'
         GOTO 9999
      ENDIF
      SEGACT KMINCT
      SEGACT KRSPGT
      SEGACT PMTOT
*      SEGACT IDMTOT
      SEGACT IDMATP
      SEGACT IDMATD
      SEGACT IZATOT*MOD
*
* Parcourons les matrices élémentaires par sous-domaine et
* remplissons les valeurs de la matrice Morse.
*
      DO 1 IMATL=1,NBMATL
         ITIDUA=KRINCD.LECT(IMATL)
         ITIPRI=KRINCP.LECT(IMATL)
         NUELG=0
         OLDISM=1
         VMATEL=IMATEL.LIZAFM(OLDISM,IMATL)
         SEGACT VMATEL
         DO 12 ISOUM=1,NBSOUM
            SMLDUA=ML2DUA.LISOUS(ISOUM)
            SEGACT SMLDUA
            SMLPRI=ML2PRI.LISOUS(ISOUM)
            SEGACT SMLPRI
            NELPRI=SMLPRI.NUM(/2)
            DO 122 IELEM=1,NELPRI
               NUELG=NUELG+1
               CALL RPELEM(NUELG,RPMAT,ISOUMA,NUELOC,IMPR,IRET)
               IF (IRET.NE.0) GOTO 9999
               ISOUMA=MAX(ISOUMA,1)
               IF (ISOUMA.NE.OLDISM) THEN
                  SEGDES VMATEL
                  VMATEL=IMATEL.LIZAFM(ISOUMA,IMATL)
                  SEGACT VMATEL
                  OLDISM=ISOUMA
               ENDIF
               ILMAT=NUELOC
               NPMAT=VMATEL.AM(/2)
               NDMAT=VMATEL.AM(/3)
               DO 1222 JDMAT=1,NDMAT
                  ITPODU=KRSPGT.LECT(SMLDUA.NUM(JDMAT,IELEM))
                  IF (ITPODU.EQ.0) THEN
                     WRITE(IOIMP,*) 'Point dual ????'
                     GOTO 9999
                  ENDIF
C     Test du MPOS... déjà fait dans mkpmor...
                  ITDDLD=IDMATD.NUAN(
     $                 KMINCT.NPOS(ITPODU)
     $                 + KMINCT.MPOS(ITPODU,ITIDUA)-1
     $                 )
C     IPMAT parce que IDMAT est le nom d'un segment par défaut...
                  DO 12222 IPMAT=1,NPMAT
                     ITPOPR=KRSPGT.LECT(SMLPRI.NUM(IPMAT,IELEM))
                     IF (ITPOPR.EQ.0) THEN
                        WRITE(IOIMP,*) 'Point primal ????'
                        GOTO 9999
                     ENDIF
                     ITDDLP=IDMATP.NUAN(
     $                    KMINCT.NPOS(ITPOPR)
     $                    + KMINCT.MPOS(ITPOPR,ITIPRI)-1
     $                    )
                     IDXDEB=PMTOT.IA(ITDDLP)
                     LONLIG=PMTOT.IA(ITDDLP+1)-IDXDEB
                     IF (LONLIG.EQ.0) THEN
                        WRITE(IOIMP,*) 'Ligne inex. ddl pri =',ITDDLP
                        GOTO 9999
                     ENDIF
                     CALL IFIDIC(LONLIG,PMTOT.JA(IDXDEB),ITDDLD,
     $                    IDX,
     $                    IMPR,IRET)
                     IF (IRET.NE.0) GOTO 9999
                     IZATOT.A(IDXDEB+IDX-1)=IZATOT.A(IDXDEB+IDX-1)
     $                    + VMATEL.AM(ILMAT,IPMAT,JDMAT)
12222             CONTINUE
 1222          CONTINUE
 122        CONTINUE
            SEGDES VMATEL
 12      CONTINUE
         SEGDES SMLPRI
         SEGDES SMLDUA
 1    CONTINUE
      SEGDES IZATOT
      SEGDES IDMATD
      SEGDES IDMATP
*      SEGDES IDMTOT
      SEGDES PMTOT
      SEGDES KRSPGT
      SEGDES KMINCT
      SEGDES KRINCP
      SEGDES KRINCD
      SEGSUP RPMAT
      SEGDES IMATEL
      SEGDES ML2PRI
      SEGDES ML2DUA
      IF (.NOT.LPARTP) SEGSUP ML2PRI
      IF (.NOT.LPARTD) SEGSUP ML2DUA
*
* Normal termination
*
      IRET=0
      RETURN
*
* Format handling
*
*
* Error handling
*
 9999 CONTINUE
      IRET=1
      WRITE(IOIMP,*) 'An error was detected in subroutine mkizt2'
      RETURN
*
* End of subroutine MKIZT2
*
      END







