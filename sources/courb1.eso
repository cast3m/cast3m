C COURB1    SOURCE    BP208322  16/11/18    21:15:56     9177
      SUBROUTINE COURB1 (MCOURB,LIGNE)
      implicit real*8 (a-h,o-z)
************************************************************************
*
*                             C O U R B 1
*                             -----------
*
* FONCTION:
* ---------
*
*     EXECUTE LA TACHE DE L'OPERATEUR "COURBE".
*
* MODULES UTILISES:
* -----------------
*
      IMPLICIT INTEGER(I-N)
-INC CCOPTIO
-INC CCGEOME
-INC SMCOORD
-INC SMELEME
-INC TMCOURB
*
* PARAMETRES:   (E)=ENTREE   (S)=SORTIE   (+ = CONTENU DANS UN COMMUN)
* -----------
*
*     MCOURB  (E)  SEGMENT ACTIF.
*    +DENSIT  (E)  VOIR LE COMMUN "CGEOME".
*    +IDIM    (E)  VOIR LE COMMUN "COPTIO".
*    +MCOORD  (E)  VOIR LE COMMUN "COPTIO".
*     LIGNE   (S)  OBJET 'MAILLAGE' CREE.
*
* VARIABLES:
* ----------
*
*     NOXTRM = .TRUE.  SI AUCUN POINT-EXTREMITE CONVENABLE N'A ETE
*              FOURNI (UTILISE DANS LA PROCEDURE INTERNE, A LA FIN).
*     DIST   = DISTANCE ENTRE POINT FOURNI POUR EXTREMITE ET VERITABLE
*              POINT EXTREME DE LA COURBE.
*     X1COU,   )
*     X2COU,   )  COORDONNEES DES POINTS EXTREMITES DE LA COURBE.
*     Y1COU,   )
*       ETC... )
*
      INTEGER PT0COU,LI0COU
      LOGICAL NOXTRM,ltelq
      REAL*8 X1COU,Y1COU,Z1COU,X2COU,Y2COU,Z2COU
      REAL*8 X0COU,Y0COU,Z0COU,D0COU
*
* FONCTIONS:
* ----------
*
      REAL*8 POLYNO
*
* AUTEUR, DATE DE CREATION:
* -------------------------
*
*     PASCAL MANIGOT     10 SEPTEMBRE 1986
*     P.M.   24/02/87 : REMODELAGE, AVEC UN NOUVEAU SEGMENT "MCOURB".
*
* LANGAGE:
* ------
*
*     ESOPE + FORTRAN77 + EXTENSION: DECLARATION "REAL*8".
*
************************************************************************
*
      SEGACT,MCOORD
*
*     RECHERCHE DES POINTS EXTREMES EN CAS DE DONNEE DE COURBES A
*     RACCORDER:
*
      IF (LI1COU .NE. 0) THEN
*        ON RELEVE LE DERNIER POINT DE LA LIGNE A RACCORDER EN TETE DE
*        LA COURBE:
         N = 1
*        (CURIEUSEMENT, C'EST LA VALEUR "1" QUI PERMET D'EXTRAIRE LE
*        DERNIER POINT)
         LI0COU = LI1COU
         IPT6=LI0COU
         SEGACT IPT6
         CALL EXTRPO (LI0COU,N,  PT0COU)
         IF (IERR .NE. 0) RETURN
         PT1COU = PT0COU
      END IF
*
      IF (LI2COU .NE. 0) THEN
*        ON RELEVE LE 1ER POINT DE LA LIGNE A RACCORDER A LA FIN DE LA
*        COURBE:
         N = 2
         LI0COU = LI2COU
         IPT6=LI0COU
         SEGACT IPT6
         CALL EXTRPO (LI0COU,N,  PT0COU)
         IF (IERR .NE. 0) RETURN
         PT2COU = PT0COU
      END IF
*
*     CALCUL DES COORDONNEES DES POINTS EXTREMES.
*
      MCOFCO = ICOFCO
      SEGACT,MCOFCO
      X1COU = POLYNO (COFCOU(1,1),ND1COU,1,U1COU)
      X2COU = POLYNO (COFCOU(1,1),ND1COU,1,U2COU)
      Y1COU = POLYNO (COFCOU(1,2),ND1COU,1,U1COU)
      Y2COU = POLYNO (COFCOU(1,2),ND1COU,1,U2COU)
      IF (IDIM .EQ. 3) THEN
         Z1COU = POLYNO (COFCOU(1,3),ND1COU,1,U1COU)
         Z2COU = POLYNO (COFCOU(1,3),ND1COU,1,U2COU)
      END IF
      SEGDES,MCOFCO
*
*     LES POINTS EXTREMES FOURNIS EXPLICITEMENT (LE CAS ECHEANT)
*     SONT-ILS ACCEPTABLES ?
*     (SINON, CREATION DE NOUVEAUX)
*
*     APPEL PROCEDURE INTERNE:
         PT0COU = PT1COU
         X0COU = X1COU
         Y0COU = Y1COU
         IF (IDIM .EQ. 3) Z0COU = Z1COU
         D0COU = D1COU
*        ASSIGN 105 TO IRTURN
         irturn=105
         GOTO 500
  105    CONTINUE
*     RETOUR DE PROCEDURE INTERNE.
      IF (PT1COU .NE. 0 .AND. PT1COU .NE. PT0COU) THEN
         IF (LI1COU .EQ. 0) THEN
            CALL ERREUR (295)
         ELSE
            CALL ERREUR (297)
         END IF
*        IL N'Y A PAS LIEU DE S'ARRETER POUR SI PEU.
      END IF
      PT1COU = PT0COU
      D1COU = D0COU
*
*     APPEL PROCEDURE INTERNE:
         PT0COU = PT2COU
         X0COU = X2COU
         Y0COU = Y2COU
         IF (IDIM .EQ. 3) Z0COU = Z2COU
         D0COU = D2COU
*        ASSIGN 205 TO IRTURN
         irturn=205
         GOTO 500
  205    CONTINUE
*     RETOUR DE PROCEDURE INTERNE.
      IF (PT2COU .NE. 0 .AND. PT2COU .NE. PT0COU) THEN
         IF (LI2COU .EQ. 0) THEN
            CALL ERREUR (296)
         ELSE
            CALL ERREUR (298)
         END IF
*        IL N'Y A PAS LIEU DE S'ARRETER POUR SI PEU.
      END IF
      PT2COU = PT0COU
      D2COU = D0COU
*
*     LES EXTREMITES ETANT MAINTENANT BIEN DEFINIES, ON APPELLE LE
*     SOUS-PROGRAMME DE MAILLAGE.
*
      CALL COURB2 (MCOURB,  LIGNE)
      IF (IERR .NE. 0) RETURN
*
*     SI DES LIGNES ONT ETE DONNEES AU LIEU DE POINTS EXTREMES,
*     L'OBJET RESULTAT N'EST PAS CE QUI VIENT D'ETRE CREE MAIS LA
*     REUNION DES ANCIENNES LIGNES ET DE CE QUI VIENT D'ETRE CREE:
*
      IF (LI1COU .NE. 0) THEN
         LI0COU = LI1COU
         ltelq=.false.
         CALL FUSE (LI0COU,LIGNE,  IP,ltelq)
         IF (IERR .NE. 0) RETURN
         LIGNE = IP
      END IF
      IF (LI2COU .NE. 0) THEN
         LI0COU = LI2COU
         ltelq=.false.
         CALL FUSE (LIGNE,LI0COU,  IP,ltelq)
         IF (IERR .NE. 0) RETURN
         LIGNE = IP
      END IF
*
      IF (IIMPI .EQ. 342) THEN
         IDIMP1 = IDIM + 1
         DO 400 IB=1,XCOOR(/1),IDIMP1
            IB2 = IB / IDIMP1 + 1
            WRITE (IOIMP,'(1X,I5,3(1X,G12.5))') IB2,XCOOR(IB)
     &      ,XCOOR(IB+1),XCOOR(IB+IDIM)
  400       CONTINUE
*        END DO
      END IF
*
      RETURN
*
*     ***********************
*     *  PROCEDURE INTERNE  *
*     ***********************
*
*     PARAMETRES:
*
*     PT0COU  (E)  POINT EXTREME PROPOSE.
*             (S)  POINT EXTREME FINALEMENT RETENU.
*     X0COU   (E)  )
*     Y0COU   (E)  )) COORDONNEES DU VERITABLE POINT EXTREME.
*     Z0COU   (E)  )
*     D0COU   E/S  DENSITE ASSOCIEE (LARGEUR DE MAILLE).
*     MCOORD  (E)  SEGMENT ACTIF.
*             (S)  CE SEGMENT EST EVENTUELLEMENT ETENDU.
*
  500 CONTINUE
*
      IF (PT0COU .NE. 0) THEN
         IPD = (PT0COU - 1) * (IDIM + 1)
         X0DONN = XCOOR(IPD+1)
         Y0DONN = XCOOR(IPD+2)
         IF (IDIM .EQ. 3) THEN
            Z0DONN = XCOOR(IPD+3)
            DIST = SQRT((X0COU-X0DONN)**2 + (Y0COU-Y0DONN)**2
     &                + (Z0COU-Z0DONN)**2)
         ELSE
            DIST = SQRT((X0COU-X0DONN)**2 + (Y0COU-Y0DONN)**2)
         END IF
         IF (D0COU .EQ. 0.) THEN
            IPD = PT0COU * (IDIM + 1)
            D0DONN = XCOOR(IPD)
            PETIT = D0DONN * 0.1
         ELSE
            PETIT = D0COU * 0.1
         END IF
         NOXTRM = DIST.GT.PETIT
      ELSE
         NOXTRM = .TRUE.
      END IF
*
      IF (NOXTRM) THEN
*        UN POINT EXTREME NON ACCEPTABLE A ETE FOURNI OU BIEN AUCUN
*        POINT N'A ETE FOURNI.
*        CREATION D'UN NOUVEAU POINT POUR L'EXTREMITE:
         IF (D0COU .EQ. 0.) THEN
            D0COU = DENSIT
         END IF
         CALL CREPO2 (X0COU,Y0COU,Z0COU,D0COU,  PT0COU)
         IF (IERR .NE. 0) RETURN
      ELSE IF (D0COU .EQ. 0.) THEN
*        POINT IMPOSE CORRECT ET PAS DE DENSITE IMPOSEE
*        --> ON PREND CELLE DU POINT IMPOSE:
         D0COU = D0DONN
*     ELSE
*        SI POINT IMPOSE CORRECT ET DENSITE FOURNIE, RIEN A FAIRE.
      END IF
*
      if (irturn.eq.105) goto 105
      if (irturn.eq.205) goto 205
      call erreur(5)
*
      END













