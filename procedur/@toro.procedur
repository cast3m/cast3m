$$$$ @TORO
* @TORO     PROCEDUR  CB215821  15/12/02    21:15:02     8719
*-------------------------------------------------
******          PROCEDURE @TORO             ******
*-------------------------------------------------
*
*
*    CETTE PROCEDURE A ETE MISE GRACIEUSEMENT
*   A DISPOSOTION DE LA COMMUNAUTE  CASTEM2000
*    PAR M. LIBEYRE ( CEA/DSM/DRFC )
*
*     TEL : ( 33 1 ) 42 25 46 03
*
*-------------------------------------------------
DEBPROC @TORO TAGEO*TABLE TABOB*TABLE ;
*
* Developpement et test de la procedure @TORO
* Projet DRFC/TO_PO Contrat n 30422676
*
opti dime 3 elem cub8 echo 0 ;
**********************************************************************
*                                                                    *
*                          T O R O                                   *
*                          -------                                   *
*                                                                    *
* Objet:                                                             *
* -----                                                              *
*                                                                    *
* Calcul de l'induction magnetique creee par un ensemble             *
* de bobines circulaires ou en 'D', reparties regulierement          *
* autour de l'axe Oz, en l'absence de fer.                           *
*                                                                    *
* Syntaxe:                                                           *
* -------                                                            *
*                                                                    *
* TABCHB TAB2 = @TORO TAGEO1 TABOB1 ;                                *
*                                                                    *
* En entree :                                                        *
*                                                                    *
*                                                                    *
* TAGEO1        table des domaines de calcul du champ                *
*    TAGEO1.i   geometrie ou le champ est calcule (type TABLE)       *
*    TAGEO1.i.'mail' : maillage de la geometrie (type MAILLAGE)      *
*                                                                    *
* TABOB         table a deux indices contenant les donnees           *
*               relatives aux bobines (type TABLE)                   *
*       .GENE    table                                               *
*             .1 nbob: nombre de bobines (type ENTIER)               *
*             .2 b: largeur des bobines (type FLOTTANT)              *
*             .3 h: hauteur des bobines (type FLOTTANT)              *
*             .4 cbob: centre de la bobine (type POINT)              *
*             .5 vn: vecteur normal au plan de la bobine (type POINT)*
*             .6 tsol: table des solenations des bobines             *
*                     .i solenation (courant * nombre de spires)     *
*                        de la bobine i (type FLOTTANT)              *
*             .7 rt: rayon du tore (type FLOTTANT)                   *
*             .8 ri: nombre de bobines (type FLOTTANT)               *
*       .TYPE     'c' pour une bobine circulaire                     *
*                 'd' pour une bobine en 'D'                         *
*       .TRAC1 si oui : trace du maillage des bobines (type LOGIQUE) *
*       .CBIOT si oui : calcul de l'induction magnetique             *
*       .D       = troncon : table des troncons:                     *
*                  troncon.j = troncj : table du troncon j:          *
*                     troncj.'l' longueur du troncon si rectiligne,  *
*                           .'r' rayon de courbure et                *
*                           .'alpha' angle de courbure si courbe     *
*                                                                    *
* En sortie :                                                        *
*                                                                    *
*                                                                    *
* TABCHB        table contenant (type TABLE)                         *
*    i          champ de Biot et Savart relatif au i-eme             *
*               maillage GEO1 (type CHPOINT)                         *
*                                                                    *
* TAB2          table contenant (type TABLE)                         *
* BOBMAI.i      maillage de chaque bobine (type MAILLAGE)            *
* CONT.j        ensemble des coupes sur le plan j                    *
*               (type MAILLAGE)                                      *
*                                                                    *
* Remarques:                                                         *
* ---------                                                          *
*                                                                    *
* Les grandeurs suivantes sont "en dur" dans la procedure :          *
*                                                                    *
* NELE          nombre d'elements generes lors des rotations         *
*               et des translations effectuees pendant la            *
*               creation du maillage des bobines.                    *
*                                                                    *
* COEF1         coefficient etablissant la distance critique         *
*               de selection des points lors de la recherche         *
*               de contour.                                          *
*                                                                    *
**********************************************************************
isym = 0 ;
*
* Valeurs de quelques constantes
*
pi = PI ;
mu0 = 4.e-7 * pi ;
eps = 1.e-3 ;
nele = 4 ;
alpha = 90. ;
oeil = 100. 20. 10. ;
*
* creation du maillage
*
tab2 = table ;
tabmai = table ;
tab2.bobmai = tabmai ;
ibob = 1 ;
repeter proc 1 ;
   sauter 1 ligne ;
   mess ' ************ procedure @TORO' ;
   sauter 1 ligne ;
   ngeo = dime tageo1 ;
   si (ega ngeo 0) ;
      mess ' **** Il n y a pas de domaine de calcul ;
   sinon ;
      si (ega ngeo 1) ;
         mess ' **** Il y a un seul domaine de calcul' ;
      sinon ;
         mess ' **** Il y a' ngeo 'domaines de calcul ;
      finsi ;
   finsi ;
   si (existe tabob type) ;
      typbob = tabob.type ;
   sinon ;
      mess '  ***  erreur : indice type inexistant' ;
      quitter proc ;
   finsi ;
   si (existe tabob gene) ;
      tcara = table ;
      tcara = tabob.gene ;
      si (existe tcara 1) ;
         nbob*entier = tcara.1 ;
      sinon ;
         mess ' *** erreur ; il manque nbob !!' ;
         quitter proc ;
      finsi ;
      si (existe tcara 2) ;
         b*flottant = tcara.2 ;
      sinon ;
         mess ' *** erreur ; il manque b !!' ;
         quitter proc ;
      finsi ;
      si (existe tcara 3) ;
         h*flottant = tcara.3 ;
      sinon ;
         mess ' *** erreur ; il manque nbob !!' ;
         quitter proc ;
      finsi ;
      si (existe tcara 4) ;
         cbob*point = tcara.4 ;
      sinon ;
         mess ' *** erreur ; il manque cbob !!' ;
         quitter proc ;
      finsi ;
      si (existe tcara 5) ;
         v*point = tcara.5 ;
      sinon ;
         mess ' *** erreur ; il manque v !!' ;
         quitter proc ;
      finsi ;
      si (existe tcara 6) ;
         tabsol = table ;
         tabsol = tcara.6 ;
      sinon ;
         mess ' *** erreur ; il manque tabsol !!' ;
         quitter proc ;
      finsi ;
      si (existe tcara 7) ;
         rt*flottant = tcara.7 ;
      sinon ;
         mess ' *** erreur ; il manque rt !!' ;
         quitter proc ;
      finsi ;
      si (existe tcara 8) ;
         ri*flottant = tcara.8 ;
      sinon ;
         mess ' *** erreur ; il manque ri !!' ;
         quitter proc ;
      finsi ;
   sinon ;
      mess '  ***  erreur : indice gene inexistant' ;
   finsi ;
*
   si (ega typbob 'c') ;
       sauter 1 ligne ;
       mess ' ******* bobine circulaire *********' ;
   sinon;
      si (ega typbob 'd') ;
          si (existe tabob 'd') ;
             sauter 1 ligne ;
             mess ' ******* bobine en D *********' ;
             sauter 1 ligne ;
          sinon;
             mess ' erreur bobine D : indice d inexistant' ;
          finsi;
      sinon;
         mess '*********  erreur bobine  ***********' ;
         quitter proc ;
      finsi;
   finsi ;
*-----------------------------------------------------------------
*       fin de l'analyse syntaxique
*-----------------------------------------------------------------
   c1 c2 c3 = coor cbob ;
   o1 = cbob plus (0. (0. - rt) 0.) ;
   o2 = o1 plus (0. 0. 10.) ;
*
*  calcul du vecteur norme vnor normal au plan de la bobine
*
   v1 v2 v3 = coor v ;
*
   vn = ( (v1**2) + (v2**2) + (v3**2) )**0.5 ;
   si (vn ega 0.);
      mess '  ***  erreur: vecteur vn nul !' ;
      quitter proc ;
   finsi  ;
   vn1 = v1/vn ; vn2 = v2/vn ; vn3 = v3/vn ;
   vnor = vn1 vn2 vn3 ;
   ovn = o1 plus (v1 v2 v3) ;
*
*  calcul du vecteur norme wn normal a vnor (dans le plan de la bobine
*   et dans le plan xOy) et du vecteur t tangent au troncon
*
   si (vn3 ega 0.);
      t0 = 0. 0. 1. ;
      wn = pvec t0 vnor ;
   sinon ;
      si ( (non (ega vn1 0.)) ou (non (ega vn2 0.)) ) ;
         wn = pvec (0. 0. 1.) vnor ;
         t0 = pvec vnor wn ;
      sinon ;
         wn = 0. 1. 0. ;
         t0 = 1. 0. 0. ;
      finsi ;
   finsi ;
   xt0 yt0 zt0 = coor t0 ;
   t = t0 plus (0. 0. 0.) ;
   wn1 wn2 wn3 = coor wn ;
*-----------------------------------------------------------
* test sur le domaine de calcul
*-----------------------------------------------------------
   itest = table ;
   igeo1 = 0 ;
   repeter bgeo1 ngeo ;
      igeo1 = igeo1 + 1 ;
      si (existe tageo1 igeo1) ;
          lmot = ((tageo1.igeo1).'mail') elem 'TYPE' ;
          nbeldom = nbel (tageo1.igeo1).'mail' ;
          nmot = dime lmot ;
          imot = 0 ;
          repeter boutyp nmot ;
            imot = imot + 1 ;
            mot1 = extr lmot imot ;
            mess ' *** domaine numero' igeo1
                 'compose de' nbeldom 'elements ' mot1 ;
            sauter 1 ligne ;
* domaine plan
             si ( (ega mot1 'TRI3') ou (ega mot1 'QUA4') ou
                  (ega mot1 'TRI6') ou (ega mot1 'QUA8') ) ;
                elem1 = ((tageo1.igeo1).'mail') elem 1 ;
                elem2 = chan poi1 elem1 ;
                pel1 = elem2 poin 1 ;
                pel2 = elem2 poin 2 ;
                pel3 = elem2 poin 3 ;
                zpel1 = coor 3 pel1 ;
                zpel2 = coor 3 pel2 ;
                zpel3 = coor 3 pel3 ;
                phori = (ega zpel1 zpel2 1.E-5) et
                        (ega zpel1 zpel3 1.E-5) ;
                si (phori) ;
                   (tageo1.igeo1).'ZP' = zpel1 ;
                   (tageo1.igeo1).'PP' = pel1 ;
                   (tageo1.igeo1).'VP' = 0. 0. 1. ;
                   pequa = phori et (ega zpel1 0.) ;
                   si (pequa et (ega v3 0.)) ;
                      itest.igeo1 = 0 ;
                      isym = 1 ;
                   sinon ;
                      si ((ega typbob 'c') et (ega v3 0.)) ;
* calcul analytique pour une bobine circulaire verticale
                         itest.igeo1 = 1 ;
                      sinon ;
* calcul d'intersection de Denis
                         itest.igeo1 = 2 ;
                      finsi ;
                   finsi ;
                sinon ;
                   itest.igeo1 = -2 ;
                finsi ;
                quitter boutyp ;
            sinon ;
* domaine volumique
               itest.igeo1 = -1 ;
            finsi ;
         fin boutyp ;
*         sauter 1 ligne ;
*         mess '  ****** itest =' itest.igeo1 ;
*         sauter 1 ligne ;
      sinon ;
         quitter bgeo1 ;
      finsi ;
   fin bgeo1 ;
*--------------------------------------------------------------
*  construction des points de la section initiale de la bobine
*--------------------------------------------------------------
   re = ri + b ;
   p11 = c1 + (ri*wn1) - ((h/2.)*vn1) ;
   p12 = c2 + (ri*wn2) - ((h/2.)*vn2) ;
   p13 = c3 + (ri*wn3) - ((h/2.)*vn3) ;
   p21 = c1 + (re*wn1) - ((h/2.)*vn1) ;
   p22 = c2 + (re*wn2) - ((h/2.)*vn2) ;
   p23 = c3 + (re*wn3) - ((h/2.)*vn3) ;
   p31 = c1 + (re*wn1) + ((h/2.)*vn1) ;
   p32 = c2 + (re*wn2) + ((h/2.)*vn2) ;
   p33 = c3 + (re*wn3) + ((h/2.)*vn3) ;
   p41 = c1 + (ri*wn1) + ((h/2.)*vn1) ;
   p42 = c2 + (ri*wn2) + ((h/2.)*vn2) ;
   p43 = c3 + (ri*wn3) + ((h/2.)*vn3) ;
*
* points de la base
*
   p1 = p11 p12 p13 ; p2 = p21 p22 p23 ;
   p3 = p31 p32 p33 ; p4 = p41 p42 p43 ;
* barycentre de la base:
   pp11 = (p11 + p21 + p31 + p41)/4. ;
   pp12 = (p12 + p22 + p32 + p42)/4. ;
   pp13 = (p13 + p23 + p33 + p43)/4. ;
   pp1 = pp11 pp12 pp13 ;
*
* segments de la base
*
   d1 = droi 1 p1 p2 ; d2 = droi 1 p2 p3 ;
   d3 = droi 1 p3 p4 ; d4 = droi 1 p4 p1 ;
   cont1 = p1 d 1 p2 d 1 p3 d 1 p4 d 1 p1 ;
*
   cvn = cbob plus (vn1 vn2 vn3) ;
*-----------------------------------------
*  construction des surfaces laterales
*-----------------------------------------
   si (ega typbob 'c') ;
      tquart = table ;
      pp2 = pp1 tour alpha cbob cvn ;
*
      surf1 = d1 rota nele alpha cbob cvn ;
      surf2 = d2 rota nele alpha cbob cvn ;
      surf3 = d3 rota nele alpha cbob cvn ;
      surf4 = d4 rota nele alpha cbob cvn ;
*
      surfbo1 = surf1 et surf2 et surf3 et surf4 ;
      tquart.1 = surfbo1 ;
      xn1 = (vn2*wn3) - (vn3*wn2) ;
      xn2 = (vn3*wn1) - (vn1*wn3) ;
      xn3 = (vn1*wn2) - (vn2*wn1) ;
      p51 = c1 + (ri*xn1) - ((h/2.)*vn1) ;
      p52 = c2 + (ri*xn2) - ((h/2.)*vn2) ;
      p53 = c3 + (ri*xn3) - ((h/2.)*vn3) ;
      p61 = c1 + (re*xn1) + ((h/2.)*vn1) ;
      p62 = c2 + (re*xn2) + ((h/2.)*vn2) ;
      p63 = c3 + (re*xn3) + ((h/2.)*vn3) ;
      p5 = p51 p52 p53 ; p6 = p61 p62 p63 ;
      surfbo2 = surfbo1 syme plan cbob p5 p6 ;
*
      tquart.2 = surfbo2 ;
      tquart.3 = surfbo2 syme plan cbob p1 p2 ;
      tquart.4 = surfbo1 syme plan cbob p1 p2 ;
      cont2 = cont1 syme plan cbob p5 p6 ;
      demisurf = (surfbo1 et surfbo2) ;
   finsi ;
*-------------------------------------------------
   si (ega typbob 'd') ;
      troncon = table ;
      troncon = tabob.'d' ;
      ntron = dime troncon ;
*      mess ' ****************** Il y a' ntron 'troncons' ;
      itron = 1 ;
      troncj = table ;
      repeter btron ntron ;
         troncj = troncon.itron ;
         si ( (existe troncj 'l') et (non (existe troncj 'r')) et
              (non (existe troncj 'alpha')) ) ;
            mess ' ******  troncon no' itron 'rectiligne' ;
            lj = troncj.'l' ;
            si (itron ega 1) ;
               pp2 = pp1 plus ((xt0*lj) (yt0*lj) (zt0*lj)) ;
               vdir = (xt0*lj) (yt0*lj) (zt0*lj) ;
            sinon ;
               xt yt1 zt1 = coor t ;
               xpp2 ypp2 zpp2 = coor pp2 ;
               pp1 = xpp2 ypp2 zpp2 ;
               xg = xt*lj ;
               yg = yt1*lj ;
               zg = zt1*lj ;
               pp2 = pp1 plus (xg yg zg) ;
               vdir = xg yg zg ;
            finsi ;
            surf1 = d1 tran nele vdir ;
            d1 = d1 plus vdir ;
            surf2 = d2 tran nele vdir ;
            d2 = d2 plus vdir ;
            surf3 = d3 tran nele vdir ;
            d3 = d3 plus vdir ;
            surf4 = d4 tran nele vdir ;
            d4 = d4 plus vdir ;
            surfboj = surf1 et surf2 et surf3 et surf4 ;
*
* conservation des points definissant le troncon rectiligne
*
            troncj.'pp1' = pp1 ;
            troncj.'pp2' = pp2 ;
            troncj.'pp3' = cbob ;
         sinon ;
            si ( (existe troncj 'r') et (existe troncj 'alpha')
               et (non (existe troncj 'l')) ) ;
               mess ' ******  troncon no' itron 'courbe' ;
               rj = troncj.'r' ;
               alphaj = troncj.'alpha' ;
               si (itron ega 1) ;
                  si (dbob > 0.) ;
                     crj = cbob plus (0. (dbob - rj) 0.) ;
                  sinon ;
                     crj = cbob plus (0. (dbob + rj) 0.) ;
                  finsi ;
               sinon ;
                  xpp2 ypp2 zpp2 = coor pp2 ;
                  pp1 = xpp2 ypp2 zpp2 ;
                  xt yt1 zt1 = coor t ;
*  vecteur norme vr perpendiculaire a vnor et t
                  si (alphaj > 0.) ;
                     vr = vnor pvec t ;
                  sinon ;
                     vr = t pvec vnor ;
                  finsi ;
                  xvr yvr zvr = coor vr ;
                  xcrj = xpp2 + ((rj+(b/2.))*xvr) ;
                  ycrj = ypp2 + ((rj+(b/2.))*yvr) ;
                  zcrj = zpp2 + ((rj+(b/2.))*zvr) ;
                  crj = xcrj ycrj zcrj ;
               finsi ;
               cvn = crj plus (vn1 vn2 vn3) ;
               surf1 = d1 rota nele alphaj crj cvn ;
               d1 = d1 tour alphaj crj cvn ;
               surf2 = d2 rota nele alphaj crj cvn ;
               d2 = d2 tour alphaj crj cvn ;
               surf3 = d3 rota nele alphaj crj cvn ;
               d3 = d3 tour alphaj crj cvn ;
               surf4 = d4 rota nele alphaj crj cvn ;
               d4 = d4 tour alphaj crj cvn ;
               surfboj = surf1 et surf2 et surf3 et surf4 ;
*
*  barycentre de la section finale
*
               pp2 = pp1 tour alphaj crj cvn ;
* conservation du point definissant le centre du troncon courbe
               troncj.'crj' = crj ;
*
* construction du nouveau vecteur tangent t (par rotation de alphaj)
*
               t = t tour alphaj o1 ovn ;
               troncj.'pp1' = pp1 ;
               troncj.'pp2' = pp2 ;
            sinon ;
               mess ' erreur : troncon mal defini ' ;
               quitter proc ;
            finsi ;
         finsi ;
         troncj.'mail' = surfboj ;
         si (itron ega 1) ;
            demisurf = surfboj ;
         sinon ;
            demisurf = demisurf et surfboj ;
         finsi ;
         troncon.itron = troncj ;
         itron = itron + 1 ;
      fin btron ;
      cont2 = d1 et d2 et d3 et d4 ;
      elim 1.E-3 cont2 ;
*---------------------------------------------------------
* construction des troncons inferieurs par symetrie / xOy
*---------------------------------------------------------
      si (ega isym 0);
         itron = 1 ;
         repeter btron2 ntron ;
            troncj = troncon.itron ;
            itron2 = (2*ntron) - itron + 1 ;
            troncj2 = table ;
            troncj2.'mail' = (troncj.'mail') syme plan o1 cbob cvn ;
            si ( (existe troncj 'r') et (existe troncj 'alpha')
              et (non (existe troncj 'l')) ) ;
                crj = (troncj.'crj') syme plan cbob p1 p2  ;
                pp1 = (troncj.'pp2') syme plan cbob p1 p2  ;
                pp2 = (troncj.'pp1') syme plan cbob p1 p2  ;
                troncj2.'crj' = crj ;
                troncj2.'pp1' = pp1 ;
                troncj2.'pp2' = pp2 ;
                troncj2.'r' = troncj.'r' ;
                troncj2.'alpha' = troncj.'alpha' ;
            finsi ;
            si ( (existe troncj 'l') et (non (existe troncj 'r')) et
               (non (existe troncj 'alpha')) ) ;
                pp1 = (troncj.'pp2') syme plan cbob p1 p2  ;
                pp2 = (troncj.'pp1') syme plan cbob p1 p2  ;
                troncj2.'pp1' = pp1 ;
                troncj2.'pp2' = pp2 ;
                troncj2.'pp3' = cbob ;
                troncj2.'l' = troncj.'l' ;
            finsi ;
            troncon.itron2 = troncj2 ;
            itron = itron + 1 ;
         fin btron2 ;
      finsi ;
   finsi ;
*----------------------------------------------------------------------
* construction du symetrique du maillage de la bobine par rapport a xOy
*----------------------------------------------------------------------
   surfbob = demisurf et (demisurf syme plan cbob p1 p2 ) ;
   elim eps surfbob ;
   mess 'construction de la premiere bobine effectuee' ;
*-----------------------------------------------------------
* construction des autres bobines par rotation autour de Oz
*-----------------------------------------------------------
   ibob = 1 ;
   tabmai.ibob = surfbob ;
   surftot = surfbob ;
   si (nbob > 1) ;
      repeter bbob (nbob-1) ;
         ibob = ibob + 1 ;
         angln = (ibob-1)*360./nbob ;
         surfbobn = surfbob tour angln o1 o2 ;
         tabmai.ibob = surfbobn ;
         surftot = surftot et tabmai.ibob ;
         mess 'construction de la bobine' ibob 'effectuee' ;
      fin bbob ;
   finsi ;
*
* construction des axes
*
   x1 = (2.*rt) 0. 0. ;
   y1 = 0. (2.*rt) 0. ;
   z1 = 0. 0. (2.*rt) ;
   axes = (o1 d 1 x1) et (o1 d 1 y1) et (o1 d 1 z1) ;
   axes = axes coul rouge ;
   si (ega tabob.trac1 'oui') ;
      trac oeil cach (surftot et axes) ;
   finsi ;
fin proc ;
****************************************
* calcul des champs de biot et savart  *
****************************************
tabchb = table ;
tab2.cont = table ;
re = ri + b ;
igeo1 = 0 ;
si (ega tabob.cbiot 'oui') ;
   repeter bogeo1 ngeo ;
      igeo1 = igeo1 + 1 ;
      mess ' *** Domaine de calcul du champ numero' igeo1 ;
      si (itest.igeo1 > -1) ;
         tabcon = table ;
      finsi ;
      si (existe tageo1 igeo1) ;
         geo1 = (tageo1.igeo1).'mail' ;
         chp0 = manu chpo geo1 3 bx 0. by 0. bz 0. ;
         ibob = 0 ;
         repeter bbob2 nbob ;
            ibob = ibob + 1 ;
            si (existe tabsol ibob) ;
               sol = tabsol.ibob ;
               dens = sol/(b*h) ;
            finsi ;
            si (ega typbob 'c') ;
               mess ' *** BIOT ; induction magnetique cree par '
                    'la bobine circulaire numero' ibob ;
               mess 'dont la solenation est' sol ;
               sauter 1 ligne ;
               si (ega ibob 1) ;
                  chb1 = biot geo1 cerc cbob pp1 pp2 ri re h dens mu0 ;
               sinon ;
                  anglj = 360./nbob ;
                  cbob = cbob tour anglj o1 o2 ;
                  pp1 = pp1 tour anglj o1 o2 ;
                  pp2 = pp2 tour anglj o1 o2 ;
                  chb1 = chb1 et
                 (biot geo1 cerc  cbob  pp1  pp2 ri re h dens mu0) ;
               finsi ;
            sinon ;
               sauter 1 ligne ;
               mess ' *** BIOT ; induction magnetique cree par '
                    'la bobine en D numero' ibob ;
               mess 'dont la solenation est' sol ;
               sauter 1 ligne ;
               itron = 0 ;
               ntron = dime troncon ;
               repeter bbob3 ntron ;
                  itron = itron + 1 ;
                  troncj = troncon.itron ;
*
*  troncon courbe
*
                si ( (existe troncj 'r') et (existe troncj 'alpha') ) ;
*                     mess ' troncon numero' itron;
                     ri = troncj.'r' ;
                     re = ri + b ;
                     crj = troncj.'crj' ;
                     pp1 = troncj.'pp1' ;
                     pp2 = troncj.'pp2' ;
*                     mess '** ri' ri ;
*                     list crj ;
*                     list pp1 ;
*                     list pp2 ;
                     si ( (ega ibob 1) et (ega itron 1) ) ;
                        mess ' *** premier troncon courbe ' ;
                 chb1 = biot geo1 arc crj pp1 pp2 ri re h dens mu0 ;
                     sinon ;
                        mess ' *** troncon courbe numero' itron;
                        si (ibob > 1) ;
                           teta = (ibob - 1)*360./nbob ;
                           tcrj = crj tour teta o1 o2 ;
                           tpp1 = pp1 tour teta o1 o2 ;
                           tpp2 = pp2 tour teta o1 o2 ;
             chb1j = biot geo1 arc tcrj tpp1 tpp2 ri re h dens mu0 ;
                           chb1 = chb1 et chb1j ;
                        sinon ;
                chb1j = biot geo1 arc crj pp1 pp2 ri re h dens mu0 ;
                           chb1 = chb1 et chb1j ;
                        finsi ;
                     finsi ;
                  finsi ;
*
*  troncon rectiligne
*
                  si (existe troncj 'l') ;
*                     mess ' troncon numero' itron;
                     pp1 = troncj.'pp1' ;
                     pp2 = troncj.'pp2' ;
                     pp3 = troncj.'pp3' ;
*                     list pp1 ;
*                     list pp2 ;
*                     list pp3 ;
                     si ((ega ibob 1) et (ega itron 1));
                        mess ' *** premier troncon rectiligne' ;
                        chb1 = biot geo1 barr pp1 pp2 pp3 b h dens mu0 ;
                     sinon ;
                        mess ' *** troncon rectiligne numero' itron;
                        si (ibob > 1) ;
                           teta = (ibob - 1)*360./nbob ;
                           tpp1 = pp1 tour teta o1 o2 ;
                           tpp2 = pp2 tour teta o1 o2 ;
                           tpp3 = pp3 tour teta o1 o2 ;
                    chb1j = biot geo1 barr tpp1 tpp2 tpp3 b h dens mu0 ;
                           chb1 = chb1 et chb1j ;
                        sinon ;
                    chb1j = biot geo1 barr pp1 pp2 pp3 b h dens mu0 ;
                           chb1 = chb1 et chb1j ;
                        finsi ;
                     finsi ;
                  finsi ;
                 si (ega isym 1) ;
                    mess ' ***** calcul du champ par symetrie / xOy ' ;
                    si ( (ega ibob 1) et (ega itron 1) ) ;
                       chb1x = exco 'BX' chb1 'BX' ;
                       chb1y = exco 'BY' chb1 'BY' ;
                       chb1z = exco 'BZ' chb1 'BZ' ;
                       chb2z = chb1z*(-1.) ;
                       chb2 = chb1x et chb1y et chb2z ;
                       chb1 = chb1 et chb2 ;
                    sinon ;
                       chb1x = exco 'BX' chb1j 'BX' ;
                       chb1y = exco 'BY' chb1j 'BY' ;
                       chb1z = exco 'BZ' chb1j 'BZ' ;
                       chb2z = chb1z*(-1.) ;
                       chb2 = chb1x et chb1y et chb2z ;
                       chb1 = chb1 et chb2 ;
                    finsi ;
                finsi ;
              fin bbob3 ;
           finsi ;
        fin bbob2 ;
        tabchb.igeo1 = chb1 ;
*----------------------------------------------------
* calcul des intersections pour le plan igeo1
*----------------------------------------------------
        si (ega itest.igeo1 0) ;
           tabcon.1 = cont1 et cont2 ;
        finsi ;
        si (ega itest.igeo1 1) ;
*----------------------------------------------------------------
*  calcul analytique de l'intersection d'une bobine circulaire
*       verticale avec un plan
*----------------------------------------------------------------
            mess ' **** calcul analytique dans le cas'
                           'de la bobine circulaire' ;
            sauter 1 ligne ;
            zp = (tageo1.igeo1).'ZP' ;
            mess ' **** plan a la cote' zp ;
            x1 = h/2.;
            cbob*point = tcara.4 ;
            cxn = cbob plus (1. 0. 0.) ;
            czn = cbob plus (0. 0. 1.) ;
            si (zp < ri) ;
               cos1 = ((ri**2.) - (zp**2.) )**0.5 ;
               beta1 = atg zp cos1 ;
               y1 = ri*(cos beta1) ;
               pc1 = cbob plus (x1 y1 zp) ;
               pc2 = cbob plus ( (0. - x1) y1 zp ) ;
*
               cos2 = ((re**2.) - (zp**2.) )**0.5 ;
               beta2 = atg zp cos2 ;
               y2 = re*(cos beta2) ;
               pc3 = cbob plus (x1 y2 zp) ;
               pc4 = cbob plus ( (0. - x1) y2 zp ) ;
*
               cont1 = pc1 d 1 pc2 d 1 pc4 d 1 pc3 d 1 pc1 ;
               tabcon.1 = cont1 et (cont1 syme plan cbob cxn czn) ;
            sinon ;
               si (zp < re) ;
                  cos2 = ((re**2.)- (zp**2.) )**0.5 ;
                  beta2 = atg zp cos2 ;
                  y2 = re*(cos beta2) ;
                  pc1 = cbob plus (x1 y2 zp) ;
                  pc2 = cbob plus ( (0. - x1) y2 zp ) ;
                  pc3 = pc2 syme plan cbob cxn czn ;
                  pc4 = pc1 syme plan cbob cxn czn ;
                  cont1 = pc1 d 1 pc2 d 1 pc3 d 1 pc4 d 1 pc1 ;
                  tabcon.1 = cont1 ;
               sinon ;
                  mess ' ***** le plan ne coupe pas les bobines !!' ;
               finsi ;
            finsi ;
            si (non (ega vn2 0.)) ;
                gama1 = atg vn2 vn1 ;
                tabcon.1 = tabcon.1 tour gama1 cbob czn ;
            finsi ;
         finsi ;
         si (ega itest.igeo1 2) ;
*            mess 'Algorithme Denis Robert' ;
*------------------------------------------------------------------
*   Algorithme de recherche des contours des bobines
*------------------------------------------------------------------
            repeter bouci 1 ;
           'SAUTER' 1 'LIGNE' ;
           'MESS' 'Contour des bobines dans le domaine' igeo1 ;
           'MESS' '-------------------------------------------' ;
           TABLIG   = TABLE ;
           TAB2.LIG = TABLIG ;
           COUP1 = tageo1.igeo1 ;
           IRECUP = 0 ;
             'SI' ( 'EXISTE' COUP1 'PP' ) ;
                 PP*'POINT' = COUP1.'PP' ;
             'SINON' ;
                'SAUTER' 1 'LIGNE' ;
                'MESS' 'Erreur : il manque PP pour le plan ' igeo1 ;
                'SAUTER' 1 'LIGNE' ;
                IERR = 1 ; 'QUITTER' BOUCI;
             'FINSI' ;
             'SI' ( 'EXISTE' COUP1 'VP' ) ;
                 VP*'POINT' = COUP1.'VP' ;
             'SINON' ;
                'SAUTER' 1 'LIGNE' ;
                'MESS' 'Erreur : il manque VP pour le plan ' igeo1 ;
                'SAUTER' 1 'LIGNE' ;
                IERR = 1 ; 'QUITTER' BOUCI ;
             'FINSI' ;
*
*     Trois points vont definir ce plan : PP PP2 et PP3
*
              PP11 PP12 PP13 = COORD PP ;
              VP1 VP2 VP3 = COORD VP ;
*
*     Vecteur WN tq : VP1 WN1 + VP2 WN2 + VP3 WN3 = 0
*
              VPN1 = ( (VP1**2) + (VP2**2) + (VP3**2) ) ** 0.5 ;
              'SI' ( VPN1 'EGA' 0. ) ;
                'SAUTER' 1 'LIGNE' ;
                'MESS' 'ERREUR : plan ' igeo1 ' le vecteur VP est nul';
                'SAUTER' 1 'LIGNE' ;
                IERR = 1 ; 'QUITTER' BOUCI ;
              'FINSI' ;
              VN1 = VP1 / VPN1 ; VN2 = VP2 / VPN1 ; VN3 = VP3 / VPN1 ;
              VPN = VN1 VN2 VN3 ;
             'SI' ( VN1 'NEG' 0. ) ;
                 'SI' ( VN2 'NEG' 0. ) ;
                     'SI' ( VN3 'NEG' 0. ) ;
                          W2 = VN3 / VN2 ; W3 = -1 ;
                          WN = ( (W2**2) + (W3**2) ) ** 0.5 ;
                          WN1 = 0. ; WN2 = W2 / WN ; WN3 = W3 / WN ;
                     'SINON' ;
                          WN1 = 0. ; WN2 = 0. ; WN3 = 1. ;
                     'FINSI' ;
                 'SINON' ;
                     'SI' ( VN3 'NEG' 0. ) ;
                          WN1 = 0. ; WN2 = 1. ; WN3 = 0. ;
                     'SINON' ;
                          WN1 = 0. ; WN2 = 0. ; WN3 = 1. ;
                     'FINSI' ;
                 'FINSI' ;
              'SINON' ;
                  WN1 = 1. ; WN2 = 0. ; WN3 = 0. ;
              'FINSI' ;
*
               XN1 = (VN2 * WN3) - (VN3 * WN2) ;
               XN2 = (VN3 * WN1) - (VN1 * WN3) ;
               XN3 = (VN1 * WN2) - (VN2 * WN1) ;
*
*     WN et XN forment une base du plan de coupe
*
               PP21 = PP11 + WN1 ; PP22 = PP12 + WN2 ;
               PP23 = PP13 + WN3 ; PP31 = PP11 + XN1 ;
               PP32 = PP12 + XN2 ; PP33 = PP13 + XN3 ;
               PP2 = PP21 PP22 PP23 ; PP3 = PP31 PP32 PP33 ;
*
*     Intersection de ce plan avec la bobine IBO
*
               IINTER = 0 ;
*
*           On traite separement chaque troncon
*
               IINTEI = 0 ;
               itron = 0 ;
               si (ega typbob 'd') ;
                  ntron = dime tabob.'d' ;
               sinon ;
                  ntron = 4 ;
               finsi ;
              'REPETER' boutron ntron ;
                  itron = itron + 1 ;
                  si (ega typbob 'd') ;
                     MAI0 = (tabtron.itron).'mail' ;
                  sinon ;
                     MAI0 = tquart.itron ;
                  finsi ;
                  MAI1 = 'CHANGER' 'POI1' MAI0 ;
                  NBP1 = 'NBNO' MAI1 ;
                  'MESS' '---> troncon de bobine : ' itron ;
                  'MESS' '---> Nbre de pts     : ' NBP1 ;
                  IP1 = 1 ;
                  IDESSOUS = 0 ; IDESSUS = 0 ; IDEDANS = 0 ;
                  DMOY = 0. ;
                  'REPETER' BOUCPOI1 NBP1 ;
                      PO1 = MAI1 'POIN' IP1 ;
                      POX1 POY1 POZ1 = 'COORD' PO1 ;
                      MX1 = POX1 - PP11 ; MY1 = POY1 - PP12 ;
                      MZ1 = POZ1 - PP13 ;  M1 = MX1 MY1 MZ1 ;
                      PDT1 = M1 'PSCAL' VPN ;
                      DMOY = DMOY + ('ABS' (PDT1)) ;
                      'SI' ( ( 'ABS' PDT1 ) < 0.001 ) ;
                          IDEDANS = IDEDANS + 1 ;
                      'FINSI' ;
                      'SI' ( PDT1 '<EG' -0.001 ) ;
                          IDESSOUS = IDESSOUS + 1 ;
                      'FINSI' ;
                      'SI' ( PDT1 '>EG' 0.001 ) ;
                          IDESSUS = IDESSUS + 1 ;
                      'FINSI' ;
                      'SI' ( IP1 'EGA' 1 ) ;
                         LISPDT = 'PROG' PDT1 ;
                      'SINON' ;
                         LISPDT = LISPDT 'ET' ( 'PROG' PDT1 ) ;
                      'FINSI' ;
                      IP1 = IP1 + 1 ;
                  'FIN' BOUCPOI1 ;
*+*
*+*            Distance de selection des points a projeter
*+*            on divise DMOY par 2 si NELE = 4
*+*                               3           8
               COEF1 = 2. ;
               DMOY = DMOY / NBP1 ;
               DCRIT = DMOY / COEF1 ;
*
*              tests sur la repartition des points / plan de coupe
*
               'SI' ( IDEDANS '>EG' 4 ) ;
                  ICAS = 1 ;
               'SINON' ;
                  'SI' ( IDESSUS > IDESSOUS ) ;
                     ICAS = 2 ;
                  'SINON' ;
                     ICAS = 3 ;
                  'FINSI' ;
               'FINSI' ;
*
               'SI' ((( IDESSOUS '>EG' 1 ) 'ET' ( IDESSUS '>EG' 1 ))
                     'OU' ( IDEDANS '>EG' 1 )) ;
                  IINTER = IINTER + 1 ;
                  IINTEI = IINTEI + 1 ;
                     'MESS' 'Il y a une intersection ...' ;
*
*                 On ne retient que les points les plus proches du
*                 plan de coupe Pc
*
                  IREC = 0 ;
                  'REPETER' BOUCREC 7 ;
                     IREC = IREC + 1 ;
                     IP2 = 1 ; IOK = 0 ;
                     'REPETER' BOUCTRI NBP1 ;
                        VAL1 = 'EXTRAIRE' LISPDT IP2 ;
            'SI' ( ( ICAS 'EGA' 1 ) et (('ABS' VAL1 ) '<EG' 0.001) );
                               IOK = IOK + 1 ;
                              'SI' ( IOK 'EGA' 1 ) ;
                                 MAI2 = MAI1 'POIN' IP2 ;
                              'SINON' ;
                                 MAI2 = MAI2 'ET' ( MAI1 'POIN' IP2 ) ;
                              'FINSI' ;
                       'FINSI ' ;
                       'SI' ( ( ICAS 'EGA' 2 ) et
             ((('ABS' VAL1 ) '<EG' DCRIT ) 'ET' ( VAL1 '>EG' 0.001)) );
                               IOK = IOK + 1 ;
                              'SI' ( IOK 'EGA' 1 ) ;
                                  MAI2 = MAI1 'POIN' IP2 ;
                              'SINON' ;
                                  MAI2 = MAI2 'ET' ( MAI1 'POIN' IP2 ) ;
                              'FINSI' ;
                       'FINSI' ;
                       'SI' ( (ICAS 'EGA' 3 ) et
                 ((('ABS' VAL1 ) '<EG' DCRIT ) 'ET' (VAL1 < -0.001)) );
                             IOK = IOK + 1 ;
                              'SI' ( IOK 'EGA' 1 ) ;
                                  MAI2 = MAI1 'POIN' IP2 ;
                              'SINON' ;
                                  MAI2 = MAI2 'ET' ( MAI1 'POIN' IP2 ) ;
                              'FINSI' ;
                       'FINSI' ;
                        IP2 = IP2 + 1 ;
                    'FIN' BOUCTRI ;
                     list iok ;
                     si (iok > 1) ;
                        NBP2 = 'NBNO' MAI2 ;
                     sinon ;
                        NBP2 = 1 ;
                     finsi ;
                     'MESS' '---> Distance critique      : ' DCRIT ;
                     'MESS' '---> Nbre de points retenus : ' NBP2 ;
                     'MESS' '---> iok : ' iok ;
                     'SI' ( NBP2 < 4 ) ;
                        'SI' ( IREC '<EG' 6 ) ;
                           'MESS' 'Pas assez de points selectionnes' ;
                           'MESS' 'essai nouvelle distance critique' ;
                           DCRIT = DCRIT * 1.25 ;
                        'SINON' ;
                           'MESS' 'Mauvaise selection des points : ' ;
                           'MESS' 'contour introuvable !' ;
                           IERR = 1 ; 'QUITTER' BOUCREC ;
                        'FINSI' ;
                     'SINON' ;
                        'QUITTER' BOUCREC ;
                     'FINSI' ;
                  'FIN' BOUCREC ;
                  si (ega iok 1) ;
                     iterer boutron ;
                     mess ' *** Il y a un point selectionne ! ' ;
                  finsi ;
*
*                 Construction de LIGi
*
                  POIPROJ = MAI2 'PROJ' VP 'PLAN' PP PP2 PP3 ;
*
*                 recherche de WMIN, XWMIN et d'un point oppose
*
                  II1 = 1 ;
                  NBP1 = 'NBNO' POIPROJ ;
                  'REPETER' BOUCP1 NBP1 ;
                     PE1 = POIPROJ 'POIN' II1 ;
                     PEX1 PEY1 PEZ1 = 'COORD' PE1 ;
                     VV1 = PEX1 - PP11 ;
                     VV2 = PEY1 - PP12 ;
                     VV3 = PEZ1 - PP13 ;
                     PEW1 = (VV1 * WN1) + (VV2 * WN2) + (VV3 * WN3) ;
                     PEX1 = (VV1 * XN1) + (VV2 * XN2) + (VV3 * XN3) ;
                     'SI' ( II1 'EGA' 1 ) ;
                        LW = 'PROG' PEW1 ; LX = 'PROG' PEX1 ;
                        WMIN = PEW1 ; XWMIN = PEX1 ;
                        IIMIN = 1 ;
                     'SINON' ;
                        LW = LW 'ET' ( 'PROG' PEW1 ) ;
                        LX = LX 'ET' ( 'PROG' PEX1 ) ;
                        'SI' ( PEW1 < WMIN ) ;
                           WMIN = PEW1 ; XWMIN = PEX1 ;
                           IIMIN = II1 ;
                        'FINSI' ;
                     'FINSI' ;
                     II1 = II1 + 1 ;
                  'FIN' BOUCP1 ;
*
                  II2 = 1 ; DIAG0 = 0. ;
                  'REPETER' BOUCP2 NBP1 ;
                     LW1 = 'EXTRAIRE' LW II2 ;
                     LX1 = 'EXTRAIRE' LX II2 ;
                     DIAG1 = ( ((LW1 -  WMIN) ** 2) +
                               ((LX1 - XWMIN) ** 2) ) ** 0.5 ;
                     'SI' ( DIAG1 > DIAG0 ) ;
                        DIAG0 = DIAG1 ;
                        IIMAX = II2 ;
                     'FINSI' ;
                     II2 = II2 + 1 ;
                  'FIN' BOUCP2 ;
                  PC1 = POIPROJ 'POIN' IIMIN ;
                  PCX1 PCY1 PCZ1 = 'COORD' PC1 ;
                  PC2 = POIPROJ 'POIN' IIMAX ;
                  PCX2 PCY2 PCZ2 = 'COORD' PC2 ;
*
*                 PQ = PC2 - PC1
*
                  PQX1 = PCX2 - PCX1;
                  PQY1 = PCY2 - PCY1;
                  PQZ1 = PCZ2 - PCZ1;
                  PQ = PQX1 PQY1 PQZ1 ;
*
*                 PN = PQ ^ VN
*
                  PNX1 = (PQY1 * VN3) - (PQZ1 * VN2) ;
                  PNY1 = (PQZ1 * VN1) - (PQX1 * VN3) ;
                  PNZ1 = (PQX1 * VN2) - (PQY1 * VN1) ;
                  PN = PNX1 PNY1 PNZ1 ;
*
*                 Recherche des deux autres points -> PC3 et PC4
*
                  II3 = 1 ;
                  PSCAMAX = 0. ; PSCAMIN = 0. ;
                  'REPETER' BOUCP3 NBP1 ;
                     PE1 = POIPROJ 'POIN' II3 ;
                     PEX1 PEY1 PEZ1 = 'COORD' PE1 ;
                     VV1 = PEX1 - PCX1 ;
                     VV2 = PEY1 - PCY1 ;
                     VV3 = PEZ1 - PCZ1 ;
                     PSC1 = (VV1 * PNX1) + (VV2 * PNY1) +
                        (VV3 * PNZ1) ;
                     'SI' ( PSC1 > PSCAMAX ) ;
                        PSCAMAX = PSC1 ; IIMAX = II3 ;
                     'FINSI' ;
                     'SI' ( PSC1 < PSCAMIN ) ;
                        PSCAMIN = PSC1 ; IIMIN = II3 ;
                     'FINSI' ;
                     II3 = II3 + 1 ;
                  'FIN' BOUCP3 ;
                  PC3 = POIPROJ 'POIN' IIMAX ;
                  PC4 = POIPROJ 'POIN' IIMIN ;
                  L1 = 'DROITE' 1 PC1 PC3 ; L2 = 'DROITE' 1 PC3 PC2 ;
                  L3 = 'DROITE' 1 PC2 PC4 ; L4 = 'DROITE' 1 PC4 PC1 ;
                  LIG1 = L1 'ET' L2 'ET' L3 'ET' L4 ;
                  LIG1 = LIG1 'COUL' vert ;
                  mess ' ***** iinter =' iinter ;
                  'SI' (IINTER 'EGA' 1) ;
                       LB = LIG1 ;
                  'SINON' ;
                       LB = LB 'ET' LIG1 ;
                  'FINSI' ;
               'SINON' ;
                  'DETR' MAI1 ; 'DETR' LISPDT ;
               'FINSI' ;
*               IMAI = IMAI + 1 ;
            'FIN' boutron ;
            'SI' ( IINTEI '>EG' 1 ) ;
       'MESS' 'Dans le plan' igeo1 ',' iintei 'contours ont ete crees' ;
             sinon ;
           mess ' **** il n y a pas d intersection dans le plan' igeo1 ;
            'FINSI' ;
      'FIN' BOUCI ;
*
*     Archivage de l'intersection dans TAB2.LIG.j
*
      'SI' (( IINTER '>EG' 1 ) 'OU' ( IRECUP 'EGA' 1 )) ;
         tabcon.1 = LB ;
      'FINSI' ;
       sauter 1 ligne ;
       mess ' ************ fin du calcul des intersections *******' ;
   finsi ;
   sinon ;
      iterer bogeo1 ;
   finsi ;
   si (ega itest.igeo1 -2) ;
       mess ' **** le plan de calcul choisi n est pas horizontal!!' ;
   finsi ;
*-------------------------------------------------------------------------
*
*  construction des contours des autres bobines par rotation autour de Oz
*
*-------------------------------------------------------------------------
   si ((itest.igeo1) > -1) ;
      si (existe tabcon 1) ;
         si (nbob > 1) ;
            ibob = 1 ;
            contot = tabcon.ibob ;
            repeter bbob2 (nbob-1) ;
               ibob = ibob + 1 ;
               angln = (ibob-1)*360./nbob ;
               tabcon.ibob = tabcon.1 tour angln o1 o2 ;
               contot = contot et tabcon.ibob ;
            fin bbob2 ;
         finsi ;
      finsi ;
      (tab2.cont).igeo1 = tabcon ;
   sinon ;
      (tab2.cont).igeo1 = 0 ;
   finsi ;
fin bogeo1 ;
finsi ;
sauter 1 ligne ;
mess ' *** Fin normale de la procedure @TORO ***' ;
sauter 1 ligne ;
finproc tabchb tab2 ;


