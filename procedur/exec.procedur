$$$$ EXEC
* EXEC      PROCEDUR  MAGN      18/06/11    21:15:02     9850
************************************************************************
* EXECUTE UN ALGORITHME DÉCRIT DANS UNE TABL RV DE TYPE EQEX
* CETTE TABL EST CRÉÉE PAR L'OPÉRATEUR EQEX
************************************************************************
* HISTORIQUE
* 20/12/99 = Rajout de la gestion de la matrice servant à l'assemblage
*            (rv.'METHINV'.'MATASS')
* 12/05/06 = ajout STOPITER, NUITER et STOPPDT
* 21/12/07 = ajout projection algébrique incrémentale (cf. GRESP)
* 06/05/14 = ajout test DFDT : qd niter>1, on vérifie que le 2eme
*            argument est distinct de linconnue
* 05/06/14 = on teste qd niter>1 et itma>1, car certains cas utilisent
*            DFDT pour pénaliser (dvisi et ccar3)
* 05/02/16 = ajout de l'historique RV.'INCO'.'HIST'
* 16/05/18 = corrections mineures + lifting
************************************************************************
DEBP EXEC RV*'TABLE' NPARTI/'ENTIER' LOPP/'LISTMOTS' ;
*
*
*
*
*  +-------------------------------------------------------------------+
*  |                                                                   |
*  |  I N I T I A L I S A T I O N S   E T   V É R I F I C A T I O N S  |
*  |                                                                   |
*  +-------------------------------------------------------------------+
*
*
************************************************************************
*
*  Ajout test DFDT : qd niter>1, on vérifie que le 2eme argument est
*                    distinct de linconnue (anomalie #8050)
   SI (((RV.'NITER') > 1) ET ((RV.'ITMA') > 1)) ;
      NOP = DIME (RV.'LISTOPER') ;
      REPE IOP NOP ;
         NOMPER = EXTR (RV.'LISTOPER') &IOP ;
         SI (EGA NOMPER 'DFDT') ;
            NOMTAB = CHAI &IOP NOMPER ;
            RVN = RV.NOMTAB ;
            TYPARG2 = TYPE RVN.'ARG2' ;
            SI (EGA TYPARG2 MOT) ;
               NOMUN = EXTR (RVN.'LISTINCO') 1 ;
               SI (EGA NOMUN RVN.'ARG2') ;
                  ERRE 1038 ;
               FINS ;
            FINS ;
         FINS ;
      FIN IOP ;
   FINS ;
*
************************************************************************
*
*  Utilisation de RESOU plutot que KRES ?
   TRESOU = FAUX ;
   SI (EXIS RV 'TRESOU') ;
      TRESOU = RV.'TRESOU' ;
   FINS ;
*
************************************************************************
*
*  Parallélisation des résolutions lorsqu'elles sont découplées
   TKPR = FAUX ;
   SI (EXIS RV 'TKPR') ;
      TKPR = RV.'TKPR' ;
   FINS ;
*
************************************************************************
*
*  Impressions liées au parallélisme
   IMPARA = FAUX ;
   SI (EXIS RV 'IMPARA') ;
      IMPARA = RV.'IMPARA' ;
   FINS ;
*
************************************************************************
*
*  Niveau d'impression global
   IIMPR = RV.'IMPR' ;
*
************************************************************************
*
*  Liste des opérateurs potentiellement parallélisables
*    LOPERPAR = MOTS 'NS' 'TSCA' 'DFDT' 'KONV' 'LAPN' 'FROT' 'FIMP' 'TOIMP' ;
*    LOPERPAR =  MOTS 'NS' 'TSCA' 'DFDT' 'LAPN' 'KONV' ;
   LOPERPAR = MOTS 'NS' 'TSCA' 'DFDT' ;
*    LOPERPAR = MOTS 'NSQT' ;
*
*  Parallélisation du calcul des matrices élémentaires si :
*     1) RV.'TCPT' = VRAI
*     2) NPART > 1
*     3) On a bien des objets MMODEL et non pas des tables 'DOMAINE'
*
   TCPT = FAUX ;
   SI (EXIS RV 'TCPT') ;
      TCPT = RV.'TCPT' ;
   FINS ;
*
*  Préparation pour paralléliser le calcul des matrices élémentaires
   SI TCPT ;
*
*     On partitionne en fonction du nombre d'assstants (= processeurs)
*     par défaut ou bien N (si précisé dans l'instruction EXEC RV N)
      SI (EXIS NPARTI) ;
         NPART = NPARTI ;
      SINON ;
         NPART = VALE 'ASSI' ;
      FINS ;
*
      SI (NON (EXIS RV 'TABPARTM')) ;
         TABPARTM = TABL ;
         RV.'TABPARTM' = TABPARTM ;
*
         REPE IOP (DIME (RV.'LISTOPER')) ;
            NOMPER = EXTR &IOP (RV.'LISTOPER') ;
            NOMTAB = CHAI &IOP NOMPER ;
            RVN = RV.NOMTAB ;
            $MD = RVN.'DOMZ' ;
            TYM = TYPE $MD ;
*
            SI (NON (EGA TYM 'MMODEL')) ;
               TCPT = FAUX ;
               QUIT IOP ;
            FINS ;
*
            SI (EXIS LOPERPAR NOMPER) ;
               SI IMPARA ;
                  MESS 'On parallélise ' NOMPER ' NPART =' NPART ;
               FINS ;
               SI (NON (EXIS TABPARTM $MD)) ;
                  $MDP = PART 'ARLE' NPART $MD ;
*
                  $BID = TABL 'ESCLAVE' ;
                  REPE BIBI NPART ;
*                      $BID.&BIBI = TABL 'KIZX' ;
                     $BID.&BIBI = COPI RVN ;
                     $BID.&BIBI.'DOMZ'= $MDP.&BIBI ;
                     $TDZ = DOMA ($BID.&BIBI.'DOMZ') 'TABL' ;
                     $BID.&BIBI.'TDOMZ'= $TDZ ;
                  FIN BIBI ;
*
                  TABPARTM.'$bid' = $BID ;
*                   TABPARTM.'$mdp' = $MDP ;
                  RVN.'$mdp' = $MDP ;
                  RVN.'$bid' = $BID ;
               FINS ;
            SINON ;
               SI IMPARA ;
                  MESS 'On ne parallélise pas ' NOMPER ;
               FINS ;
            FINS ;
*
         FIN IOP ;
*
      SINON ;
         TABPARTM = RV.'TABPARTM' ;
      FINS ;
*
      SI (EGA (DIME TABPARTM) 0) ;
         TCPT=FAUX ;
         SI IMPARA ;
            MESS 'Il n y a pas d opérateurs à paralléliser !' ;
         FINS ;
      FINS ;
*
      SI (NPART <EG 1) ;
         SI IMPARA ;
            MESS 'NPART <EG 1 : On ne partitionne pas ' ;
         FINS ;
         TCPT = FAUX ;
      FINS ;
*
   FINS ;
*
************************************************************************
*
*  Initialisation des critères d'arrêt (type LOGIQUE) positionnables
*  par l'utilisateur pendant la simulation
*
*  (boucle interne)
   SI (NON (EXIS RV 'STOPITER')) ;
      RV.'STOPITER' = FAUX ;
   FINS ;
*
*  (boucle externe)
   SI (NON (EXIS RV 'STOPPDT')) ;
      RV.'STOPPDT' = FAUX ;
   FINS ;
*
************************************************************************
*
*  LOGIQUE forçant le recalcul de la matrice de pression a chaque pas
*  de temps (boucle externe)
   CALPRE = FAUX ;
   SI (EXIS RV 'CALPRE') ;
      VERTYTAB RV 'CALPRE' 'LOGIQUE' ;
      CALPRE = RV.'CALPRE' ;
   FINS ;
*
************************************************************************
*
*  Option 'XEQUA' (non documentée...)
   SI (NON (EXIS RV 'XEQUA')) ;
      RV.'XEQUA' = FAUX ;
   FINS ;
*
************************************************************************
************************************************************************
************************************************************************
************************************************************************
*
*  Bifurcation gérée en interne (l'indice 'NAVISTOK' n'a pas vocation
*  a être ajouté par l'utilisateur)
   SI (EGA  (RV.'NAVISTOK') 0) ;
      EXAC RV ;
      QUIT EXEC ;
   FINS ;
*
************************************************************************
************************************************************************
************************************************************************
************************************************************************
*
*  Schéma temporel pour Navier-Stokes
   TESTPR  = EXIS RV 'PRESSION' ;
   TESTPRJ = EXIS RV 'PROJ' ;
*
   SI TESTPR ;
      RVP = RV.'PRESSION' ;
      ACHP MATPR= KOPS 'MATRIK' ;
      RVP.'MATP' = MATPR ;
   FINS ;
*
   SI TESTPRJ ;
      RVP = RV.'PROJ' ;
   FINS ;
*
   SI (IIMPR > 0) ;
      SI TESTPR ;
         MESS 'Algorithme semi explicite (ANCIEN)' ;
         MESS '==================================' ;
      FINS ;
      SI TESTPRJ ;
         MESS 'Algorithme de Projection' ;
         MESS '========================' ;
      FINS ;
      SI (NON (TESTPR OU TESTPRJ)) ;
         MESS 'Algorithme standard implicite ou explicite ' ;
         MESS '===========================================' ;
      FINS ;
   FINS ;
*
************************************************************************
*
*                                                (ancien algo)
*  Choix du type de schéma de projection :             |
*                                               PSCT  VPI1  VPI2   PENA
*    -----------------------------------------+-----+-----+-----++------
*    TGRAD = Formulation en gradient          | NON | NON | NON || NON
*    TMDM1 = Correction Gresho                | NON | OUI | NON || NON
*    TPNM2 = Elimination end of step velocity | NON | NON | OUI || NON
*                                                            |
*                                                      (nouvel algo)
   TYPROJ = 'VPI1' ;
   ROW = 1. ;
   SI (EXIS RV 'TYPROJ') ;
      TYPROJ=RV.'TYPROJ' ;
      SI (NON (EXIS (MOTS 'PSCT' 'VPI1' 'VPI2' 'PENA') TYPROJ)) ;
         MESS '*****************************************************' ;
         MESS ' ERREUR   ERREUR   ERREUR   ERREUR   ERREUR   ERREUR ' ;
         MESS '                                                     ' ;
         MESS ' Le mot ' TYPROJ ' n existe pas dans la liste.       ' ;
         MESS ' Les méthodes de projection autorisées sont :        ' ;
         MESS ' VPI1, VPI2, PSCT et PENA                            ' ;
         MESS '*****************************************************' ;
         ERRE 21 ;
         QUIT EXEC ;
      FINS ;
   FINS ;
*
   SI (EGA TYPROJ 'PSCT') ;
      TGRAD = FAUX ;
      TMDM1 = FAUX ;
      TPNM2 = FAUX ;
   FINS ;
*
   SI (EGA TYPROJ 'VPI1') ;
      TGRAD = FAUX ;
      TMDM1 = VRAI ;
      TPNM2 = FAUX ;
   FINS ;
*
   SI (EGA TYPROJ 'VPI2') ;
      TGRAD = FAUX ;
      TMDM1 = FAUX ;
      TPNM2 = VRAI ;
   FINS ;
*
   SI (EGA TYPROJ 'PENA') ;
      TGRAD = FAUX ;
      TMDM1 = FAUX ;
      TPNM2 = FAUX ;
   FINS ;
*
************************************************************************
*
*  Affectations différentes selon que l'on est en 2D ou en 3D
   IDIM1 = VALE 'DIME' ;
   NOMVI = RV.'NOMVI' ;
   SI (EGA IDIM1 2) ;
      VNUL = 0.D0 0.D0 ;
      VUNI = 1.D0 1.D0 ;
      CNVI1 = CHAI '1' NOMVI ;
      CNVI2 = CHAI '2' NOMVI ;
      LC  = MOTS CNVI1 CNVI2 ;
      LCU = MOTS 'UX' 'UY' ;
   SINON ;
      VNUL = 0.D0 0.D0 0.D0 ;
      VUNI = 1.D0 1.D0 1.D0 ;
      CNVI1 = CHAI '1' NOMVI ;
      CNVI2 = CHAI '2' NOMVI ;
      CNVI3 = CHAI '3' NOMVI ;
      LC  = MOTS CNVI1 CNVI2 CNVI3 ;
      LCU = MOTS 'UX' 'UY' 'UZ' ;
   FINS ;
*
************************************************************************
*
*  Facteur de relaxation
   SI (NON (EXIS RV 'OMEGA')) ;
      OMEG = 1.D0 ;
   SINON ;
      OMEG = RV.'OMEGA' ;
   FINS ;
*
************************************************************************
*
*  Traitement d'un cas particulier = verrue (non documenté...)
   TESTRAN = TESTPR ET (EXIS RV 'CO') ;
*
************************************************************************
*
*  Initialisation de la table d'historique
   SI (NON (EXIS RV 'HIST')) ;
      RV.'HIST' = TABL ;
   FINS ;
*
************************************************************************
*
*  Nombre d'itérations externes (pas de temps)
   ITMAX = RV.'ITMA' ;
   SI (ITMAX < 1) ;
      ITMAX = 1 ;
   FINS ;
*
************************************************************************
*
*  Fréquence d'impression du solveur KRES
   IMPKRES = 0 ;
*
************************************************************************
*
*  Fréquence d'impression des pas de temps (opérateur TCRR)
   IMPTCRR = 0 ;
   SI (IIMPR >EG 0) ;
      SI (ITMAX EGA 1) ;
         IMPTCRR = 1 ;
      FINS ;
      SI TESTPRJ ;
         IMPTCRR = 1 ;
      FINS ;
      SI (NON (TESTPR OU TESTPRJ)) ;
         IMPTCRR = 1 ;
      FINS ;
   FINS ;
*
************************************************************************
*
*  FCPRECT  : fréquence de recalcul des préc. dans la boucle externe
*  FCPRECI  : fréquence de recalcul des préc. dans la boucle interne
*  FCPRECTP : idem pour la matrice de pression
*  FCPRECIP : idem pour la matrice de pression
   FCPRECT = RV. 'METHINV'.'FCPRECT' ;
   FCPRECI = RV. 'METHINV'.'FCPRECI' ;
   SI TESTPRJ ;
      FCPRECTP = RVP.'METHINV'.'FCPRECT' ;
      FCPRECIP = RVP.'METHINV'.'FCPRECI' ;
   FINS ;
*
*  Force le calcul des préconditionneurs pour la première itération
   SI (NON (EXIS (RV.'METHINV') 'CALPREC')) ;
      RV.'METHINV'.'CALPREC' = VRAI ;
   FINS ;
   SI TESTPRJ ;
      SI (NON (EXIS (RVP.'METHINV') 'CALPREC')) ;
         RVP.'METHINV'.'CALPREC' = VRAI ;
      FINS ;
   FINS ;
*
************************************************************************
*
*  RESMN  : résidu au pas de temps ou à l'itération interne précédente
*  RESMNP : idem pour la pression
   SI (NON (EXIS RV 'resmn')) ;
      RESMN MAPREC = KOPS 'MATRIK' ;
      RV.'resmn' = RESMN ;
   FINS ;
   SI (NON (EXIS RV 'resmnp')) ;
      RESMNP MAPRECP = KOPS 'MATRIK' ;
      RV.'resmnp' = RESMNP ;
   FINS ;
*
*
*
*
*  +-------------------------------------------------------------------+
*  |                                                                   |
*  |          A L G O R I T H M E   D E   R É S O L U T I O N          |
*  |                                                                   |
*  +-------------------------------------------------------------------+
*
*  *******************************************
*  *******************************************
*  DEBUT DE LA BOUCLE EXTERNE (= PAS DE TEMPS)
*  *******************************************
*  *******************************************
   REPE BLOC1 ITMAX ;
*
*     Doit-on recalculer les préconditionneurs ?
      SI (MULT &BLOC1 FCPRECT) ;
         RV.'METHINV'.'CALPREC' = VRAI ;
      FINS ;
      SI TESTPRJ ;
         SI (MULT &BLOC1 FCPRECTP) ;
            RVP.'METHINV'.'CALPREC' = VRAI ;
         FINS ;
      FINS ;
*
*     Doit-on recalculer la matrice de pression ?
      TESTP1 = FAUX ;
      SI (TESTPR OU TESTPRJ) ;
         SI CALPRE ;
            TESTP1 = VRAI ;
         FINS ;
         SI (NON (EXIS RVP 'MATC')) ;
            TESTP1 = VRAI ;
         FINS ;
      FINS ;
*
*
*     ********************************************
*     ********************************************
*     DEBUT DE LA BOUCLE INTERNE (= NON-LINEARITE)
*     ********************************************
*     ********************************************
      REPE BLOCI (RV.'NITER') ;
*
*        Numéro de l'itération interne courante
         RV.'NUITER' = &BLOCI ;
*
*        Doit-on recalculer les préconditionneurs ?
         SI (MULT &BLOCI FCPRECI) ;
            RV.'METHINV'.'CALPREC' = VRAI ;
         FINS ;
         SI TESTPRJ ;
            SI (MULT &BLOCI FCPRECIP) ;
               RVP.'METHINV'.'CALPREC' = VRAI ;
            FINS ;
         FINS ;
*
*
*        ==========================================================
*        EXÉCUTION DE TOUS LES OPÉRATEURS/PROCÉDURES DE LA TABLE RV
*        => CONSTRUCTION DU SYSTÈME D'ÉQUATIONS DE Q.D.M.
*        ==========================================================
*
         ST MAT = KOPS 'MATRIK' ;
         SF MAU = KOPS 'MATRIK' ;
         MDFDT = 0 ;
         REPE BLOC2 (DIME (RV.'LISTOPER')) ;
            NOMPER = EXTR &BLOC2 (RV.'LISTOPER') ;
            NOMTAB = CHAI &BLOC2 NOMPER ;
            RVN = RV.NOMTAB ;
*
*           KFORM vaut 0 (EFM1) ou 1 (EF) ou 2 (VF) ou 3 (EFMC)
            MDFDT = MDFDT + RVN.'KOPT'.'KFORM' ;
*
*           Exécution séquentielle
            SI (NON TCPT) ;
               MSI MAI = (TEXTE NOMPER) RVN ;
*
*           Exécution parallèle (mémoire partagée)
            SINON ;
               SI (EXIS LOPERPAR NOMPER) ;
                  SI IMPARA ;
                     MESS ' On parallélise ' NOMPER ' NPART =' NPART ;
                  FINS ;
                  $MDP = RVN.'$mdp' ;
                  $BID = RVN.'$bid' ;
                  MSI MAI = ASSI 'TOUS' (TEXTE NOMPER) RVN $BID ;
                  MSI = ETG MSI ;
                  MAI = ETG MAI ;
               SINON ;
                  SI IMPARA ;
                     MESS NOMPER ' n est pas parallélisable' ;
                  FINS ;
                  MSI MAI = (TEXTE NOMPER) RVN ;
               FINS ;
            FINS ;
*
            SI (EGA NOMPER 'DFDT') ;
*              ISCHT vaut 1 (BDF2) ou 2 (BDF4) ou 0 sinon (ordre 1)
               ISCHT = RVN.KOPT.'ISCHT' ;
               MAT = MAT ET MAI ;
               ST  = ST  ET MSI ;
            SINON ;
               MAU = MAU ET MAI ;
               SF  = SF  ET MSI ;
            FINS ;
         FIN BLOC2 ;
*
*        ST/MAT contient le second membre et la matrice pour DFDT
*        SF/MAU contient le second membre et la matrice pour les autres opérateurs
*        S2/MA1 contient le second membre et la matrice pour l'ensemble
         S2  = SF  ET ST  ;
         MA1 = MAU ET MAT ;
*
*
*        ====================================================
*        TRAITEMENTS SPÉCIFIQUES POUR LA PRESSION (SI REQUIS)
*        ====================================================
*
         SI (EXIS RV 'rvpd') ;
            RVPD  = RV.'rvpd'  ;
            IDIGV = RV.'IDigv' ;
            DIGV  = RV.'Digv'  ;
            MATPR = RVP.'MATP' ;
         FINS ;
*
*
*        1) Calcul de C*D^(-1)*Ct pour l'algorithme semi-explicite (RV.'PRESSION')
*           **********************************************************************
*
         SI (TESTPR ET TESTP1) ;
            RVPD = RVP.'DOMAINE' ;
            DIAGO = DOMA RVPD 'XXDIAGSI' ;
            SI (IDIM1 EGA 2) ;
               DIGV = (NOMC DIAGO CNVI1) ET (NOMC DIAGO CNVI2) ;
            SINON ;
               DIGV = (NOMC DIAGO CNVI1) ET (NOMC DIAGO CNVI2) ET (NOMC DIAGO CNVI3) ;
            FINS ;
            DIGV = KCHT RVPD 'VECT' 'SOMMET' 'COMP' LC DIGV ;
*
*           Les noeuds de DIGV sur lesquels existe une CLIM en vitesse sont mis a 1.E30
            SI (EXIS RV 'CLIM') ;
               RVP.'CLIM' = RV.'CLIM' ;
               DIGV = KOPS DIGV 'CLIM' (RV.'CLIM') -1 ;
            FINS ;
*
            IDIGV = INVE DIGV ;
*
            SI (NON (EXIS RVP 'DIAGV')) ;
               RVP.'DIAGV' = DIGV ;
            FINS ;
*
*           KMAB => discrétisation de l'opérateur div(U)
            RVP.'MATC' = KMAB RVP ;
            RVP.'PRESSION' = KCHT RVPD 'SCAL' 'CENTRE' 0.D0 ;
            RVP.'GRADP'    = KCHT RVPD 'VECT' 'SOMMET' VNUL ;
            ACHP MATPR = KOPS 'MATRIK' ;
            RVP.'MATP' = MATPR ;
            RV.'rvpd'  = RVPD  ;
            RV.'IDigv' = IDIGV ;
            RV.'Digv'  = DIGV  ;
*
         FINS ;
*
*
*        2) Calcul de C*D^(-1)*Ct pour l'algorithme de projection (RV.'PROJ')
*           *****************************************************************
*
         SI (TESTPRJ ET TESTP1) ;
*
*           -------------------------------------------------------------------
*           Construction de la matrice masse diagonale à partir des tables DFDT
*           -------------------------------------------------------------------
*
            DIAGO MMA = KOPS 'MATRIK' ;
            IDFDT = 0 ;
            REPE BLOCJ (DIME (RV.'LISTOPER')) ;
               NOMPER = EXTR &BLOCJ (RV.'LISTOPER') ;
               NOMTAB = CHAI &BLOCJ NOMPER ;
               SI ((EGA NOMPER 'DFDT') ET (EXIS (RV.NOMTAB) 'LISTINCO')) ;
                  SI (EXIS (RV.NOMTAB.'LISTINCO') NOMVI) ;
                     IDFDT = IDFDT + 1 ;
                     RVPD = RV.NOMTAB.'DOMZ' ;
                     DIAGO = DIAGO ET (DOMA RVPD 'XXDIAGSI') ;
                  FINS ;
               FINS ;
            FIN BLOCJ ;
*
            SI (EGA IDFDT 0) ;
               MESS 'Pas de DFDT ????' ;
               ERRE 21 ;
            FINS ;
*
            SI (IDIM1 EGA 2) ;
               DIGV = (NOMC DIAGO CNVI1) ET (NOMC DIAGO CNVI2) ;
            SINON ;
               DIGV = (NOMC DIAGO CNVI1) ET (NOMC DIAGO CNVI2) ET (NOMC DIAGO CNVI3) ;
            FINS ;
*
            DIGV = KCHT RVPD 'VECT' 'SOMMET' 'COMP' LC DIGV ;

*           DIG1 = matrice diagonale indépendante des conditions aux limites
            DIG1  = COPI DIGV ;
            IDIAG = INVE DIG1 ;
*
*           Les noeuds de DIGV sur lesquels existe une CLIM en vitesse sont mis a 1.E30
            DIGV = KOPS DIGV 'CLIM' (RV.'CLIM') -1 ;
*
            IDIGV = INVE DIGV ;
*
            SI (NON (EXIS RVP 'DIAGV')) ;
               RVP.'DIAGV' = DIGV ;
            FINS ;
            RVP.'INCO' = RV.'INCO' ;
*
*
*           -----------------------------------------------------------
*           Exécution de tous les opérateurs/procédures de la table RVP
*           -----------------------------------------------------------
*
*           TVNPC et TVNP indiquent que l'opérateur VNIMP est présent
*           (respectivement avec MSOMMET ou CENTREP0/CENTREP1)
            TVNP  = FAUX ;
            TVNPC = FAUX ;
*
*           SVNPC/MVNPC contient le second membre et la matrice pour VNIMP+MSOMMET
*           SR/MAR contient le second membre et la matrice pour les VNIMP+CENTREPx
*           SP/MAP contient le second membre et la matrice pour les autres opérateurs
            SVNPC MVNPC = KOPS 'MATRIK' ;
            SR MAR      = KOPS 'MATRIK' ;
            SP MAP      = KOPS 'MATRIK' ;
*
            REPE BLOCPJ (DIME (RVP.'LISTOPER')) ;
               NOMPER = EXTR &BLOCPJ (RVP.'LISTOPER') ;
               NOMTAB = CHAI &BLOCPJ NOMPER ;
*
               SI (EGA NOMPER 'KBBT') ;
*                 IKOMP vaut 0 (NOCONS) ou 1 (CONS) ou 2 (CONS2)
                  RVP.NOMTAB.'KOPT'.'IKOMP' = 1 ;
               FINS ;
               MSI MAI = (TEXTE NOMPER) (RVP.NOMTAB) ;
*
*######################## ATTENTION !!!!!!!!
*######################## MSIG/MAIG SONT UTILISES HORS DE BLOCPJ
*######################## LEUR VALEUR EST INCERTAINE......
               SI TGRAD ;
                  SI (IIMPR > 0) ;
                     MESS 'Procedure PROJCT (Gradient) Operateur : ' NOMPER ;
                  FINS ;
*                 IKOMP vaut 0 (NOCONS) ou 1 (CONS) ou 2 (CONS2)
                  RVP.NOMTAB.'KOPT'.'IKOMP' = 0 ;
                  MSIG MAIG = (TEXTE NOMPER) (RVP.NOMTAB) ;
               FINS ;
*########################
*########################
*########################
*
               SI (EGA NOMPER 'VNIMP') ;
*                 DISCPRES vaut 3 (CENTREP0) ou 4 (CENTREP1) ou 5 (MSOMMET)
                  SI (EGA (RVP.'DISCPRES') 5) ;
                     TVNPC = VRAI ;
                     MVNPC = MVNPC ET MAI ;
                     SVNPC = SVNPC ET MSI ;
                  SINON ;
                     TVNP = VRAI ;
                     MAR  = MAR ET MAI ;
                     SR   = SR  ET MSI ;
                  FINS ;
               SINON ;
                  MAP = MAP ET MAI ;
                  SP  = SP  ET MSI ;
               FINS ;
            FIN BLOCPJ ;
*
*           Séparation des sous-matrices type C*Ct (MAC) des autres sous-matrices (MATPC)
            MATPC MAC = KOPS 'CMCTSPLT' MAP ;
*
*######################## ATTENTION !!!!!!!!
*######################## LA VALEUR DE MAIG EST INCERTAINE......
            SI TGRAD ;
               MATPCG MACG = KOPS 'CMCTSPLT' MAIG ;
               RVP.'MATG' = MACG ;
            FINS ;
*########################
*########################
*
            SI TVNPC ;
               MAC = MAC ET MVNPC ;
            FINS ;
            RVP.'MATC' = MAC ;
*
            SCR MCR = KOPS 'MATRIK' ;
            SI TVNP ;
               RVP.'MBTR' = MAR ;
               DUNIT = IDIGV ;
*              KOPS 'CMCT' A B C calcule la matrice A*C^(-1)*Bt
               CRT = KOPS 'CMCT' MAC MAR DUNIT ;
               CTR = KOPS 'CMCT' MAR MAC DUNIT ;
               RRT = KOPS 'CMCT' MAR MAR DUNIT ;
*                MCR = MCR ET CRT ET CTR ET RRT ;
               MCR = CRT ET CTR ET RRT ;
            FINS ;
            RVP.'TVNP' = TVNP ;
*
            SI (EGA (RVP.'DISCPRES') 5) ;
               SI (IIMPR > 0) ;
                  MESS 'Cas des pressions CONTINUES' ;
               FINS ;
*                MATPR = MATPC ET MCR ;
*              MCR est vide !
               MATPR = MATPC ;
            SINON ;
               SI (IIMPR > 0) ;
                  MESS 'Cas des pressions DISCONTINUES' ;
               FINS ;
               MATPR = KOPS 'CMCT' MAC MAC IDIGV ;
               MATPR = MATPC ET MATPR ET MCR ;
*
               SI TRESOU ;
                  MATPR = KOPS 'RIMA' MATPR 'NSYM' ;

                  INCU = EXTR MAC 'COMP' ;
                  INCP = EXTR MAC 'COMP' 'DUAL' ;
                  INCUP = INCU ET INCP ;
                  OPTI 'INCO' INCUP INCUP ;
*
*                 RIGIDITE/CHPOINT associés aux C.L. en pression
           Si('EXIS' rvp 'rigp')                                ;
            rigp=rvp.'rigp'                                     ;
            fpi =rvp.'climreso'                                 ;
           Sinon                                                ;
            incpres=extr incp 1                                 ;
            mip=extr rvp.clim 'MAILLAGE'                        ;
            rigp=BLOQ mip incpres                               ;
            fpi =DEPI RIGP rvp.'CLIM'                           ;
            rvp.'rigp'=rigp                                     ;
            rvp.'climreso'=fpi                                  ;
           Finsi                                                ;
            matpr = matpr et rigp                               ;


                  SI (IIMPR > 0) ;
                     MESS '***** ON UTILISE RESOU POUR LA PRESSION *****' ;
                  FINS ;
               SINON ;
                  SI (IIMPR > 0) ;
                     MESS '***** ON UTILISE KRES POUR LA PRESSION *****' ;
                  FINS ;
               FINS ;
            FINS ;
*
            RV.'rvpd'  = RVPD  ;
            RV.'IDigv' = IDIGV ;
            RV.'Digv'  = DIGV  ;
            RVP.'MATP' = MATPR ;
*
         FINS ;
*
*
*        3) Calcul de Ct*P pour l'algorithme semi-explicite (RV.'PRESSION')
*           ***************************************************************
*
         SI TESTPR ;
            DT = (RV.'PASDETPS'.'DELTAT') * (RV.'ALFA') ;
            RVP.'DELTAT' = DT ;
*
*             F = COPI S2 ;
*             LC = EXTR DIGV 'COMP' ;
            F = S2 ;
            FU = KCHT RVPD 'VECT' 'SOMMET' 'COMP' LC (EXCO F LC) ;
*
*           DM1F vaut (-1 * RV.'CLIM' / DT) aux noeuds supportant une C.L.
*           DM1F vaut (-1 * FU * IDIGV) partout ailleurs
            SI (EXIS RV 'CLIM') ;
               DM1F = KOPS (DT '*' (KOPS FU '*' IDIGV)) 'CLIM' (RV.'CLIM') 3 ;
               DTI  = -1.D0 / DT ;
               DM1F = DTI * DM1F ;
            SINON ;
               DM1F = (-1.D0) * (KOPS FU '*' IDIGV) ;
            FINS ;
*
*           Calcul de -C*D^(-1)*F
            RVP.'PRESSION' = KMF (RVP.'MATC') DM1F ;
*
*           /\/\/\/\/\/\/\/\/\/\/
*           Calcul de la pression (vieille syntaxe KRES)
*           /\/\/\/\/\/\/\/\/\/\/
            KRES RVP (RVP.'PRESSION') 'BETA' (RVP.'KBETA') (RVP.'BETA')
                                      'PIMP' (RVP.'KPIMP') (RVP.'PIMP') ;
            RV.'INCO'.'PRESSION' = RVP.'PRESSION' ;

*           Calcul de CtP, c'est-à-dire grad(p)
            RVP.'GRADP' = KMTP 1 (RVP.'MATC') (RVP.'PRESSION') LC ;
            S2 = S2 + (RVP.'GRADP') ;
         FINS ;
*
*
*        4) Calcul de M*D^(-1) puis Ct*P pour l'algorithme de projection (RV.'PROJ')
*           ************************************************************************
*
         SI TESTPRJ ;
            DT = (RV.'PASDETPS'.'DELTAT') * (RV.'ALFA') ;
            RVP.'DELTAT' = DT ;
*
*
*           ------------------------------------
*           Calcul du produit M*D^(-1) si requis
*           ------------------------------------
*
            SI TMDM1 ;
               SI ((EXIS RV 'MDM1') ET (NON CALPRE)) ;
                  MDM1 = RV.'MDM1' ;
               SINON ;
                  SI (IIMPR > 0) ;
                     MESS 'On calcule M*D^(-1)' ;
                  FINS ;
*
                  STN MATN = KOPS 'MATRIK' ;
                  ROW = 0. ;
                  REPE BLOCPJ1 (DIME (RVP.'LISTOPER')) ;
                     NOMPER1 = EXTR &BLOCPJ1 (RVP.'LISTOPER') ;
                     NOMTAB1 = CHAI &BLOCPJ1 NOMPER1 ;
                     SI (EGA NOMPER1 'KBBT') ;
                        NOMIV1 = EXTR (RVP.NOMTAB1.'LISTINCO') 1 ;
*
                        REPE BLOCPJ2 (DIME (RV.'LISTOPER')) ;
                           NOMPER2 = EXTR &BLOCPJ2 (RV.'LISTOPER') ;
                           NOMTAB2 = CHAI &BLOCPJ2 NOMPER2 ;
                           SI (EGA NOMPER2 'DFDT') ;
                              NOMIV2 = EXTR (RV.NOMTAB2.'LISTINCO') 1 ;
*
                              SI (EGA NOMIV2 NOMIV1) ;
                                 SI (EGA TYPROJ 'PENA') ;
                                    RWI = (RV.NOMTAB2).ARG1 ;
                                    TRWI = TYPE RWI ;
                                    SI (EGA TRWI 'MOT') ;
                                       RWI = RV.'INCO'.RWI ;
                                       TRWI = TYPE RWI ;
                                    FINS ;
                                    SI (IIMPR > 0) ;
                                       MESS 'Type du coefficient RWI = ' TRWI ;
                                    FINS ;
*
                                    SI (EGA TRWI 'FLOTTANT') ;
                                       ROW = MAXI (PROG RWI ROW) ;
                                    FINS ;
                                    SI ((EGA TRWI 'CHPOINT') OU (EGA TRWI 'MCHAML')) ;
                                       ROW = MAXI (PROG (MAXI RWI) ROW) ;
                                    FINS ;
                                 SINON ;
                                    ROW = 1. ;
                                 FINS ;
*                                  MESS 'ROW = ' ROW ;
*
                                 MSI MAI = DFDT (RV.NOMTAB2) ;
                                 MATN = MATN ET MAI ;
*                                  DOMZP = RV.NOMTAB2.'DOMZ' ;
*                                  STI = KCHT DOMZP 'VECT' 'SOMMET' 'COMP' LC VUNI ;
                              FINS ;
                           FINS ;
                        FIN BLOCPJ2 ;
                     FINS ;
                  FIN BLOCPJ1 ;
*
                  SI (EGA TYPROJ 'PENA') ;
                     MDM1 = 1. ;
                  SINON ;
                     MDM1 = KMF MATN IDIAG ;
                  FINS ;
*
                  SI (EGA ISCHT 1) ;
                     MDM1 = MDM1 * ((DT*2.)/3.) ;
                  SINON ;
                     MDM1 = MDM1 * DT ;
                  FINS ;
*
                  RV.'MDM1' = MDM1 ;
               FINS ;
            FINS ;
*
*
*           ---------------------------
*           Calcul du produit Ct*P[n-1]
*           ---------------------------
*
            TVNP = RVP.'TVNP' ;

            SI (EXIS (RV.'INCO') 'PRESSION') ;
               PPI = RV.'INCO'.'PRESSION' ;
*
*              TPNM2 Elimination of end of step velocity (2*P[n] - P[n-1])
               SI (EXIS (RV.'INCO') 'PNM2') ;
                  PPI = (2 * PPI) - (RV.'INCO'.'PNM2') ;
               FINS ;
*
*              TGRAD=VRAI => Formulation en u*grad(p)
*              TGRAD=FAUX => Formulation en p*div(u)
               SI TGRAD ;
                  CPRE = KMF (RVP.'MATG') PPI 'TRAN' ;
               SINON ;
                  CPRE = KMF (RVP.'MATC') PPI 'TRAN' ;
               FINS ;
*
*              Prise en compte des C.L. (opérateur VNIMP avec CENTREP0/CENTREP1)
               SI TVNP ;
                  CXRE = KMF (RVP.'MBTR') PPI 'TRAN' ;
                  CPRE = CPRE ET CXRE ;
               FINS ;

*              Consistence selon Gresho
               SI TMDM1 ;
                  GRADPRES = KOPS MDM1 '*' CPRE ;
*              Consistence selon Guermond
               SINON ;
                  GRADPRES = CPRE ;
               FINS ;
               OUBL CPRE ;
               RV.'INCO'.'GRADPRES' = NOMC GRADPRES LCU LC ;
*
               SI TGRAD ;
                  S2 = SF - (RV.'INCO'.'GRADPRES') + ST ;
               SINON ;
                  S2 = SF + (RV.'INCO'.'GRADPRES') + ST ;
               FINS ;
*
            FINS ;
         FINS ;
*
         SI (EXIS RV 'CLIM') ;
            S1 = RV.'CLIM' ;
         SINON ;
            S1 = ' ' ;
         FINS ;
         RV.'S2' = S2 ;
*
*
*        ===========================================
*        RÉSOLUTION DU SYSTÈME D'ÉQUATIONS DE Q.D.M.
*        ===========================================
*
         SI ((NON TESTPRJ) OU (EGA MDFDT 0)) ;
*
            RV.'METHINV'.'XINIT' = RV.'resmn' ;
*
*           Méthode de projection incrémentale
*           **********************************
            SI (EXIS RV 'GPROJ') ;
               SI (IIMPR > 0) ;
                  MESS 'Résolution QDM - méthode de projection incrémentale' ;
               FINS ;
               RES = GRESP MA1 S1 S2 RV ;
*
*           Système monolithique d'équations (U-P)
*           **************************************
            SINON ;
               SI (IIMPR > 0) ;
                  MESS 'Résolution QDM - système monolithique (U-P)' ;
               FINS ;
*
               SI ((RV.'METHINV'.'TYPINV' EGA 1) ET TRESOU) ;
                  SI (IIMPR > 0) ;
                     MESS 'ILU-Crout => on utilise RESOU' ;
                  FINS ;
*
                  MA1 = KOPS 'RIMA' MA1 'NSYM' ;
                  INCPRES = EXTR RV.'LISTINCO' 1 ;
                  OPTI 'INCO' INCPRES INCPRES ;
*
*                 RIGIDITE/CHPOINT associés aux C.L.
                  SI (EXIS RV 'trico1') ;
                     TRICO = RV.'trico1' ;
                  SINON ;
                     INC = EXTR (RV.'CLIM') 'COMP' ;
                     TRICO = TABL 'ESCLAVE' ;
                     RV.'trico1' = TRICO ;
                     NCMP = DIME INC ;
                     REPE BINC NCMP ;
                        ICO = EXTR &BINC INC ;
                        RCLIM = EXCO (RV.'CLIM') ICO ICO ;
                        MIP = EXTR RCLIM 'MAILLAGE' ;
                        TRICO.&BINC = BLOQ MIP ICO ;
                     FIN BINC ;
                  FINS ;
                  S1 = VIDE 'CHPOINT/DISCRET' ;
                  REPE BINC NCMP ;
                     ICO = EXTR &BINC INC ;
                     RCLIM = EXCO (RV.'CLIM') ICO ICO ;
                     RIGP = TRICO.&BINC ;
                     S1 = S1 ET (DEPI RIGP RCLIM) ;
                  FIN BINC ;
*
                  RIGP = ET TRICO ;
                  MA1  = MA1 ET RIGP ;
               FINS ;
*
               RES = KRESP MA1 'TYPI' (RV.'METHINV')
                               'CLIM' S1
                               'SMBR' S2
                               'IMPR' IMPKRES ;
            FINS ;
         FINS ;
*
*        Méthode de projection standard
*        ******************************
         SI (TESTPRJ ET (NEG MDFDT 0)) ;
            SI (IIMPR > 0) ;
               MESS 'Résolution QDM - méthode de projection standard' ;
            FINS ;
*
*             LPART  = EXTR MA1 'COMP' ;
            LPART  = KOPS 'EXTRCOUP' MA1 ;
            NBPART = DIME LPART ;
*             MESS 'Liste des composantes' ;
*             LIST LPART ;
*
            $MA1   = TABL 'ESCLAVE' ;
            $S1    = TABL 'ESCLAVE' ;
            $S2    = TABL 'ESCLAVE' ;
            $RESMN = TABL 'ESCLAVE' ;
            $TAB1  = TABL 'ESCLAVE' ;
*
            SI (EXIS RV '$trico') ;
               $TRICO = RV.'$trico' ;
            SINON ;
               $TRICO = TABL 'ESCLAVE' ;
               RV.'$trico' = $TRICO ;
               REPE BCLCOM NBPART ;
                  $TRICO.&BCLCOM = TABL 'ESCLAVE' ;
               FIN BCLCOM ;
            FINS ;
*
*           On boucle sur les partitions du domaine (déjà déterminées plus haut)
            REPE BCLCOM NBPART ;
*                NMC = EXTR LPART &BCLCOM ;
               NMC = LPART.&BCLCOM ;
*                MESS 'NMC=' NMC &BCLCOM ;

*                MA1I = EXTR MA1 (MOTS NMC) (MOTS NMC) ;
               MA1I = KOPS 'EXTRINCO' NMC NMC MA1 ;
               $MA1.&BCLCOM = MA1I ;
*                $S1.&BCLCOM = EXCO S1 NMC NMC ;
*                $S2.&BCLCOM = EXCO S2 NMC NMC ;
*                RESMNI = EXCO (RV.'resmn') NMC 'NOID' NMC ;
               $S1.&BCLCOM = EXCO S1 NMC 'NOID' ;
               $S2.&BCLCOM = EXCO S2 NMC 'NOID' ;
               RESMNI = EXCO (RV.'resmn') NMC 'NOID' ;
               TAB1 = COPI RV.'METHINV' ;
*                TAB1 = RV.'METHINV' ;
               TAB1.'XINIT' = RESMNI ;
               $TAB1.&BCLCOM = TAB1 ;
*
               SI (IIMPR > 0) ;
                  MESS 'Mise à jour du préconditionnement' ;
               FINS ;
               SI (TAB1.'TYPINV' >EG 2) ;
                  LWORD1 LWORD2 = KOPS 'EXTRNINC' MA1I ;
                  WORD1 = EXTR LWORD1 1 ;
*
                  SI (NON (EXIS RV 'TABRES')) ;
                     RV.'TABRES' = TABL ;
                  FINS ;
                  TABRES = RV.'TABRES' ;
*
                  SI (TAB1.'CALPREC') ;
                     SI (NON (EXIS TABRES WORD1)) ;
                        TABRES.WORD1 = TABL ;
                     FINS ;
                     TABRES.WORD1.'MATASS' = MA1I ;
                     TABRES.WORD1.'MAPREC' = MA1I ;
                  FINS ;
                  TAB1.'MATASS' = TABRES.WORD1.'MATASS' ;
                  TAB1.'MAPREC' = TABRES.WORD1.'MAPREC' ;
               FINS ;
            FIN BCLCOM ;
*
*           RÉSOLUTION PARALLÈLE
            SI TKPR ;
               SI IMPARA ;
                  MESS 'Les résolutions sont traitées en parallèle' ;
               FINS ;
*
               RES = ASSI 'TOUS' KRES $MA1 'TYPI' $TAB1
                                           'CLIM' $S1
                                           'SMBR' $S2
                                           'IMPR' IMPKRES ;
               RES = ETG RES ;
*
*           RÉSOLUTION SÉQUENTIELLE
            SINON ;
               SI IMPARA ;
                  MESS 'Les résolutions sont traitées séquentiellement' ;
               FINS ;
*
               RES MM1 = KOPS 'MATRIK' ;
               $TRICO = RV.'$trico' ;
               REPE BCLCOM NBPART ;
                  SI (($TAB1.&BCLCOM.'TYPINV' EGA 1) ET TRESOU) ;
                     MESS 'ILU-Crout => on utilise RESOU' ;
*
                     MATCOM = $MA1.&BCLCOM ;
                     MATCOM = KOPS 'RIMA' MATCOM 'NSYM' ;
*
*                    RIGIDITE/CHPOINT associés aux C.L.
                     SI (NON (EXIS ($TRICO.&BCLCOM) &BINC)) ;
                        INC = EXTR ($S1.&BCLCOM) 'COMP' ;
                        NCMP = DIME INC ;
                        REPE BINC NCMP ;
                           ICO = EXTR &BINC INC ;
                           OPTI 'INCO' ICO ICO ;
                           RCLIM = EXCO ICO ($S1.&BCLCOM) ICO ;
                           MIP = EXTR RCLIM 'MAILLAGE' ;
                           $TRICO.&BCLCOM.(&BINC) = BLOQ MIP ICO ;
                        FIN BINC ;
                     FINS ;
                     S1 = VIDE 'CHPOINT'/'DISCRET' ;
                     REPE BINC NCMP ;
                        ICO = EXTR &BINC INC ;
                        RCLIM = EXCO ICO ($S1.&BCLCOM) ICO ;
                        RIGP = $TRICO.(&BCLCOM).&BINC ;
                        S1 = S1 ET (DEPI RIGP RCLIM) ;
                     FIN BINC ;
*
                     RIGP = ETG ($TRICO.&BCLCOM) ;
                     MATCOM = MATCOM ET RIGP ;
*
                     RES1 = RESO MATCOM ($S2.&BCLCOM ET S1) ;
                     RES1 = RES1 'CHAN' 'ATTRIBUT' 'NATURE' 'DISCRET' ;

                  SINON ;
                     RES1 = KRES ($MA1.&BCLCOM) 'TYPI' ($TAB1.&BCLCOM)
                                                'CLIM' ($S1.&BCLCOM)
                                                'SMBR' ($S2.&BCLCOM)
                                                'IMPR' IMPKRES ;
                  FINS ;
                  RES = RES ET RES1 ;
               FIN BCLCOM ;
            FINS ;
         FINS ;
*
*
*        ===============================================
*        ÉTAPE DE PROJECTION STANDARD : CALCUL DE C*Û[n]
*        ===============================================
*
         SI TESTPRJ ;
*
            CUN = KMF (RVP.'MATC') RES ;
            SI TVNP ;
               CXN = KMF (RVP.'MBTR') RES ;
               CUN = CUN ET CXN ;
            FINS ;
*
*           On calcule les seconds membres de l'équation de pression
*           s'ils existent (opérateurs FIMP)
            REPE BLOCPJ (DIME (RVP.'LISTOPER')) ;
               NOMPER = EXTR &BLOCPJ (RVP.'LISTOPER') ;
               NOMTAB = CHAI &BLOCPJ NOMPER ;
               SI (EGA NOMPER 'FIMP') ;
                  MSI MAI = (TEXTE NOMPER) (RVP.NOMTAB) ;
                  CUN = CUN ET MSI ;
               FINS ;
            FIN BLOCPJ ;
*
            CUN = CUN * ROW * (-1./DT) ;
*
*           Calcul de Lamdba[n]
            RVP.'METHINV'.'XINIT' = RV.'resmnp' ;
            SL =  KRESP MATPR 'TYPI' (RVP.'METHINV')
                              'CLIM' (RVP.'CLIM' )
                              'SMBR' CUN
                              'IMPR' IMPKRES ;
            OUBL CUN ;
            RV.'resmnp' = SL ;
*
            CTL = KMF (RVP.'MATC') SL 'TRAN' ;
            SI TVNP ;
               CXL = KMF (RVP.'MBTR') SL 'TRAN' ;
               CTL = CTL + CXL ;
            FINS ;
*
*           Elimination of end of step velocity
*           (si 'PNM2' existe, on ne corrige pas)
            SI (NON TPNM2) ;
               SI (NON (EXIS (RV.'INCO') 'PNM2')) ;
                  A = NOMC LCU LC (KOPS IDIGV '*' CTL) ;
                  RES = RES + ((1./ROW)*A*DT) ;
               FINS ;
            FINS ;
            OUBL CTL ;
*
         FINS ;
*
*
*        ===================
*        AVANCEMENT EN TEMPS
*        ===================
*
*          SI (TESTPRJ ET (EGA MDFDT 0)) ;
*             IMPTCRR = IIMPR ;
*          FINS ;
         SI (EGA MDFDT 0) ;
            IMPTCRR = IIMPR ;
         FINS ;
         IMPKRES = 0 ;
*
*          MESS 'On passe dans TCRR ' ;
         LCMP = EXTR RES 'COMP' ;
         SI (EXIS LCMP 'LX') ;
*             AG = EXTR (EXCO RES 'LX') 'MAILLAGE' ;
*             AR = EXTR RES 'MAILLAGE' ;
*             ATN = DIFF AR AG ;
*             RES = REDU RES ATN ;
            RES = ENLE RES 'LX' ;
         FINS ;
*
         EPS = TCRR RES OMEG (RV.'INCO') 'IMPR' IMPTCRR ;
*
         RV.'METHINV'.'CALPREC' = FAUX ;
         SI (TESTPRJ) ;
            RVP.'METHINV'.'CALPREC'= FAUX ;
         FINS ;
*
         RV.'resmn' = RES ;
*
         MENA ;
*
         SI (RV.'STOPITER') ;
            RV.'STOPITER' = FAUX ;
            QUIT BLOCI ;
         FINS ;
*
      FIN BLOCI ;
*     ******************************************
*     ******************************************
*     FIN DE LA BOUCLE INTERNE (= NON-LINEARITE)
*     ******************************************
*     ******************************************
*
*
*       MESS ' ITMAX= ' ITMAX ' MDFDT= ' MDFDT ;
*
      IRT=0 ;
      SI (EGA ITMAX 0) ;
         IRT = TCNM RV 'NOUP' ;
      SINON ;
         IRT = TCNM RV ;
      FINS ;
*
*     ------------------------------------------------------------
*     Avancement en temps pour l'algorithme de projection standard
*     => P[n+1] = P[n] + Lambda
*     ------------------------------------------------------------
      SI TESTPRJ ;
         SI (NON (EXIS (RV.'INCO') 'PRESSION')) ;
            RV.'INCO'.'PRESSION' = SL ;
            SI TPNM2 ;
               RV.'INCO'.'PNM2' = SL ;
            FINS ;
         SINON ;
            PNM1 = RV.'INCO'.'PRESSION' ;
            SI (EGA ISCHT 1) ;
               PN = PNM1 + (1.5*SL) ;
            SINON ;
               PN = PNM1 + SL ;
            FINS ;

            SI TPNM2 ;
               RV.'INCO'.'PNM2' = PNM1 ;
            FINS ;
            RV.'INCO'.'PRESSION' = PN ;
         FINS ;

         SI ((EGA TYPROJ 'PSCT') OU (EGA TYPROJ 'PENA')) ;
            RV.'INCO'.'PRESSION' = SL ;
         FINS ;

         OUBL SL ;
      FINS ;
*
*     ----------------------------------------
*     Traitement spécifique (non documenté...)
*     ----------------------------------------
      SI TESTRAN ;
         RV.'CO'.'VITESSE' = KOPS (RV.'INCO'.NOMVI) '-'  (RV.'SEDIM') ;
         K = 'ABS' (RV.'INCO'.'KN') ;
         E = 'ABS' (RV.'INCO'.'EN') ;
         K = KOPS (KOPS K '*' K) '/' E ;
         DIF = KOPS (KOPS K '*' 0.09) '+' (RV.'COEF') ;
         RV.'CO'.'DIFFU'   = NOEL RVPD DIF ;
         RV.'CO'.'TEMPERA' = RV.'INCO'.'CN' ;
      FINS ;
*
*
*
      RV.'METHINV'.'CALPREC' = FAUX ;
      SI (TESTPRJ) ;
         RVP.'METHINV'.'CALPREC'= FAUX ;
      FINS ;
*
      MENA ;
*
      SI (EGA IRT 1) ;
         MESS 'TEMPS FINAL ATTEINT : ' (RV.'PASDETPS'.'TPS') ;
         QUIT BLOC1 ;
      FINS ;
*
      SI (RV.'STOPPDT') ;
         RV.'STOPPDT' = FAUX ;
         MESS 'ARRET DEMANDÉ AU TEMPS : ' (RV.'PASDETPS'.'TPS') ;
         QUIT BLOC1 ;
      FINS ;
*
   FIN BLOC1 ;
*  *****************************************
*  *****************************************
*  FIN DE LA BOUCLE EXTERNE (= PAS DE TEMPS)
*  *****************************************
*  *****************************************
*
*
   SI TESTPR ;
      RVP.'PRESSION' = KCHT RVPD 'SCAL' 'CENTRE' (RVP.'PRESSION') ;
      RVP.'PN'       = ELNO RVPD (RVP.'PRESSION') ;
   FINS ;
*
FINP ;
*


