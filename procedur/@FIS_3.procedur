$$$$ @FIS_3
* @FIS_3    PROCEDUR  CHAT      12/08/07    21:15:02     7481
*
debproc @FIS_3 c*flottant a*flottant lo*flottant
                 to*flottant ho*flottant eps*flottant
                 nt*entier nc*entier ns*entier
                 rc0*flottant rc1*flottant rc2*flottant rc3*flottant
                 beta*flottant alpha*flottant
                 ndt*entier nsdt*entier
                 xl*entier xt*entier xh*entier
                 d1*mot d2*mot ;
*
saut ligne ;
mess '*****************************************************' ;
mess '****  PROCEDURE DE MAILLAGE D"UN BLOC FISSURE 3D ****' ;
mess '*****************************************************' ;
saut ligne ;
*
oeil = -100 -310 200 ;
*
* Tests sur les parametres d'entree de la procedure
* ------------------------------------------------
*
si ((a < 0) ou (c < 0) ou (lo < 0) ou (to < 0) ou (ho < 0)
    ou (rc0 < 0) ou (rc1 < 0) ou (rc2 < 0) ou (rc3 < 0)
    ou (xl < 0) ou (xt < 0) ou (xh < 0) ou (nt < 0)) ;
   saut ligne ;
   mess '================================================== ' ;
   mess '                 ATTENTION !!!                     ' ;
   saut ligne ;
   mess '  Un parametre au moins est negatif ...            ' ;
   mess '  Tous les parametres doivent etre positifs.       ' ;
   mess '      -----  VERIFIEZ VOS DONNEES  ----            ' ;
   saut ligne ;
   mess '      ------ ON SORT DE LA PROCEDURE -----         ' ;
   mess '================================================== ' ;
quit @FIS_3 ;
finsi ;
*
si ((ndt neg 1) et (ndt neg 2)) ;
   saut ligne ;
   mess '================================================== ' ;
   mess '                 ATTENTION !!!                     ' ;
   saut ligne ;
   mess '     Le nombre de couronnes de deraffinement       ' ;
   mess '     des tranches doit etre egal a 1 ou 2          ' ;
   mess '  ndt =' ndt ;
   saut ligne ;
   mess '      ------ ON SORT DE LA PROCEDURE -----         ' ;
   mess '================================================== ' ;
quit @FIS_3 ;
finsi ;
*
si ((alpha > 1.) ou (alpha < 0.)) ;
   saut ligne ;
   mess '================================================== ' ;
   mess '                 ATTENTION !!!                     ' ;
   saut ligne ;
   mess '     Le parametre imposant l"inclinaison           ' ;
   mess '     des tranches doit etre compris entre 0 et 1   ' ;
   mess '     alpha =' alpha ;
   saut ligne ;
   mess '      ------ ON SORT DE LA PROCEDURE -----         ' ;
   mess '================================================== ' ;
quit @FIS_3 ;
finsi ;
*
si ((beta > 1.) ou (beta < 0.)) ;
   saut ligne ;
   mess '================================================== ' ;
   mess '                 ATTENTION !!!                     ' ;
   saut ligne ;
   mess '     Le parametre imposant le decoupage            ' ;
   mess '     des tranches doit etre compris entre 0 et 1   ' ;
   mess '     beta =' beta ;
   saut ligne ;
   mess '      ------ ON SORT DE LA PROCEDURE -----         ' ;
   mess '================================================== ' ;
quit @FIS_3 ;
finsi ;
*
si ((eps > 1.) ou (eps < 0)) ;
   saut ligne ;
   mess '================================================== ' ;
   mess '                 ATTENTION !!!                     ' ;
   saut ligne ;
   mess '     Le demi angle d"ouverture de la fissure       ' ;
   mess '     doit etre compris entre 0 et 1 degre          ' ;
   mess '     eps =' eps ;
   saut ligne ;
   mess '      ------ ON SORT DE LA PROCEDURE -----         ' ;
   mess '================================================== ' ;
quit @FIS_3 ;
finsi ;
*
si (lo < c) ;
   saut ligne ;
   mess '================================================== ' ;
   mess '                 ATTENTION !!!                     ' ;
   saut ligne ;
   mess '     La longueur du bloc doit etre superieure      ' ;
   mess '     au demi grand axe                             ' ;
   mess '     lo =' lo ;
   mess '     c =' c ;
   saut ligne ;
   mess '      ------ ON SORT DE LA PROCEDURE -----         ' ;
   mess '================================================== ' ;
quit @FIS_3 ;
finsi ;
*
si ((neg d1 'non') et (neg d1 'oui')) ;
   saut ligne ;
   mess '================================================== ' ;
   mess '                 ATTENTION !!!                     ' ;
   saut ligne ;
   mess '  Le mot cle imposant le deplacement des noeuds    ' ;
   mess '  intermediares du "boudin torique" doit etre egal ' ;
   mess '  a : oui ou non, en minuscules et entre cotes.    ' ;
     saut ligne ;
   mess '      ------ ON SORT DE LA PROCEDURE -----         ' ;
   mess '================================================== ' ;
quit @FIS_3 ;
finsi ;
*
si ((neg d2 'non') et (neg d2 'oui')) ;
   saut ligne ;
   mess '================================================== ' ;
   mess '                 ATTENTION !!!                     ' ;
   saut ligne ;
   mess '  Le mot cle imposant le maillage rayonnant sur la ' ;
   mess '  face exterieure au boudin torique doit etre egal ' ;
   mess '  a : oui ou non, en minuscules et entre cotes.    ' ;
     saut ligne ;
   mess '      ------ ON SORT DE LA PROCEDURE -----         ' ;
   mess '================================================== ' ;
quit @FIS_3 ;
finsi ;
*
si (nt > 64) ;
   saut ligne ;
   mess '================================================== ' ;
   mess '                 ATTENTION !!!                     ' ;
   saut ligne ;
   mess '  Le nombre de tranches doit etre inferieur ou     ' ;
   mess '  egal a 64                                        ' ;
   saut ligne ;
   mess '  VOUS AVEZ UN NOMBRE DE TRANCHES DE' nt           ;
   saut ligne ;
   mess '      ------ ON SORT DE LA PROCEDURE -----         ' ;
   mess '================================================== ' ;
quit @FIS_3 ;
finsi ;
*
i = 1 ;
puis = 0 ;
repe bouc1 6 ;
 i = i + 1 ;
 if = flottant i ;
 ndivf = flottant nt ;
 deux = ndivf ** (1 / if) ;
    si (deux ega 2 .001) ;
       puis = 1 ;
       quit bouc1 ;
    finsi ;
fin bouc1 ;
*
si (puis ega 0) ;
   saut ligne ;
   mess '================================================== ' ;
   mess '    ATTENTION !!!  Le nombre de tranches doit etre ' ;
   mess '                   une puissance de 2              ' ;
   mess '                                                   ' ;
   mess '  VOUS AVEZ UN NOMBRE DE TRANCHES DE' nt           ;
   saut ligne ;
   mess '      ------ ON SORT DE LA PROCEDURE -----         ' ;
   mess '================================================== ' ;
   saut ligne ;
   quit @FIS_3 ;
finsi ;
*
si ((nsdt neg 2) et (nsdt neg 4)) ;
   saut ligne ;
   mess '================================================== ' ;
   mess '                 ATTENTION !!!                     ' ;
   saut ligne ;
   mess '  Le nombre de secteurs des couronnes de           ' ;
   mess '  deraffinement des tranches doit etre             ' ;
   mess '  egal a 2 ou 4                                    ' ;
   saut ligne ;
   mess '  VOUS AVEZ UN NOMBRE DE SECTEUR (nsdt) DE' nsdt     ;
   saut ligne ;
   mess '      ------ ON SORT DE LA PROCEDURE -----         ' ;
   mess '================================================== ' ;
quit @FIS_3 ;
finsi ;
*
*----------------------------------------
* Calcul de la profondeur du bloc initial
* ---------------------------------------
bsura = a / c ;
*
si (bsura < .15) ;
* CMODI BK 10/3/95
*   t = a / .7 ;
   t = a / .6 ;
finsi ;
si (bsura > .15) ;
* CMODI BK 10/3/95
*    t = a / .6 ;
    t = a / .5 ;
finsi ;
*
bsurt = a / t ;
bsurto = a / to ;
*
rallon = 1 ;
si (bsurto >EG ((1.-1.E-6)*bsurt)) ;
   t = a / bsurto ;
   rallon = 0 ;
finsi ;
*
* --------------------------------------
ns = ns * 4 ;
nt = nt * 2 ;
*
*
 si ((nt <EG 8) et (ndt ega 2)) ;
  mess '=========================================================' ;
  mess '    ATTENTION !!! Vous ne pouvez pas utiliser 2 couronnes' ;
  mess '                  de deraffinement avec 4 tranches       ' ;
  mess '=========================================================' ;
  quit @FIS_3 ;
 finsi ;
*
*
* maillage 2D de la section du tore dans le plan xoz
* --------------------------------------------------
*
flag_eps = 1 ;
 si (eps ega 0) ;
    eps = .1 ;
    flag_eps = 0 ;
 finsi ;
*
o = 0. 0. 0. ;
ox = c 0. 0. ;
coseps = cos eps ;
sineps = sin eps ;
crit_cer = rc0 / 1.E4 ;
p0 = (c - (crit_cer * coseps)) 0.
     (-1. * crit_cer * sineps) ;
p1 = (c - (rc0 * coseps)) 0. ( -1. * rc0 * sineps) ;
angrot = 180. - eps ;
loxp1 = p0 d nc p1 ;
nsdemi = ns / 2 ;
nsquart = ns / 4;
* demi boudin inferieur
mbase = loxp1 rota nsdemi angrot ox (c -1. 0.) ;
* fusion des noeuds situes pres du centre du maillage 2D en etoile
mbapoi = changer poi1 mbase ;
confon = mbapoi poin sphe ox p0 (rc0 / 1.E4) ;
elim confon (rc0 / 1.E4) ;
mbase = rege mbase ;
mbase = mbase coul roug ;
*
* premiere couronne de transition
* -------------------------------
*
p2 = (c - ((1 + rc1) * rc0 * coseps)) 0.
     ( -1. * (1 + rc1) * rc0 * sineps) ;
p3 = (c - ((1 + rc1 + rc2) * rc0 * coseps)) 0.
     (-1 * (1 + rc1 + rc2) * rc0 * sineps) ;
lp1p2 = p1 d 1 p2 ;
q1 = (c + rc0) 0. 0. ;
q2 = (c + ((1 + rc1) * rc0)) 0. 0. ;
q3 = (c + ((1 + rc1 + rc2) * rc0)) 0. 0. ;
undemi = 1./2. ;
*
si (nsdt ega 4) ;
   nbp1bq1b = 8 ;
sinon ;
   nbp1bq1b = (4 + nsdemi) / 2 ;
finsi ;
*
xp1b = undemi*( ( 2. * c ) - ( coseps * rc0 * (2. + rc1) )) ;
yp1b = 0. ;
zp1b = undemi*( -1. * (2 + rc1) *  rc0 * sineps ) ;
xq1b = undemi*( ( 2. * c ) + ( (2 + rc1) * rc0 ) ) ;
yq1b = 0. ;
zq1b = 0. ;
p1b  = xp1b yp1b zp1b ;
q1b  = xq1b yq1b zq1b ;
opti elem seg3 ;
lp1p1b  = p1 d 1 p1b ;
lp1bq1b = p1b cerc nbp1bq1b ox q1b ;
lp2q2   = p2  cerc 4        ox q2  ;
lp1q1   = p1  cerc nsdemi   ox q1  ;
si ( EGA nsdemi 12) ;
 chp1bq1b = chan lp1bq1b poi1 ;
 chp1q1   = chan lp1q1   poi1 ;
*
* tri de la ligne lp1bq1b
*
i = 0 ;
tab1 = table ;
tab2 = table ;
nbval = nbno chp1bq1b ;
repeter bouc5 nbval ;
 i = i + 1 ;
 pcour_c = chp1bq1b poin i ;
 xp = coor 1 pcour_c ;
 yp = coor 2 pcour_c ;
 zp = coor 3 pcour_c ;
 tab1 . i = xp ;
 tab2 . i = pcour_c ;
fin bouc5 ;
tab2 = @FIS_1 tab1 tab2 ;
*
* tri de la ligne lp1q1
*
i = 0 ;
tab3 = table ;
tab4 = table ;
nbval = nbno chp1q1 ;
repeter bouc5 nbval ;
 i = i + 1 ;
 pcour_c = chp1q1 poin i ;
 xp = coor 1 pcour_c ;
 yp = coor 2 pcour_c ;
 zp = coor 3 pcour_c ;
 tab3 . i = xp ;
 tab4 . i = pcour_c ;
fin bouc5 ;
tab4 = @FIS_1 tab3 tab4 ;
*
* construction des points milieu interieur couronne
*
 lpoin_m = table ;
 poin_m  = table ;
 i = 0 ;
 j = 1 ;
 opti elem seg3 ;
 lpoin_m . 1  = chan ( (tab4 . 1  ) d 1 (tab2 . 1  ) ) poi1 ;
 lpoin_m . 2  = chan ( (tab4 . 3  ) d 1 (tab2 . 3  ) ) poi1 ;
 lpoin_m . 3  = chan ( (tab4 . 5  ) d 1 (tab2 . 3  ) ) poi1 ;
 lpoin_m . 4  = chan ( (tab4 . 7  ) d 1 (tab2 . 5  ) ) poi1 ;
 lpoin_m . 5  = chan ( (tab4 . 9  ) d 1 (tab2 . 7  ) ) poi1 ;
 lpoin_m . 6  = chan ( (tab4 . 11 ) d 1 (tab2 . 7  ) ) poi1 ;
 lpoin_m . 7  = chan ( (tab4 . 13 ) d 1 (tab2 . 9  ) ) poi1 ;
 lpoin_m . 8  = chan ( (tab4 . 15 ) d 1 (tab2 . 11 ) ) poi1 ;
 lpoin_m . 9  = chan ( (tab4 . 17 ) d 1 (tab2 . 11 ) ) poi1 ;
 lpoin_m . 10 = chan ( (tab4 . 19 ) d 1 (tab2 . 13 ) ) poi1 ;
 lpoin_m . 11 = chan ( (tab4 . 21 ) d 1 (tab2 . 15 ) ) poi1 ;
 lpoin_m . 12 = chan ( (tab4 . 23 ) d 1 (tab2 . 15 ) ) poi1 ;
 lpoin_m . 13 = chan ( (tab4 . 25 ) d 1 (tab2 . 17 ) ) poi1 ;
*
* construction des elements de la couronne
*
 opti elem qua8 ;
 elem1  = manu qua8 (tab4 . 1)  (poin 2 (lpoin_m . 1) )
                    (tab2 . 1)  (tab2 . 2)
                    (tab2 . 3)  (poin 2 (lpoin_m . 2) )
                    (tab4 . 3)  (tab4 . 2) ;
 elem2  = manu tri6 (tab4 . 3)  (poin 2 (lpoin_m . 2) )
                    (tab2 . 3)  (poin 2 (lpoin_m . 3) )
                    (tab4 . 5)  (tab4 . 4) ;
 elem3  = manu qua8 (tab4 . 5)  (poin 2 (lpoin_m . 3) )
                    (tab2 . 3)  (tab2 . 4)
                    (tab2 . 5)  (poin 2 (lpoin_m . 4) )
                    (tab4 . 7)  (tab4 . 6) ;
*
 elem4  = manu qua8 (tab4 . 7)  (poin 2 (lpoin_m . 4) )
                    (tab2 . 5)  (tab2 . 6)
                    (tab2 . 7)  (poin 2 (lpoin_m . 5) )
                    (tab4 . 9)  (tab4 . 8) ;
 elem5  = manu tri6 (tab4 . 9)  (poin 2 (lpoin_m . 5) )
                    (tab2 . 7)  (poin 2 (lpoin_m . 6) )
                    (tab4 . 11) (tab4 . 10) ;
 elem6  = manu qua8 (tab4 . 11) (poin 2 (lpoin_m . 6) )
                    (tab2 . 7)  (tab2 . 8)
                    (tab2 . 9)  (poin 2 (lpoin_m . 7) )
                    (tab4 . 13) (tab4 . 12) ;
*
 elem7  = manu qua8 (tab4 . 13) (poin 2 (lpoin_m . 7) )
                    (tab2 . 9 ) (tab2 . 10)
                    (tab2 . 11) (poin 2 (lpoin_m . 8) )
                    (tab4 . 15) (tab4 . 14) ;
 elem8  = manu tri6 (tab4 . 15) (poin 2 (lpoin_m . 8) )
                    (tab2 . 11) (poin 2 (lpoin_m . 9) )
                    (tab4 . 17) (tab4 . 16) ;
 elem9  = manu qua8 (tab4 . 17) (poin 2 (lpoin_m . 9) )
                    (tab2 . 11) (tab2 . 12)
                    (tab2 . 13) (poin 2 (lpoin_m . 10) )
                    (tab4 . 19) (tab4 . 18) ;
*
 elem10 = manu qua8 (tab4 . 19) (poin 2 (lpoin_m . 10) )
                    (tab2 . 13) (tab2 . 14 )
                    (tab2 . 15) (poin 2 (lpoin_m . 11) )
                    (tab4 . 21) (tab4 . 20) ;
 elem11 = manu tri6 (tab4 . 21) (poin 2 (lpoin_m . 11) )
                    (tab2 . 15) (poin 2 (lpoin_m . 12) )
                    (tab4 . 23) (tab4 . 22 ) ;
 elem12 = manu qua8 (tab4 . 23) (poin 2 (lpoin_m . 12) )
                    (tab2 . 15) (tab2 . 16)
                    (tab2 . 17) (poin 2 (lpoin_m . 13) )
                    (tab4 . 25) (tab4 . 24) ;
*
 mtran11 = elem1  et elem2  et elem3  et
           elem4  et elem5  et elem6  et
           elem7  et elem8  et elem9  et
           elem10 et elem11 et elem12 ;
elim mtran11 (c / 1.E4) ;
sinon ;
 opti elem seg3 ;
 coutou1 = lp1p1b et lp1bq1b et
           (q1b d 1 q1) et (inve lp1q1) ;
 opti elem qua8 ;
*
*CMODI BK le 10/5/95
*
si ((EGA ns 8) et (EGA nsdt 2)) ;
 mtran11 =  lp1q1 regler 1 lp1bq1b ;
sinon ;
 mtran11 = surf coutou1 plan ;
finsi ;
finsi ;
*
si (nsdt ega 2) ;
*
 opti elem seg3 ;
 coutou2 = (p1b d 1 p2)  et lp2q2 et
           (q2  d 1 q1b) et (inve lp1bq1b);
 opti elem qua8 ;
si (EGA ns 8) ;
 mtran12 =  lp2q2 regler 1 lp1bq1b ;
sinon ;
 mtran12 = surf coutou2 plan ;
finsi ;
*
 mtran1  = mtran11 et mtran12 ;
*
sinon ;
*
 mtran1 = mtran11 ;
*
finsi ;
*
 mtran1 = mtran1 coul bleu ;
 elim (c / 1.E4) mtran1 mbase ;
 mgen = mbase et mtran1 ;
*
* deuxieme couronne de transition
*
*
p6 = q3 moins (0. 0. ((1 + rc1 + rc2) * rc0)) ;
p4 = (c - ((1 + rc1 + rc2) * rc0 * coseps)) 0.
     (-1 * (1 + rc1 + rc2) * rc0 ) ;
p5 = plus p4 p6  / 2;
*
si (nsdt ega 2) ;
*
  pasang = (180 - eps) / 4 ;
*
  p4b = q2 tour ox (c 1 0) (3 * pasang) ;
  p5b = q2 tour ox (c 1 0) (2 * pasang) ;
  p6b = q2 tour ox (c 1 0) (1 * pasang) ;
*
  mtran21 alpha_m1 al_max1 sommet11 sommet31 sommet51
  sommet71
                           = @FIS_2 p3 p2 p4b p4 ox c a
                             alpha beta nt 1;
*
  mtran22 alpha_m2 al_max2 sommet12 sommet32 sommet52
  sommet72
                           = @FIS_2 p4 p4b p5b p5 ox c a
                             alpha beta nt 1;
*
  mtran23 alpha_m3 al_max3 sommet13 sommet33 sommet53
  sommet73
                           = @FIS_2 p5 p5b p6b p6 ox c a
                             alpha beta nt 1;
*
  mtran24 alpha_m4 al_max4 sommet14 sommet34 sommet54
  sommet74
                           = @FIS_2 p6 p6b q2 q3 ox c a
                             alpha beta nt 1;
*
  al_m_c1 = prog alpha_m1 alpha_m2 alpha_m3 alpha_m4 ;
  alpha_c1 = mini al_m_c1 ;
*
  al_max = prog al_max1 al_max2 al_max3 al_max4 ;
  almax = maxi al_max ;
*
  lref = sommet74 ;
*
sinon ;
*
  pasang = (180 - eps) / 8 ;
*
  p24b  = q1b tour ox (c 1 0) (7 * pasang) ;
  p4b   = q1b tour ox (c 1 0) (6 * pasang) ;
  p4b5b = q1b tour ox (c 1 0) (5 * pasang) ;
  p5b   = q1b tour ox (c 1 0) (4 * pasang) ;
  p5b6b = q1b tour ox (c 1 0) (3 * pasang) ;
  p6b   = q1b tour ox (c 1 0) (2 * pasang) ;
  p6b2  = q1b tour ox (c 1 0) (1 * pasang) ;
*
p63 = plus q3 p6 / 2 ;
p56 = plus p6 p5 / 2 ;
p45 = plus  p4 p5 / 2 ;
p34 = plus  p3 p4  / 2;
*
  mtran21 alpha_m1 al_max1 sommet11 sommet31 sommet51
  sommet71
                           = @FIS_2 p3 p1b p24b p34 ox c a
                             alpha beta nt 1;
*
  mtran22 alpha_m2 al_max2 sommet12 sommet32 sommet52
  sommet72
                           = @FIS_2 p34 p24b p4b p4 ox c a
                             alpha beta nt 1;
*
  mtran23 alpha_m3 al_max3 sommet13 sommet33 sommet53
  sommet73
                           = @FIS_2 p4 p4b p4b5b p45 ox c a
                             alpha beta nt 1;
*
  mtran24 alpha_m4 al_max4 sommet14 sommet34 sommet54
  sommet74
                           = @FIS_2 p45 p4b5b p5b p5 ox c a
                             alpha beta nt 1;
*
  mtran25 alpha_m5 al_max5 sommet15 sommet35 sommet55
  sommet75
                           = @FIS_2 p5 p5b p5b6b p56 ox c a
                             alpha beta nt 1;
*
  mtran26 alpha_m6 al_max6 sommet16 sommet36 sommet56
  sommet76
                           = @FIS_2 p56 p5b6b p6b p6 ox c a
                             alpha beta nt 1;
*
  mtran27 alpha_m7 al_max7 sommet17 sommet37 sommet57
  sommet77
                           = @FIS_2 p6 p6b p6b2 p63 ox c a
                             alpha beta nt 1;
*
  mtran28 alpha_m8 al_max8 sommet18 sommet38 sommet58
  sommet78
                           = @FIS_2 p63 p6b2 q1b q3 ox c a
                             alpha beta nt 1;
*
  al_m_c1 = prog alpha_m1 alpha_m2 alpha_m3 alpha_m4
                 alpha_m5 alpha_m6 alpha_m7 alpha_m8 ;
  alpha_c1 = mini al_m_c1 ;
*
  al_max = prog al_max1 al_max2 al_max3 al_max4
                al_max5 al_max6 al_max7 al_max8 ;
  almax = maxi al_max ;
*
  lref = sommet78 ;
*
finsi ;
*
  saut ligne ;
  mess '--------------------------------------------------' ;
  mess 'ANGLE MINI SUR LES PRISMES DE LA PREMIERE COURONNE' ;
  mess 'DE DERAFFINEMENT DES TRANCHES =' alpha_c1 'DEGRES'  ;
  saut ligne ;
  mess '    POUR AUGMENTER CET ANGLE : AUGMENTER "rc2" ' ;
  mess '                               DIMINUER  "rc0" ' ;
  saut ligne ;
  mess '--------------------------------------------------' ;
  saut ligne ;
*
si (almax > 175.) ;
  mess '----------------------------------------------------' ;
  mess 'L"ANGLE MAXI SUR LES PRISMES DE LA PREMIERE COURONNE' ;
  mess 'DE DERAFFINEMENT DES TRANCHES EST TROP GRAND :' almax ;
  mess 'DEGRES !!!   ERREUR SUR LA GENERATION DU MAILLAGE    ' ;
  saut ligne ;
  mess '    POUR DIMINUER CET ANGLE : AUGMENTER "rc2" ' ;
  mess '                              DIMINUER  "rc0" ' ;
  saut ligne ;
  mess '   ATTENTION !!! ---- ON SORT DE LA PROCEDURE ----- ' ;
  saut ligne ;
  mess '----------------------------------------------------' ;
  saut ligne ;
quit @FIS_3 ;
finsi ;
*
si (nsdt ega 2) ;
   mtran2 = mtran21 et mtran22 et mtran23 et mtran24 ;
sinon ;
   mtran2 = mtran21 et mtran22 et mtran23 et mtran24 et
            mtran25 et mtran26 et mtran27 et mtran28 ;
finsi ;
*
elim mtran2 (c / 1.E4);
*
*
 si (flag_eps ega 0) ;
saut ligne ;
mess '===========================================================' ;
mess '    ATTENTION !!! Vous ne pouvez pas utiliser un demi-angle' ;
mess '                  d"ouverture de la fissure egal a 0 degre ' ;
mess '                                                           ' ;
mess '    LA PROCEDURE FIXE CET ANGLE A 0.1 DEGRE PAR DEFAUT     ' ;
mess '    ET PROJETTE LA LEVRE SUR LE PLAN Z=0                   ' ;
mess '===========================================================' ;
saut ligne ;
 finsi ;
*
* troisieme couronne de transition
* --------------------------------
*
si (ndt ega 2) ;
*
p7 = (c - ((1 + rc1 + rc2 + rc3) * rc0 * coseps)) 0.
     (-1 * (1 + rc1 + rc2 + rc3) * rc0 * sineps) ;
p8 = (c - ((1 + rc1 + rc2 + rc3) * rc0 * coseps)) 0.
     (-1 * (1 + rc1 + rc2 + rc3) * rc0 ) ;
p10 = (c + ((1 + rc1 + rc2 + rc3) * rc0 * coseps)) 0.
      (-1 * (1 + rc1 + rc2 + rc3) * rc0 ) ;
p9 = plus p8 p10 / 2 ;
p11 = (c + ((1 + rc1 + rc2 + rc3) * rc0)) 0. 0. ;
*
si (nsdt ega 2) ;
*
  mtran31 alpha_m1 al_max1 sommet11 sommet31 sommet51
  sommet71
                           = @FIS_2 p7 p3 p4 p8 o c a
                             alpha beta nt 2;
*
  mtran32 alpha_m2 al_max2 sommet12 sommet32 sommet52
  sommet72
                           = @FIS_2 p8 p4 p5 p9 o c a
                             alpha beta nt 2;
*
  mtran33 alpha_m3 al_max3 sommet13 sommet33 sommet53
  sommet73
                           = @FIS_2 p9 p5 p6 p10 o c a
                             alpha beta nt 2;
*
  mtran34 alpha_m4 al_max4 sommet14 sommet34 sommet54
  sommet74
                           = @FIS_2 p10 p6 q3 p11 o c a
                             alpha beta nt 2;
*
  al_m_c2 = prog alpha_m1 alpha_m2 alpha_m3 alpha_m4 ;
  alpha_c2 = mini al_m_c2 ;
*
  al_max = prog al_max1 al_max2 al_max3 al_max4 ;
  almax2 = maxi al_max ;
*
  lref = sommet74 ;
*
sinon ;
*
  p78 = plus p7 p8 / 2 ;
  p89 = plus p8 p9 / 2;
  p910 = plus p9 p10 / 2 ;
  p1011 = plus p10 p11 / 2 ;
*
  mtran31 alpha_m1 al_max1 sommet11 sommet31 sommet51
  sommet71
                           = @FIS_2 p7 p3 p34 p78 o c a
                             alpha beta nt 2;
*
  mtran32 alpha_m2 al_max2 sommet12 sommet32 sommet52
  sommet72
                           = @FIS_2 p78 p34 p4 p8 o c a
                             alpha beta nt 2;
*
  mtran33 alpha_m3 al_max3 sommet13 sommet33 sommet53
  sommet73
                           = @FIS_2 p8 p4 p45 p89 o c a
                             alpha beta nt 2;
  mtran34 alpha_m4 al_max4 sommet14 sommet34 sommet54
  sommet74
                           = @FIS_2 p89 p45 p5 p9 o c a
                             alpha beta nt 2;
*
  mtran35 alpha_m5 al_max5 sommet15 sommet35 sommet55
  sommet75
                           = @FIS_2 p9 p5 p56 p910 o c a
                             alpha beta nt 2;
*
  mtran36 alpha_m6 al_max6 sommet16 sommet36 sommet56
  sommet76
                           = @FIS_2 p910 p56 p6 p10 o c a
                             alpha beta nt 2;
*
  mtran37 alpha_m7 al_max7 sommet17 sommet37 sommet57
  sommet77
                           = @FIS_2 p10 p6 p63 p1011 o c a
                             alpha beta nt 2;
*
  mtran38 alpha_m8 al_max8 sommet18 sommet38 sommet58
  sommet78
                           = @FIS_2 p1011 p63 q3 p11 o c a
                             alpha beta nt 2;
*
  al_m_c2 = prog alpha_m1 alpha_m2 alpha_m3 alpha_m4
                 alpha_m5 alpha_m6 alpha_m7 alpha_m8 ;
  alpha_c2 = mini al_m_c2 ;
*
  al_max = prog al_max1 al_max2 al_max3 al_max4
                al_max5 al_max6 al_max7 al_max8 ;
  almax2 = maxi al_max ;
*
  lref = sommet78 ;
*
finsi ;
*
  saut ligne ;
  mess '--------------------------------------------------' ;
  mess 'ANGLE MINI SUR LES PRISMES DE LA DEUXIEME COURONNE' ;
  mess 'DE DERAFFINEMENT DES TRANCHES =' alpha_c2 'DEGRES'  ;
  saut ligne ;
  mess '    POUR AUGMENTER CET ANGLE : AUGMENTER "rc3" ' ;
  mess '                               DIMINUER  "rc0" ' ;
  saut ligne ;
  mess '--------------------------------------------------' ;
  saut ligne ;
*
si (almax2 > 175.) ;
  mess '----------------------------------------------------' ;
  mess 'L"ANGLE MAXI SUR LES PRISMES DE LA DEUXIEME COURONNE' ;
  mess 'DE DERAFFINEMENT DES TRANCHES EST TROP GRAND :' almax2 ;
  mess 'DEGRES !!!   ERREUR SUR LA GENERATION DU MAILLAGE    ' ;
  saut ligne ;
  mess '    POUR DIMINUER CET ANGLE : AUGMENTER "rc3" ' ;
  mess '                              DIMINUER  "rc0" ' ;
  saut ligne ;
  mess '   ATTENTION !!! ---- ON SORT DE LA PROCEDURE ----- ' ;
  saut ligne ;
  mess '----------------------------------------------------' ;
  saut ligne ;
quit @FIS_3 ;
finsi ;
*
si (nsdt ega 2) ;
   mtran3 = mtran31 et mtran32 et mtran33 et mtran34;
sinon ;
   mtran3 = mtran31 et mtran32 et mtran33 et mtran34 et
            mtran35 et mtran36 et mtran37 et mtran38 ;
finsi ;
*
mtran3 = mtran3 coul vert ;
elim mtran3 (c / 1.E4) ;
*
finsi ;
*
*
* parcours de la generatrice elliptique
* -------------------------------------
*
  si (ega ndt 1) ;
     p7 = p3 ;
     p8 = p4 ;
     p9 = p5 ;
     p10 = p6 ;
     p11 = q3 ;
     na = 2 ;
     nb = (nt / 8) ;
     nd = 1 + rc1 + rc2 ;
  sinon ;
     na = 4 ;
     nb = (nt / 16) ;
     nd = 1 + rc1 + rc2 + rc3 ;
  finsi ;
*
l810 = p8 droi 1 p9 droi 1 p10 ;
*
opti elem cu20 ;
ermax = 0 ;
idiv = 0 ;
ndiv2 = nt / 2 ;
lff = ox ;
pcour_m1 = ox ;
dis_max = 0 ;
*
si (nsdt ega 2) ;
   lboulev = ox d nc p1 d 1 p1b d 1 p2 ;
   lbouext = q2 d 1 q1b d 1 q1 d nc ox ;
sinon ;
   lboulev = ox d nc p1 d 1 p1b ;
   lbouext = q1b d 1 q1 d nc ox ;
finsi ;
*
* Cas de la demi ellipse
repeter bloc1 ndiv2 ;
   idiv = idiv + 1 ;
   psi = (idiv * 180.) / nt ;
   si (ega idiv ndiv2) ;
      phi = 90. ;
      cosphi = 0. ;
      sinphi = 1. ;
   sinon ;
      cospsi = cos psi ;
      sinpsi = sin psi ;
      tanpsi = sinpsi / cospsi ;
      tanphi = a * tanpsi / c ;
      phik1  = atg tanphi ;
      phik2  = psi ;
      phi = (beta * phik2) + ((1 - beta) * phik1) ;
      si (phi < 0.) ;
         phi = 180. + phi ;
      finsi ;
      cosphi = cos phi ;
      sinphi = sin phi ;
*
      tanphi = sinphi / cosphi ;
      psiref = atg (c * tanphi / a) ;
      talpha = (alpha * (1 - (c / a))) + (c / a) ;
      tanpsi = talpha * tanphi ;
      psi = atg tanpsi ;
    erreupsi = abs (psiref - psi) ;
    si (erreupsi > ermax) ;
       ermax = erreupsi ;
    finsi ;
   finsi ;
   si (ega idiv nt) ;
      phi = 180. ;
      cosphi = -1. ;
      sinphi = 0. ;
   finsi ;
   xcour = c * cosphi ;
   ycour = a * sinphi ;
   zcour = 0. ;
   pcour = xcour ycour zcour ;
   s_lff = pcour_m1 d 1 pcour ;
   pcour_m1 = pcour ;
   lff = lff d 1 pcour ;
*
* Mesure de la longueur maxi d'un segment de lff
* ----------------------------------------------
   pi_s_lff = s_lff poin initial ;
   pf_s_lff = s_lff poin final ;
   dis_pipf = moins pi_s_lff pf_s_lff  norm ;
    si (dis_pipf > dis_max) ;
       dis_max = dis_pipf ;
    finsi ;
*
   mcour = mgen moins ox ;
   depl mcour tour psi o (0. 0. 1.) ;
   depl mcour plus pcour ;
*
   lboulcou = lboulev moins ox ;
   depl lboulcou tour psi o (0. 0. 1.) ;
   depl lboulcou plus pcour ;
   lbouecou = lbouext moins ox ;
   depl lbouecou tour psi o (0. 0. 1.) ;
   depl lbouecou plus pcour ;
*
* ---------------------------------------------------------------
* -----  Test sur les parametres rc0 rc1 rc2 rc3            ------
* ---------------------------------------------------------------
*
     si (ega ndt 1) ;
        dx1 = rc0 * (1 + rc1 + rc2) ;
*CMODI BK 08/03/95
*        dx2 = dx1 + (rc0 * rc2) ;
        dx2 = dx1 + (2. * rc0 * rc2) ;
     sinon ;
        dx1 = rc0 * (1 + rc1 + rc2 + rc3) ;
*CMODI BK 08/03/95
*        dx2 = dx1 + (rc0 * rc3) ;
        dx2 = dx1 + (2. * rc0 * rc3) ;
     finsi ;
*
* l = longueur du bloc initial
* ----------------------------
l = c + dx2 ;
*
si (ega idiv 1) ;
*
  si (dx1 > (ycour / tanpsi)) ;
   saut ligne ;
   mess '-----------------------------------------------------------';
   mess 'ATTENTION !!  LES VALEURS DES PARAMETRES rc0,rc1,rc2 et rc3';
   mess 'SONT TROP ELEVEES POUR UNE GENERATION CORRECTE DU MAILLAGE' ;
   saut ligne ;
   mess '*** PROBLEME AU NIVEAU DU PLUS PETIT RAYON DE COURBURE **' ;
   mess '-----------------------------------------------------------';
   saut ligne ;
     si (ega ndt 1) ;
       mess 'LA VALEUR MAXI DU TERME rc0 * (1 + rc1 + rc2)' ;
       mess 'DOIT ETRE INFERIEURE A :' (ycour / tanpsi) ;
       saut ligne ;
       mess 'SI VOUS CONSERVEZ rc1,rc2,rc3 ALORS rc0 DOIT ETRE ';
       mess 'INFERIEUR A :' ((ycour / tanpsi) / (1 + rc1 + rc2)) ;
     sinon ;
       mess 'LA VALEUR MAXI DU TERME rc0 * (1 + rc1 + rc2 + rc3)' ;
       mess 'DOIT ETRE INFERIEURE A :' (ycour / tanpsi) ;
       saut ligne ;
       mess 'SI VOUS CONSERVEZ rc1,rc2,rc3 ALORS rc0 DOIT ETRE ';
       mess 'INFERIEUR A :' ;
       mess ((ycour / tanpsi) / (1 + rc1 + rc2 + rc3)) ;
     finsi ;
  finsi ;
      si (dx2 > (t - a )) ;
   saut ligne ;
   mess '-----------------------------------------------------------';
   mess 'ATTENTION !!  LES VALEURS DES PARAMETRES rc0,rc1,rc2 et rc3';
   mess 'SONT TROP ELEVEES POUR UNE GENERATION CORRECTE DU MAILLAGE' ;
   saut ligne ;
   mess '*** PROBLEME AU NIVEAU DU PLUS GRAND RAYON DE COURBURE **' ;
   mess '-----------------------------------------------------------';
   saut ligne ;
     si (ega ndt 1) ;
       mess 'LA VALEUR MAXI DU TERME rc0 * (1 + rc1 + rc2)' ;
       mess 'DOIT ETRE INFERIEURE A :' ((t - a) - (rc0 * rc2)) ;
       saut ligne ;
       mess 'SI VOUS CONSERVEZ rc1,rc2,rc3 ALORS rc0 DOIT ETRE ';
       mess 'INFERIEUR A :' ;
*       mess (((t - a) - (rc0 * rc2)) / (1 + rc1 + rc2)) ;
       mess ((t - a) / (1 + rc1 + (2 * rc2))) ;
     sinon ;
       mess 'LA VALEUR MAXI DU TERME rc0 * (1 + rc1 + rc2 + rc3)' ;
       mess 'DOIT ETRE INFERIEURE A :' ((t - a) - (rc0 * rc3)) ;
       saut ligne ;
       mess 'SI VOUS CONSERVEZ rc1,rc2,rc3 ALORS rc0 DOIT ETRE ';
       mess 'INFERIEUR A :' ;
*       mess (((t - a) - (rc0 * rc3)) / (1 + rc1 + rc2 + rc3)) ;
       mess ((t - a) / (1 + rc1 + rc2 + (2 * rc3))) ;
     finsi ;
      finsi ;
finsi ;
*
*
   p8cour = p8 moins ox ;
   depl p8cour tour psi o (0. 0. 1.) ;
   depl p8cour plus pcour ;
*
   p9cour = p9 moins ox ;
   depl p9cour tour psi o (0. 0. 1.) ;
   depl p9cour plus pcour ;
*
   p10cour = p10 moins ox ;
   depl p10cour tour psi o (0. 0. 1.) ;
   depl p10cour plus pcour ;
*
l810cour = p8cour droi 1 p9cour droi 1 p10cour ;
*
   p7cour = p7 moins ox ;
   depl p7cour tour psi o (0. 0. 1.) ;
   depl p7cour plus pcour ;
   xp7cour = coord 1 p7cour ;
*
   p11cour = p11 moins ox ;
   depl p11cour tour psi o (0. 0. 1.) ;
   depl p11cour plus pcour ;
   xp11cour = coord 1 p11cour ;
*
   xcourp7 = (c - (4 * rc0 * coseps)) * cosphi ;
   zp7 = coor 3 p7 ;
*
   si (ega idiv 1) ;
      boudin = mgen volu 1 mcour ;
      linf_b = lboulev regler 1 lboulcou ;
      linf_bex = lbouext regler 1 lbouecou ;
   sinon ;
      boudin = boudin volu 1 mcour ;
      linf_b = linf_b regler 1 lboulcou ;
      linf_bex = linf_bex regler 1 lbouecou ;
   finsi ;
*
tab_fron = table ;
tab_ang = table ;
tab_int = table ;
*
*   si (ega idiv na) ;
   si (idiv <EG (2 * na)) ;
      si (ega idiv na) ;
         lfronti1 = p7 droi 1 p7cour ;
         lfronte1 = p11 droi 1 p11cour ;
      finsi ;
      si (ega idiv (2 * na)) ;
         p7n1 = p7cour ;
         p11n1 = p11cour ;
         lfronti1 = lfronti1 droi 1 p7cour ;
         lfronte1 = lfronte1 droi 1 p11cour ;
      finsi ;
*
*
* On ecrit dans la table tab_fron les points de la ligne
* lfrontex et dans la table tab_ang l'angle de la tranche
* -------------------------------------------------------
*
tab_fron . 1 = p11cour ;
tab_ang . 1 = tanpsi ;
it = 1 ;
   sinon ;
      indd = idiv / na  entier;
      ind  = idiv - (indd * na) ;
          si (ind ega 0) ;
             si (idiv ega (3 * na)) ;
                lfrontin = p7n1 droi 1 p7cour ;
                lfrontex = p11n1 droi 1 p11cour ;
                lxi = p7 droi 1 (xp7cour 0 zp7) ;
             sinon ;
               lfrontin = lfrontin droi 1 p7cour ;
               lfrontin = lfrontin coul rouge;
               lfrontex = lfrontex droi 1 p11cour ;
               lfrontex = lfrontex coul rouge;
               lxi = lxi droi 1 (xp7cour 0 zp7) ;
             finsi ;
it = it + 1 ;
tab_fron . it  = p11cour ;
tab_ang . it = tanpsi ;
*
         finsi ;
   finsi ;
*
fin bloc1 ;
*
r1 = l 0 0 ;
r2 = l t 0 ;
r3 = 0 t 0 ;
*
*
 si (ermax > 1.) ;
     saut ligne ;
  mess '-----------------------------------------------------------' ;
  mess 'INCLINAISON MAXIMALE DES TRANCHES PAR RAPPORT A LA NORMALE'  ;
  mess 'DE LA GENERATRICE DU FOND DE FISSURE :' ermax 'DEGRES'       ;
     saut ligne ;
  mess 'POUR DIMINUER L"INCLINAISON : DIMINUER LE PARAMETRE "alpha"' ;
  mess '-----------------------------------------------------------' ;
     saut ligne ;
 sinon ;
     saut ligne ;
  mess '--------------------------------------------------' ;
  mess 'TOUTES LES TRANCHES SONT NORMALES A LA GENERATRICE' ;
  mess '--------------------------------------------------' ;
     saut ligne ;
 finsi ;
*
la_cour = rc0 / nc ;
fac_etir = dis_max / la_cour ;
*
  mess '-----------------------------------------------------------' ;
  mess 'FACTEUR D"ETIREMENT MAXI LE LONG DE LA FISSURE =' fac_etir   ;
  saut ligne ;
  mess '   POUR REDUIRE LE FACTEUR D"ETIREMENT : AUGMENTER "nt"    ' ;
  mess '                                         DIMINUER  "nc"    ' ;
  mess '-----------------------------------------------------------' ;
  saut ligne ;
*
* Epaisseur absolue de la couronne de deraffinement des tranches la
* plus eloignee de la ligne de fond de fissure
* -----------------------------------------------------------------
 si (ndt ega 1) ;
   ep_cd = (rc0 * rc2) ;
 sinon ;
   ep_cd = (rc0 * rc3) ;
 finsi ;
*
* surface superieure interieure a l ellipse
* -----------------------------------------
*
* CMODI BK 30/05/95
*
yp7cour = coor 2 p7cour ;
*
* Repartition 1/3 2/3 dans le plan x=0
*
lyie = p7cour droi 1 (xp7cour (2. * yp7cour / 3.) zp7)
              droi 1 (xp7cour 0 zp7) ;
*
cont = lfrontin et lfronti1 et lyie et (inve lxi) ;
elim cont (c / 1.E4) ;
*
sintsup = lfrontin lyie (inve lxi) lfronti1 dall plan ;
*
*
* surface superieure exterieure a l ellipse
* -----------------------------------------
*
* tri de la ligne lref
*
lref = chan lref poi1 ;
*
i = 0 ;
tab1 = table ;
tab2 = table ;
nbval = nbno lref ;
repeter bouc1 nbval ;
 i = i + 1 ;
 pcour_c = lref poin i ;
 xp = coor 1 pcour_c ;
 tab1 . i = xp ;
 tab2 . i = pcour_c ;
fin bouc1 ;
tab2 = @FIS_1 tab1 tab2 ;
*
p11n3 = plus r1 r2 / 2;
*
lyee1 = p11n3 d 2 r1 ;
lyee2 = p11n3 d 2 r2;
*
*
   nbel_lxi = nbel lxi ;
*
si (ega d2 'oui') ;
*
* DECOUPAGE RAYONNANT SELON X DE LA FACE Y=t
* ------------------------------------------------
p11n2 = ((coor 1 p11n1) t 0) ;
lxee1 = r2 d 2 p11n2 ;
*
si (nbval ega 9) ;
   lxee2 = r3 d nbel_lxi p11n2 ;
sinon ;
*
   lxee2 = r3 d 1 ((coor 1 (tab2 . 3)) t 0) ;
*
   i = 3 ;
*   repeter bouc1 ((nbval - 1) / 4) ;
   repeter bouc1 ((nbel lfrontex) - 2) ;
   i = i + 2 ;
        lxee2 = lxee2 d 1 ((coor 1 (tab2 . i)) t 0) ;
   fin bouc1 ;
*
   lxee2 = lxee2 d 1 p11n2 ;
*
finsi ;
*
sinon ;
*
* DECOUPAGE REGULIER SELON X DE LA FACE Y=t
* -----------------------------------------------------
   long_el = l / (nbel_lxi + 2) ;
   p11n2 = ((nbel_lxi * long_el) t 0) ;
   lxee1 = r2 d 2 p11n2 ;
   lxee2 = r3 d nbel_lxi p11n2 ;
*
* -----------------------------------------------------
*
finsi ;
*
lp11n2n1 = p11n2 d 2 p11n1 ;
lp11n1n3 = p11n1 d 2 p11n3 ;
*
lxee = (inve lxee1) et lxee2 ;
*
d_r1p11 = moins r1 p11   norm ;
d_r3p11c = moins r3 p11cour  norm ;
*
lxei = r1 d 1 (r1 moin ((2. * d_r1p11 / 3.) 0 0)) d 1 p11 ;
lyei = p11cour d 1 (p11cour plus (0 (d_r3p11c / 3.) 0)) d 1 r3 ;
*
sextsup1 = lxei lfronte1 lp11n1n3 lyee1 dall plan ;
sextsup2 = lp11n2n1 lp11n1n3 lyee2 lxee1 dall plan ;
sextsup3 = lfrontex lyei lxee2 lp11n2n1 dall plan ;
*
sextsup = sextsup1 et sextsup2 et sextsup3 ;
*
* volume interieur a l ellipse
* ----------------------------
*
opti elem cu20 ;
*
si (nsdt ega 2) ;
   vint = sintsup volu tran 1 (0 0 ((nd * rc0) * (sineps - 1))) ;
sinon ;
   vint = sintsup volu tran 2 (0 0 ((nd * rc0) * (sineps - 1))) ;
finsi ;
*
* volume exterieur a l ellipse
* ----------------------------
*
si (nsdt ega 2) ;
   vext = sextsup volu tran 1 (0 0 (-1 * nd * rc0)) ;
sinon ;
   vext = sextsup volu tran 2 (0 0 (-1 * nd * rc0)) ;
finsi ;
*
* volume sous le boudin
* ---------------------
*
   si (ega ndt 1) ;
     vtotcomp = (boudin et mtran2 et vint et vext et linf_b
                 et linf_bex et lff) ;
       elim vtotcomp (c / 1.E4) ;
     vtot = boudin et mtran2 et vint et vext ;
      sinon ;
     vtotcomp = (boudin et mtran2 et mtran3 et vint et vext
                 et linf_b et linf_bex et lff) ;
       elim vtotcomp (c / 1.E4) ;
     vtot = boudin et mtran2 et mtran3 et vint et vext ;
   finsi ;
*
* MODIF BC 30/04/96
* recuperation de la surface inferieure de velim
* avec velim = mtran2 et mtran3 et vint et vext
* pour une elimination des points doubles avec vbas
*
si (ega ndt 1) ;
   velim = mtran2 et vint et vext ;
sinon ;
   velim = mtran2 et mtran3 et vint et vext ;
finsi ;
env_vel = enve velim ;
zcot1 = -1 * nd * rc0 ;
pvelim = env_vel point plan (0. 0. zcot1) (1. 0. zcot1)
         (0. 1. zcot1) (c / 1.E4) ;
selim = env_vel elem appuye strictement pvelim ;
*
* FIN MODIF BC 30/04/96
*
* -----------------------------------------------
* Deplacement des noeuds intermediares du boudin
* -----------------------------------------------
*
si (ega d1 'oui') ;
*
idiv1 = -1 ;
idiv2 = 0 ;
idiv3 = -.5 ;
nc = 1 ;
ndiv4 = nt / 2 ;
* Cas du quart d'ellipse
repeter bouc1 ndiv4 ;
   idiv1 = idiv1 + nc ;
   idiv2 = idiv2 + nc ;
   idiv3 = idiv3 + nc ;
   psi1 = (idiv1 * 180.) / nt ;
   psi2 = (idiv2 * 180.) / nt ;
   psi3 = (idiv3 * 180.) / nt ;
      cospsi1 = cos psi1 ;
      sinpsi1 = sin psi1 ;
      tanpsi1 = sinpsi1 / cospsi1 ;
      tanphi1 = a * tanpsi1 / c ;
      phik1  = atg tanphi1 ;
      phik2  = psi1 ;
      phi1 = (beta * phik2) + ((1 - beta) * phik1) ;
*      phi1    = atg tanphi1 ;
      si (phi1 < 0.) ;
         phi1 = 180. + phi1 ;
      finsi ;
      cosphi1 = cos phi1 ;
      sinphi1 = sin phi1 ;
      tanphi1 = sinphi1 / cosphi1 ;
      talpha = (alpha * (1 - (c / a))) + (c / a) ;
      tanpsi1 = talpha * tanphi1 ;
      psi1 = atg tanpsi1 ;
      cospsi1 = cos psi1 ;
      sinpsi1 = sin psi1 ;
*
   si (ega idiv2 (nt /2)) ;
      phi2 = 90. ;
      cosphi2 = 0. ;
      sinphi2 = 1. ;
   sinon ;
      cospsi2 = cos psi2 ;
      sinpsi2 = sin psi2 ;
      tanpsi2 = sinpsi2 / cospsi2 ;
      tanphi2 = a * tanpsi2 / c ;
      phik1  = atg tanphi2 ;
      phik2  = psi2 ;
      phi2 = (beta * phik2) + ((1 - beta) * phik1) ;
*      phi2    = atg tanphi2 ;
      si (phi2 < 0.) ;
         phi2 = 180. + phi2 ;
      finsi ;
      cosphi2 = cos phi2 ;
      sinphi2 = sin phi2 ;
      tanphi2 = sinphi2 / cosphi2 ;
      talpha = (alpha * (1 - (c / a))) + (c / a) ;
      tanpsi2 = talpha * tanphi2 ;
      psi2 = atg tanpsi2 ;
      cospsi2 = cos psi2 ;
      sinpsi2 = sin psi2 ;
   finsi ;
*
      cospsi3 = cos psi3 ;
      sinpsi3 = sin psi3 ;
      tanpsi3 = sinpsi3 / cospsi3 ;
      tanphi3 = a * tanpsi3 / c ;
      phik1  = atg tanphi3 ;
      phik2  = psi3 ;
      phi3 = (beta * phik2) + ((1 - beta) * phik1) ;
*      phi3    = atg tanphi3 ;
      si (phi3 < 0.) ;
         phi3 = 180. + phi3 ;
      finsi ;
      cosphi3 = cos phi3 ;
      sinphi3 = sin phi3 ;
      tanphi3 = sinphi3 / cosphi3 ;
      talpha = (alpha * (1 - (c / a))) + (c / a) ;
      tanpsi3 = talpha * tanphi3 ;
      psi3 = atg tanpsi3 ;
      cospsi3 = cos psi3 ;
      sinpsi3 = sin psi3 ;
*
*
   xcour1 = c * cosphi1 ;
   ycour1 = a * sinphi1 ;
   zcour1 = 0. ;
   pcour1 = xcour1 ycour1 zcour1 ;
*
   xcour2 = c * cosphi2 ;
   ycour2 = a * sinphi2 ;
   zcour2 = 0. ;
   pcour2 = xcour2 ycour2 zcour2 ;
*
   xcour3 = c * cosphi3 ;
   ycour3 = a * sinphi3 ;
   zcour3 = 0. ;
   pcour3 = xcour3 ycour3 zcour3 ;
*
   pcourmi = plus pcour1 pcour2 / 2 ;
   pcourmiz = pcourmi plus (0 0 1) ;
*
*
   pcourq11 = q1 moins ox ;
   depl pcourq11 tour psi1 o (0. 0. 1.) ;
   depl pcourq11 plus pcour1 ;
*
   pcourq12 = q1 moins ox ;
   depl pcourq12 tour psi2 o (0. 0. 1.) ;
   depl pcourq12 plus pcour2 ;
*
   pcourq1 = plus pcourq11 pcourq12 / 2 ;
*
   hyp = moins pcourmi pcourq1  norm ;
   dx = (coor 1 pcourq1) - (coor 1 pcourmi) ;
   dy = (coor 2 pcourq1) - (coor 2 pcourmi) ;
   sina = (dy / hyp) ;
   cosa = (dx / hyp) ;
*
   vproj = (-1 * sina) cosa 0 ;
   depl pcour3 proj vproj plan pcourmi pcourmiz pcourq1 ;
*
   padep = boudin poin plan pcourmi pcourmiz pcourq1 (c / 1.E4) ;
*
    dvect = moins pcour3 pcourmi  norm ;
    vect = ((dvect * cosa) (dvect * sina) 0) ;
*
   depl padep plus vect ;
*
fin bouc1 ;
*
finsi ;
*
* ===========================================================
*          RECUPERATION DE LA LEVRE DE LA FISSURE
* -----------------------------------------------------------
*
*  Surface interieure dans le plan z=constante
*  --------------------------------------------
*
z_p2 = coor 3 p2 ;
z_p4b = coor 3 p4b ;
dz_p2p4b = z_p2 - z_p4b ;
crit = dz_p2p4b / 10. ;
sineps = (sin eps) ;
*
 si (ega ndt 1) ;
    p7 = p3 ;
    plinf_c = (vint et mtran21) poin plan p7cour p7 (xp7cour 0 zp7)
              crit ;
 sinon ;
    p7 = (c - ((1 + rc1 + rc2 + rc3) * rc0 * coseps)) 0.
         (-1 * (1 + rc1 + rc2 + rc3) * rc0 * sineps) ;
    plinf_c = (vint et mtran21 et mtran31) poin plan p7cour p7
              (xp7cour 0 zp7) crit ;
 finsi ;
*
*
vtot_env = enve vtot ;
*
levreinf = vtot_env elem appuye strictement plinf_c ;
*
levreinf = levreinf et linf_b ;
*
levreinf = levreinf orienter direction (0 0 1) ;
*
si (flag_eps ega 0) ;
   depl levreinf proj (0 0 1) plan (0 0 0) (1 0 0) (0 1 0) ;
finsi ;
*
* =============================================================
*
*  Creation du volume complementaire pour l obtention de la
*  longueur lo
*  ------------------------------------------------------------
*
pslat_i = vtot poin plan r1 r2 (r2 plus (0 0 1)) (c / 1.E4) ;
slat_i = vtot_env elem appuye strictement pslat_i ;
*
si ((lo - l) < 0) ;
  mess '=============================================================' ;
  mess 'ATTENTION !!! La longueur du bloc est trop faible par rapport' ;
  mess '              au grand axe de l"ellipse et/ou aux parametres ' ;
  mess '              rc0,rc1,rc2,rc3                                ' ;
  mess '               --- REDUISEZ CES PARAMETRES ---               ' ;
  mess '=============================================================' ;
finsi ;
*
si (((abs (lo - l)) < (l / 1.E10)) ou (xl ega 0)) ;
   mess '----------------------------------------------- ' ;
   mess 'Pas de prolongation du bloc initial en longueur ' ;
   mess 'Longueur =' l                                     ;
   mess '----------------------------------------------- ' ;
   ind_vlat = 0 ;
   xl = 0 ;
     si (xl ega 0) ;
        si (ndt ega 1) ;
           lo = c + (rc0 * (1 + rc1 + (3. * rc2))) ;
        sinon ;
           lo = c + (rc0 * (1 + rc1 + rc2 + (3. * rc3))) ;
        finsi ;
     finsi ;
sinon ;
   ind_vlat = 1 ;
   vlat_com = slat_i volu tran xl ((lo - l) 0 0) ;
   vtot = vtot et vlat_com ;
finsi ;
*
vtot_env = enve vtot ;
*
*
*  Creation du volume complementaire pour l'obtention de la
*  largeur to
*  --------------------------------------------------------
*
si (ndt ega 1) ;
  nd = 1 + rc1 + rc2 ;
sinon ;
  nd = 1 + rc1 + rc2 + rc3 ;
finsi ;
*
hh = -1 * (nd * rc0) ;
*
si ((rallon ega 1) et (xt neg 0)) ;
*
si (ind_vlat ega 1) ;
*
       r2b = r2 plus ((lo - l) 0 0) ;
       lxee_p = lxee d xl r2b ;
*
sinon ;
        r2b = r2 ;
        lxee_p = lxee ;
finsi ;
*
nbe_l = (nbel lxee) + xl ;
*
   l_r3r2b = r3 d nbe_l r2b ;
*
   l_r3r2b = l_r3r2b plus (0 (to - t) 0) ;
*
si (nsdt ega 2) ;
   s_r3r2b = l_r3r2b tran 1 (0 0 hh) ;
   sar_i = lxee_p tran 1 (0 0 hh) ;
sinon ;
   s_r3r2b = l_r3r2b tran 2 (0 0 hh) ;
   sar_i = lxee_p tran 2 (0 0 hh) ;
finsi ;
*
*
   var_com = volu xt sar_i s_r3r2b ;
*
    vtot = vtot et var_com ; elim vtot (c / 1.E6) ;
*
finsi ;
*
   vtot_env = enve vtot ;
*
si (xt ega 0) ;
   rallon = 0 ;
   to = t ;
   mess '---------------------------------------------- ' ;
   mess 'Pas de prolongation du bloc initial en largeur ' ;
   mess 'Largeur =' t                                     ;
   mess '---------------------------------------------- ' ;
finsi ;
*
*
*  Creation du volume complementaire MI1 pour l obtention de la
*  hauteur ho
*  ------------------------------------------------------------
*
si (((2. * hh) + ho) < 0) ;
  mess '=============================================================' ;
  mess 'ATTENTION !!!  La hauteur du bloc est trop faible par rapport' ;
  mess '               aux parametres rc0,rc1,rc2,rc3                ' ;
  mess '               --- REDUISEZ CES PARAMETRES ---               ' ;
  mess '=============================================================' ;
finsi ;
*
   psi1 = vint poin plan (0 0 hh) (0 1 hh) (1 0 hh) (c / 1.E4) ;
   si1 = (enve vint) elem appuye strictement psi1 ;
*
************ ATTENTION ***************
*   hh < 0
*   ep2 < 0
*   ep3 < 0
**************************************
*
* hh : Altitude du niveau 1
* ---------------------------
*
* ep2 : Altitude du niveau 0
* ---------------------------
*
* ep3 : Altitude du niveau -1
* ---------------------------
*
ral_bloc = 0 ;
*
si ((ho / (-1. * hh)) < 5.) ;
   ep2 = (((-1. * ho) - hh) / 2.) + hh ;
   ep3 = -1. * ho ;
sinon ;
   ral_bloc = 1 ;
   ep2 = 3. * hh ;
   ep3 = 5. * hh ;
finsi ;
*
si ((-1. * ep3) > ho) ;
   ep23 = (ho + hh) / 2. ;
   ep3 = -1. * ho ;
   ep2 = ep3 + ep23 ;
finsi ;
*
si (xh ega 0) ;
   ral_bloc = 0 ;
   ep2 = 3. * hh ;
   ep3 = 5. * hh ;
finsi ;
*
   mi1 = si1 volu tran 1 (0 0 (ep2 - hh)) ;
*
*  Projection de la surface SE1 sur le niveau 0
*  --------------------------------------------
*
se1 = sextsup plus (0 0 hh) ;
*
****************************************
*
*  Creation de la surface SE0 par transformation geometrique
*  ---------------------------------------------------------
*
si (nsdt ega 2) ;
   i1 = sommet71 ;
   e1 = sommet14 ;
   p_i1 = changer i1 poi1 ;
   p_e1 = changer e1 poi1 ;
sinon ;
   i1 = sommet72 ;
   e1 = sommet17 ;
   p_i1 = changer i1 poi1 ;
   p_e1 = changer e1 poi1 ;
finsi ;
*
se01 = sextsup1 plus (0 0 ep2) ;
se02 = sextsup2 plus (0 0 ep2) ;
se03 = sextsup3 plus (0 0 ep2) ;
se0 = se01 et se02 et se03 ;
elim se0 crit ;
*
e0 = e1 plus (0 0 (ep2 - hh)) ;
elim se0 e0 crit ;
p_e0 = changer e0 poi1 ;
*
numnod = nbno p_e0 ;
inod = 0 ;
*
* deplacement des points du bord e0
*
repe bouc1 numnod ;
     inod = inod + 1 ;
     dep = (p_i1 poin inod) moins (p_e1 poin inod) ;
     dx = coor 1 dep ;
     dy = coor 2 dep ;
     depl (p_e0 poin inod) plus (dx dy 0.) ;
fin bouc1 ;
*
* definition des points limites du contour
*
p_se0 = se0 chan poi1 ;
con_se0 = 'CONT' se0 ;
p_lx = con_se0 poin plan (l 0 0) (l 1 0) (l 0 1) crit ;
lx = con_se0 elem appui stric p_lx ;
p_ly = con_se0 poin plan (0 t 0) (1 t 0) (0 t 1) crit ;
ly = con_se0 elem appui stric p_ly ;
p_lx0 = con_se0 poin plan (0 0 0) (0 1 0) (0 0 1) crit ;
lx0 = con_se0 elem appui stric p_lx0 ;
p_ly0 = con_se0 poin plan (0 0 0) (1 0 0) (0 0 1) crit ;
ly0 = con_se0 elem appui stric p_ly0 ;
*
ppp1 = p_e0 poin 1 ;
ppp2 = p_e0 poin (nbno p_e0) ;
ppp1 = e0 poin plan (0 0 0) (1 0 0) (0 0 1) crit ;
ppp2 = e0 poin plan (0 0 0) (0 1 0) (0 0 1) crit ;
p_lx0_2 = p_lx0 diff ppp2 ;
p_ly0_1 = p_ly0 diff ppp1 ;
*
* definition des points "interieurs"
*
lxy = lx et ly et lx0 et ly0 et e0 ;
p_lxy = lxy chan poi1 ;
p_inter = p_se0 diff p_lxy ;
*
* definitions des points definissant les transformations
*
p_pro_y = (0. t 0. ) ;
p_y = p_pro_y plus (l 0. 0.) ;
*
* p_e1t et p_i1t sont les images de p_e1 et p_i1 par
* l'affinite transformant la "presque ellipse" e0 en " presque cercle".
*
p_e1t = p_e1 plus (0. 0. 0.) ;
p_i1t = p_i1 plus (0. 0. 0.) ;
depl p_e1t affi (a/c) p_pro_y p_y ;
depl p_i1t affi (a/c) p_pro_y p_y ;
*
* calcul des distances des points de p_e1t et p_i1t au centre
*
numnod = nbno p_e1t ;
inod = 0 ;
rayone1 = table ;
rayoni1 = table ;
repe bouc2 numnod ;
     inod = inod + 1 ;
     xe1 ye1 ze1 = coord (p_e1t poin inod) ;
     xi1 yi1 zi1 = coord (p_i1t poin inod) ;
     rayone1 . inod = (((xe1**2)+(ye1**2))**0.5) ;
     rayoni1 . inod = (((xi1**2)+(yi1**2))**0.5) ;
fin bouc2 ;
*
* calcul des rayons pour les points x = 0 et y = 0
*
inod = numnod ;
     xe1 ye1 ze1 = coord (p_e1t poin inod) ;
     xi1 yi1 zi1 = coord (p_i1t poin inod) ;
     re1x = (((xe1**2)+(ye1**2))**0.5) ;
     ri1x = (((xi1**2)+(yi1**2))**0.5) ;
inod = 1 ;
     xe1 ye1 ze1 = coord (p_e1t poin inod) ;
     xi1 yi1 zi1 = coord (p_i1t poin inod) ;
     re1y = (((xe1**2)+(ye1**2))**0.5) ;
     ri1y = (((xi1**2)+(yi1**2))**0.5) ;
*
lasc = l * a / c ;
*
*
* Calcul des angles a l'origine des points de p_e1t et p_i1t
*
angle1 = table ;
angli1 = table ;
numray = nbno p_e1t ;
inod = 0 ;
repe bouc7 numray ;
   inod = inod + 1 ;
   angle1 . inod = ((p_e1t poin inod) coor 2)
                 / ((p_e1t poin inod) coor 1) ;
   angli1 . inod = ((p_i1t poin inod) coor 2)
                 / ((p_i1t poin inod) coor 1) ;
fin bouc7 ;
*
* deplacement des points "interieurs"
* -----------------------------------
* affinite transformant la "presque ellipse" e0 en " presque cercle".
*
depl p_inter affi (a/c) p_pro_y p_y ;
*
* homothetie de centre (0 0 0) et de rapport dpsd. le rapport depend
* du point courant et est calcule en fonction des rayons des points
* de p_e1t et p_i1t, qui juxtaposent la projection du point courant
* sur ces memes contours
*
numnod = nbno p_inter ;
inod = 0 ;
repe bouc3 numnod ;
     inod = inod + 1 ;
     p = p_inter poin inod ;
     x y z = coor p ;
     r = ((x**2) + (y**2))**0.5 ;
     dmax1 = r*lasc/x ;
     dmax2 = r*t/y ;
     dmax = dmax1 ;
     si (dmax2 < dmax1) ; dmax = dmax2 ; finsi ;
     re1 = (((x/r*re1y)**2) + ((y/r*re1x)**2))**0.5 ;
     ri1 = (((x/r*ri1y)**2) + ((y/r*ri1x)**2))**0.5 ;
* calcul des rayons secants
     iray = 0 ;
     anglc = y / x ;
     ke1 = 0 ;
     ki1 = 0 ;
     repe bouc77 numray ;
        iray = iray + 1 ;
        si ( ega ke1 0 ) ;
        si ( anglc < angle1 . iray ); ie1 = iray ; ke1 = 1 ; finsi ;
        finsi ;
        si ( ega ki1 0 ) ;
        si ( anglc < angli1 . iray ); ii1 = iray ; ki1 = 1 ; finsi ;
        finsi ;
     fin bouc77 ;
     re1 = (rayone1 . ie1 + rayone1 . (ie1 - 1) ) / 2. ;
     ri1 = (rayoni1 . ii1 + rayoni1 . (ii1 - 1) ) / 2. ;
* fin de calcul des rayons secants
     dpsd = ((dmax-ri1) + (dmax/r*(ri1-re1)))/(dmax-re1) ;
* ccoo est un coefficient qui limite le deplacement des points en x
* ccoo est compris entre 0 et 1, et depend de la distance a l'axe Oy
     ccoo = (x/lasc)**2.0 ;
     dx = (x * dpsd - x)*ccoo ;
     dy = y * dpsd - y ;
     depl p plus (dx dy 0.) ;
fin bouc3 ;
*
* affinite inverse de la premiere, appliquee aux points interieurs
*
depl p_inter affi (c/a) p_pro_y p_y ;
*
* deplacement des points de lx0.
* ------------------------------
* homothetie de centre (0 0 0) et de rapport dpsd.
*
numnod = nbno p_lx0_2 ;
inod = 0 ;
repe bouc4 numnod ;
     inod = inod + 1 ;
     p = p_lx0_2 poin inod ;
     y = coor 2 p ;
     dpsd = ((t-ri1x) + (t/y*(ri1x-re1x)))/(t-re1x) ;
     dy = y * dpsd - y ;
     depl p plus (0. dy 0.) ;
fin bouc4 ;
*
* deplacement des points de ly0.
* ------------------------------
* affinite transformant la "presque ellipse" e0 en " presque cercle".
*
depl p_ly0_1 affi (a/c) p_pro_y p_y ;
*
* homothetie de centre (0 0 0) et de rapport dpsd.
*
numnod = nbno p_ly0_1 ;
inod = 0 ;
repe bouc5 numnod ;
     inod = inod + 1 ;
     p = p_ly0_1 poin inod ;
     x = coor 1 p ;
     dpsd = ((lasc-ri1y) + (lasc/x*(ri1y-re1y)))/(lasc-re1y) ;
* ccoo est un coefficient qui limite le deplacement des points en x
* ccoo est compris entre 0 et 1, et depend de la distance a l'axe Oy
     ccoo = (x/lasc)**2.0 ;
     dx = (x * dpsd - x)*ccoo ;
     depl p plus (dx 0. 0.) ;
fin bouc5 ;
*
* affinite inverse de la premiere.
*
depl p_ly0_1 affi (c/a) p_pro_y p_y ;
*
* rectification des cotes courbes de la surface se0
* -------------------------------------------------
numel = nbel se0 ;
iel = 0 ;
repeter bloc1 numel ;
   iel = iel + 1 ;
   elcour = se0 elem iel ;
   pcour = changer elcour poi1 ;
   pt1 = pcour poin 1 ;
   x1 = pt1 coor 1 ;
   y1 = pt1 coor 2 ;
   pt2 = pcour poin 2 ;
   x2 = pt2 coor 1 ;
   y2 = pt2 coor 2 ;
   pt3 = pcour poin 3 ;
   x3 = pt3 coor 1 ;
   y3 = pt3 coor 2 ;
   pt4 = pcour poin 4 ;
   x4 = pt4 coor 1 ;
   y4 = pt4 coor 2 ;
   pt5 = pcour poin 5 ;
   x5 = pt5 coor 1 ;
   y5 = pt5 coor 2 ;
   pt6 = pcour poin 6 ;
   x6 = pt6 coor 1 ;
   y6 = pt6 coor 2 ;
   pt7 = pcour poin 7 ;
   x7 = pt7 coor 1 ;
   y7 = pt7 coor 2 ;
   pt8 = pcour poin 8 ;
   x8 = pt8 coor 1 ;
   y8 = pt8 coor 2 ;
   dx2 = (0.5 * (x1 + x3) ) - x2 ;
   dy2 = (0.5 * (y1 + y3) ) - y2 ;
   depl pt2 plus (dx2 dy2 0) ;
   dx4 = (0.5 * (x3 + x5) ) - x4 ;
   dy4 = (0.5 * (y3 + y5) ) - y4 ;
   depl pt4 plus (dx4 dy4 0) ;
   dx6 = (0.5 * (x5 + x7) ) - x6 ;
   dy6 = (0.5 * (y5 + y7) ) - y6 ;
   depl pt6 plus (dx6 dy6 0) ;
   dx8 = (0.5 * (x7 + x1) ) - x8 ;
   dy8 = (0.5 * (y7 + y1) ) - y8 ;
   depl pt8 plus (dx8 dy8 0) ;
fin bloc1 ;
*
se0 = se0 coul blan ;
se1 = se1 coul vert ;
*
*
*  Creation du volume ME1
*  ----------------------
*
me1 = volu 1 se1 se0 ;
***********
*
* Creation de la surface elliptique du volume ME1
* -----------------------------------------------
*
lextsup = lfrontex et lfronte1 ;
lextsup = lextsup plus (0 0 hh) ;
*
* tri de la ligne e0 pour sa creation en seg3
*
e0 = chan e0 poi1 ;
*
i = 0 ;
tab1 = table ;
tab2 = table ;
nbval = nbno e0 ;
repeter bouc5 nbval ;
 i = i + 1 ;
 pcour_c = e0 poin i ;
 xp = coor 1 pcour_c ;
 tab1 . i = xp ;
 tab2 . i = pcour_c ;
fin bouc5 ;
tab2 = @FIS_1 tab1 tab2 ;
*
nel = (nbval / 2 ) ;
*
i = -1 ;
repe bouc1 nel ;
i = i + 2 ;
si (i ega 1) ;
le0 = manu seg3 (tab2 . i) (tab2 . (i + 1))
                (tab2 . (i + 2)) ;
sinon ;
l2 = manu seg3 (tab2 . i) (tab2 . (i + 1))
               (tab2 . (i + 2)) ;
le0 = le0 et l2 ;
finsi ;
*
fin bouc1 ;
*
le0 = inve le0 ;
spe = lextsup regler 1 le0 ;
*
* Creation de la surface elliptique du volume MI1
* -----------------------------------------------
*
lsup = (lfrontin et lfronti1) plus (0 0 hh) ;
linf = (lfrontin et lfronti1) plus (0 0 ep2) ;
*
spi = lsup regler 1 linf ;
*
* Creation du volume de la zone prismatique
* -----------------------------------------
*
si (nsdt ega 2) ;
   volpri = volu 2 spe spi ;
sinon ;
   volpri = volu 4 spe spi ;
finsi ;
*
elim volpri (c / 1.E3) ;
volpri = rege volpri ;
*
si (ndt ega 1) ;
   elim mtran2 volpri (c / 1.E3) ;
sinon ;
   elim mtran3 volpri (c / 1.E3) ;
finsi ;
*
elim volpri mi1 (c / 1.E3) ;
*
vtot = vtot et me1 et mi1 et volpri ;
elim vtot (c / 1.E4) ;
*
*
* ======================================================
* Creation des maillages grilles reguliers
* ----------------------------------------
*
si0 = sintsup plus (0 0 ep2) ;
*
* Nombre d'elements sur la droite y=0
nbel_fro = nbel lfrontin ;
nbel_lxe = nbel lxei ;
nbely0 = nbel_fro + nbel_lxe ;
*
l_elem = l / nbely0 ;
*
p1_n2 = 0 0 0 ;
p2_n2 = (l_elem * nbel_fro) 0 0 ;
p3_n2 = (coor 1 p2_n2) (coor 2 p11n3) 0 ;
p4_n2 = 0 (coor 2 p11n3) 0 ;
p5_n2 = (coor 1 p2_n2) t 0 ;
*
l1_n2 = p3_n2 d nbel_fro p4_n2 ;
l2_n2 = p4_n2 d 2 p1_n2 ;
l3_n2 = p1_n2 d nbel_fro p2_n2 ;
l4_n2 = p2_n2 d 2 p3_n2 ;
*
l5_n2 = r1 d 2 p2_n2 ;
l6_n2 = p11n3 d 2 r1 ;
l7_n2 = p3_n2 d 2 p11n3 ;
l8_n2 = p11n3 d 2 r2 ;
l9_n2 = lxee1 ;
*l9_n2 = r2 d 2 p5_n2 ;
*l10_n2 = p5_n2 d 2 p3_n2 ;
l10_n2 = p11n2 d 2 p3_n2 ;
l11_n2 = lxee2 ;
*l11_n2 = r3 d nbel_fro p5_n2 ;
l12_n2 = p4_n2 d 2 r3 ;
*
si2_r = l1_n2 l2_n2 l3_n2 l4_n2 dall plan ;
*
se21_r = l5_n2 l4_n2 l7_n2 l6_n2 dall plan ;
se22_r = l10_n2 l7_n2 l8_n2 l9_n2 dall plan ;
se23_r = l1_n2 l12_n2 l11_n2 l10_n2 dall plan ;
*
si0_inf = si2_r plus (0 0 ep3) ;
*
se01_inf = se21_r plus (0 0 ep3) ;
se02_inf = se22_r plus (0 0 ep3) ;
se03_inf = se23_r plus (0 0 ep3) ;
*
vi_inf = volu 1 si0_inf si0 ;
ve1_inf = volu 1 se01_inf se01 ;
ve2_inf = volu 1 se02_inf se02 ;
ve3_inf = volu 1 se03_inf se03 ;
*
v_inf = vi_inf et ve1_inf et ve2_inf et ve3_inf ;
*
vbas = v_inf et mi1 et me1 et volpri ;
elim vbas (c / 1.E3) ;
*
vtot = vtot et v_inf ;
*
vtot_env = enve vtot ;
*
* MODIF BC 30/04/96
* elimination des points doubles avec le bloc superieur
* dont on a extrait la surface selim
*
*mess 'debut cmodif bc 30/04/96 ';
celim = c / 1.E2 ;
si ( celim >EG (rc0/10.) ) ;
celim = rc0 / 10. ;
*mess 'celim = rc0 / 10.  celim = ' celim ;
finsi ;

elim ( vbas et selim ) celim ;
vtot = rege vtot ;
*vtot_env = enve vtot ;
*trac oeil vtot_env   ;
*vbas_env = enve vbas ;
*trac oeil vbas_env   ;
*mess 'fin cmodif bc 30/04/96 ';

*FIN MODIF BC 30/04/96
*
*  Creation du volume complementaire inferieur du bloc initial
*  pour obtenir h
*  -----------------------------------------------------------
*
si (ral_bloc ega 1) ;
*
p_se_inf = vtot poin plan (0 0 ep3) (0 1 ep3)
                          (1 0 ep3) (c / 1.E4) ;
*
se_inf = vtot_env elem appuye strictement p_se_inf ;
se_inf = se_inf orienter direction (0 0 -1) ;
*
* nelh = nombre d'elements dans la hauteur du volume
nelh = xh ;
*
vral_blo = se_inf volu tran nelh (0 0 (-1. * (ho + ep3))) ;
*
vtot = vtot et vral_blo ;
*
*
finsi ;
*
*
* Creation du volume complementaire inferieur en dehors du
* bloc initial pour obtenir h
* --------------------------------------------------------
*
ral_tl = 0 ;
*
si ((rallon ega 1) et (xt neg 0)) ;
*
   si (ind_vlat ega 1) ;
      p_hor_in = (var_com et vlat_com) poin plan
                                       (0 0 hh) (0 1 hh)
                                       (1 0 hh) (c / 1.E4) ;
      enve_com = enve (var_com et vlat_com) ;
*
ral_tl = 1 ;
*
   sinon ;
*
         p_hor_in = var_com poin plan
                            (0 0 hh) (0 1 hh)
                            (1 0 hh) (c / 1.E4) ;
      enve_com = enve var_com ;
   finsi ;
*
hor_inf = enve_com elem appuye
          strictement p_hor_in ;
hor_inf = hor_inf orienter direction (0 0 -1) ;
*
   vral_hor = hor_inf volu tran 1 (0 0 (ep2 - hh))
                      volu tran 1 (0 0 (ep3 - ep2)) ;
*
  si (ral_bloc ega 1) ;
    vral_hor = vral_hor volu tran xh (0 0 (-1. * (ho + ep3))) ;
  finsi ;
*
vtot = vtot et vral_hor ;
elim vtot (c / 1.E6) ;
*
finsi ;
*
si (ral_tl ega 0) ;
*
si (ind_vlat ega 1) ;
*
   si ((rallon ega 1) et (xt neg 0)) ;
      p_hor_in = (var_com et vlat_com) poin plan
                            (0 0 hh) (0 1 hh)
                            (1 0 hh) (c / 1.E4) ;
      enve_com = enve (var_com et vlat_com) ;
   sinon ;
            p_hor_in = vlat_com poin plan
                                (0 0 hh) (0 1 hh)
                                (1 0 hh) (c / 1.E4) ;
      enve_com = enve vlat_com ;
   finsi ;
hor_inf = enve_com elem appuye
          strictement p_hor_in ;
hor_inf = hor_inf orienter direction (0 0 -1) ;
*
   vral_hor = hor_inf volu tran 1 (0 0 (ep2 - hh))
                      volu tran 1 (0 0 (ep3 - ep2)) ;
*
  si (ral_bloc ega 1) ;
    vral_hor = vral_hor volu tran xh (0 0 (-1. * (ho + ep3))) ;
  finsi ;
*
vtot = vtot et vral_hor ;
elim vtot (c / 1.E6) ;
*
finsi ;
*
finsi ;
*
vtot_env = enve vtot ;
*
* recuperation des surfaces (sinf , sar , slat)
* ---------------------------------------------
*
pslat = vtot poin plan (lo 0 0) (lo 1 0) (lo 0 1) (c / 1.E4) ;
slat = vtot_env elem appuye strictement pslat ;
slat = slat orienter direction (1 0 0) ;
*
*
psar = vtot poin plan (0 to 0) (1 to 0) (0 to 1) (c / 1.E4) ;
sar = vtot_env elem appuye strictement psar ;
sar = sar orienter direction (0 1 0) ;
*
* CMODI BK 16/8/95
* Rajout du test (ral_bloc ega 0)
*
si (ral_bloc ega 0) ;
psinf = vtot poin plan (0 0 ep3) (0 1 ep3)
                       (1 0 ep3) (c / 1.E4) ;
*
sinon ;
psinf = vtot poin plan (0 0 (-1 * ho)) (0 1 (-1 * ho))
                       (1 0 (-1 * ho)) (c / 1.E4) ;
*
finsi ;
*
sinf = vtot_env elem appuye strictement psinf ;
sinf = sinf orienter direction (0 0 -1) ;
*
* recuperation des surfaces (ssup_s , sav_s , slat_s)
* ---------------------------------------------------
*
pslat_s = vtot poin plan (0 0 0) (0 1 0) (0 0 1) (c / 1.E4) ;
slat_s = vtot_env elem appuye strictement pslat_s ;
slat_s = slat_s orienter direction (-1000. 0. 0.) ;
*
psav_s = vtot poin plan (0 0 0) (1 0 0) (0 0 1) (c / 1.E4) ;
sav_s = vtot_env elem appuye strictement psav_s ;
*
*
sav_s = sav_s orienter direction (0 -1 0) ;
*
si ((rallon ega 1) et (ind_vlat ega 1)) ;
 si (ega ndt 1) ;
    si (ega nsdt 2) ;
    pssup_s = (vext et mtran24 et var_com et vlat_com) poin plan
              (0 0 0) (1 0 0) (0 1 0) (c / 1.E4) ;
    sinon ;
    pssup_s = (vext et mtran28 et var_com et vlat_com) poin plan
              (0 0 0) (1 0 0) (0 1 0) (c / 1.E4) ;
    finsi ;
 sinon ;
*
    si (ega nsdt 2) ;
    pssup_s = (vext et mtran24 et mtran34 et var_com et vlat_com)
              poin plan (0 0 0) (1 0 0) (0 1 0) (c / 1.E4) ;
    sinon ;
    pssup_s = (vext et mtran28 et mtran38 et var_com et vlat_com)
              poin plan (0 0 0) (1 0 0) (0 1 0) (c / 1.E4) ;
    finsi ;
 finsi ;
finsi ;
*
si ((rallon ega 0) et (ind_vlat ega 0)) ;
 si (ega ndt 1) ;
    si (ega nsdt 2) ;
    pssup_s = (vext et mtran24) poin plan
              (0 0 0) (1 0 0) (0 1 0) (c / 1.E4) ;
    sinon ;
    pssup_s = (vext et mtran28) poin plan
              (0 0 0) (1 0 0) (0 1 0) (c / 1.E4) ;
    finsi ;
 sinon ;
    si (ega nsdt 2) ;
    pssup_s = (vext et mtran24 et mtran34 )
              poin plan (0 0 0) (1 0 0) (0 1 0) (c / 1.E4) ;
    sinon ;
    pssup_s = (vext et mtran28 et mtran38 )
              poin plan (0 0 0) (1 0 0) (0 1 0) (c / 1.E4) ;
    finsi ;
 finsi ;
finsi ;
*
si ((rallon ega 1) et (ind_vlat ega 0)) ;
 si (ega ndt 1) ;
    si (ega nsdt 2) ;
    pssup_s = (vext et mtran24 et var_com ) poin plan
              (0 0 0) (1 0 0) (0 1 0) (c / 1.E4) ;
    sinon ;
    pssup_s = (vext et mtran28 et var_com ) poin plan
              (0 0 0) (1 0 0) (0 1 0) (c / 1.E4) ;
    finsi ;
 sinon ;
    si (ega nsdt 2) ;
    pssup_s = (vext et mtran24 et mtran34 et var_com )
              poin plan (0 0 0) (1 0 0) (0 1 0) (c / 1.E4) ;
    sinon ;
    pssup_s = (vext et mtran28 et mtran38 et var_com )
              poin plan (0 0 0) (1 0 0) (0 1 0) (c / 1.E4) ;
    finsi ;
 finsi ;
finsi ;
*
si ((rallon ega 0) et (ind_vlat ega 1)) ;
 si (ega ndt 1) ;
    si (ega nsdt 2) ;
    pssup_s = (vext et mtran24 et vlat_com ) poin plan
              (0 0 0) (1 0 0) (0 1 0) (c / 1.E4) ;
    sinon ;
    pssup_s = (vext et mtran28 et vlat_com ) poin plan
              (0 0 0) (1 0 0) (0 1 0) (c / 1.E4) ;
    finsi ;
 sinon ;
    si (ega nsdt 2) ;
    pssup_s = (vext et mtran24 et mtran34 et vlat_com )
              poin plan (0 0 0) (1 0 0) (0 1 0) (c / 1.E4) ;
    sinon ;
    pssup_s = (vext et mtran28 et mtran38 et vlat_com )
              poin plan (0 0 0) (1 0 0) (0 1 0) (c / 1.E4) ;
    finsi ;
 finsi ;
finsi ;
*
*
ssup_s = vtot_env elem appuye strictement pssup_s ;
*
ssup_s = ssup_s et linf_bex ;
ssup_s = ssup_s orienter direction (0 0 1) ;
*
*sort vtot ;
*sauv 'FORMATTE' vtot;
*
finproc vtot lff levreinf sar slat sinf sav_s ssup_s
        slat_s boudin ep3 ;



