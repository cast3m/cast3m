$$$$ FRCTRACE        
* FRCTRACE  PROCEDUR  AF221230  18/04/20    21:15:01     9814
DEBPROC FRCTRACE TAB1*'TABLE' TOL1*'FLOTTANT';
*
* --------------------------------------------------------
*  Procedure FRCTRACE
*  Imprimer les surface de capacité et/ou les enveloppes
*  des efforts statiques + sismiques pour les elements frame 
*  (TIMO et  POUT)
*
*  Developpers:
*    Alberto FRAU
*    DEN/DANS/DM2S/SEMT/EMSI
*    Nicolas ILE
*    DEN/DANS/DM2S/SEMT/EMSI
*    Giulia DI STEFANO
*
*
*  TAB2 = FRCTRACE TAB1;
*
*
*  INPUT:
*
*    En entrée on utilise une table TAB1. Un indice de la table TAB1
*    indique si la definition de la surface limite doit etre faite pour 
*    la couche externe,interne ou intermediaire:
*                 TAB1.'TYPE_COUCHE'   MOT pour indiquer le type de 
*                                      couche 
*                                         'POTEAU'  pouteau
*                                         'POUTRE'  poutre
*                 TAB1.'ENROBAGE'   enrobage en m [FLOTTANT]
*                 TAB1.'S_CADRE'    espacement des cadres en 
*                                                    m  [FLOTTANT]
*                 TAB1.'LONGEUR_Y'  longuer ly [FLOTTANT]
*                 TAB1.'LONGEUR_Z'  longeur lz [FLOTTANT]
*                 TAB1.'FCK'        resistance caracteristique 
*                                                      beton [FLOTTANT]
*                 TAB1.'FSK'        resistance caracteristique 
*                                                      acier [FLOTTANT]
*                 TAB1.'PHI_LON'    LISTREEL des barres d'acier en mm
*                 TAB1.'PHI_Y'      LISTREEL de la position y en m de 
*                                   chaque barre par rapport au 
*                                   baricentre de la section
*                 TAB1.'PHI_Z'      LISTREEL de la position z en m de 
*                                   chaque barre par rapport au 
*                                   baricentre de la section 
*                 TAB1.'ASWL_Y'     aire de l'armature transversale 
*                                   direction y
*                 TAB1.'ASWL_Z'     aire de l'armature transversale 
*                                   direction z
*                 TAB1.'GAMMA_C'    coef gamma_c [FLOTTANT]
*                 TAB1.'ALPA_C'     coef alpha_c [FLOTTANT]
*                 TAB1.'GAMMA_S'    coef gamma_s [FLOTTANT]  
*                 TAB1.'EPSI_BET'   deformation ultime beton [FLOTTANT]
*                 TAB1.'EPSI_ACI'   deformation ultime acier [FLOTTANT]
*                 TAB1.'YOUNG_ACIER' Module Young acier [FLOTTANT]
*                 TAB1.'EFFORT_SEISME'   effort seisme - matrice 
*                                        caracteristique (optionelle)
*                                        [MCHML]
*                 TAB1.'EFFORT_STATIQUE' effort statique (optionelle)
*                                        [MCHML]


*
*                 TAB1.'NX'   nombre de subdivisions dans le domaine N
*                 TAB1.'NY'   nombre de subdivisions dans la 
*                                                   direction polaire
*                 TAB1.'BY'   dimensions section direction Y
*                 TAB1.'BZ'   dimensions section direction Z



*                 TAB1.'FCK'  resistance caracteristique beton
*                 TAB1.'FSK'  resistance caracteristique acier 
*                 TAB1.'YOUNG_ACIER' Module Young acier
*                 TAB1.'PHI_LON'  Liste des barres longitudinales
*                 TAB1.'PHI_Y'    Liste position y 
*                                 des barres longitudinales
*                 TAB1.'PHI_Z'    Liste position z 
*                                 des barres longitudinales
*                 TAB1.'ASWL'     Section des aciers transversales
*                 TAB1.'GAMMA_C'    coefficient gamma_c
*                 TAB1.'ALPA_C'     coefficient alpha
*                 TAB1.'GAMMA_S'    coefficient gamma_s
*                 TAB1.'EFFORT_STATIQUE'  effort statique (optionelle)
*                 TAB1.'EFFORT_SEISME'    matrice caracteristique 
*                                                  seisme (optionelle)
*
*  OUTPUT:
*
*
*                  TT1:          table d'output
*                  TT1.'LIMITE'  Surface limite 
*                  TT1.'ELLIPSOIDE'  Enveloppe ellipsoide 
*                                      (si present dans la 
*                                      TAB1 les MCHML des efforts)
*                  TT1.'RECTANGLE'   Enveloppe rectangulaire
*                                      (si present dans la 
*                                      TAB1 les MCHML des efforts)
*
*
*                   
* --------------------------------------------------------
*
'SI' ('EXIST' TAB1 'TYPE_COUCHE');
  TPY1 = TAB1.'TYPE_COUCHE';
  'SI' ('NEG' ('TYPE' TPY1) 'MOT');
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
'SINON';
  'MESS' 'Input Error ...';
  'QUIT' FRCTRACE;
'FINSI';
*
*
* ------- Cas Poteau ---------------------------
'SI' (('EGA' TPY1 'POTEAU'));
* controle
  'SI' ('EXIST' TAB1 'NX');
    NX1 = TAB1.'NX';
    'SI' ('NEG' ('TYPE' NX1) 'ENTIER');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'NY');
    NY1 = TAB1.'NY';
    'SI' ('NEG' ('TYPE' NY1) 'ENTIER');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'FCK');
    FC1 = TAB1.'FCK';
    'SI' ('NEG' ('TYPE' FC1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' MRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' MRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'FSK');
    FS1 = TAB1.'FSK';
    'SI' ('NEG' ('TYPE' FS1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'GAMMA_C');
    GAMC = TAB1.'GAMMA_C';
    'SI' ('NEG' ('TYPE' GAMC) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'ALPA_C');
    ALP1 = TAB1.'ALPA_C';
    'SI' ('NEG' ('TYPE' ALP1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'GAMMA_S');
    GAMS = TAB1.'GAMMA_S';
    'SI' ('NEG' ('TYPE' GAMS) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'GAMMA_S');
    GAMS = TAB1.'GAMMA_S';
    'SI' ('NEG' ('TYPE' GAMS) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'PHI_LON');
    PHI1 = TAB1.'PHI_LON';
    'SI' ('NEG' ('TYPE' PHI1) 'LISTREEL');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'PHI_Y');
    PHIY1 = TAB1.'PHI_Y';
    'SI' ('NEG' ('TYPE' PHIY1) 'LISTREEL');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'PHI_Z');
    PHIZ1 = TAB1.'PHI_Z';
    'SI' ('NEG' ('TYPE' PHIZ1) 'LISTREEL');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'ASWL_Y');
    ASWLY1 = TAB1.'ASWL_Y';
    'SI' ('NEG' ('TYPE' ASWLY1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'ASWL_Z');
    ASWLZ1 = TAB1.'ASWL_Z';
    'SI' ('NEG' ('TYPE' ASWLZ1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'BY');
    BY1 = TAB1.'BY';
    'SI' ('NEG' ('TYPE' BY1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'BZ');
    BZ1 = TAB1.'BZ';
    'SI' ('NEG' ('TYPE' BZ1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'ENROBAGE');
    ENR1 = TAB1.'ENROBAGE';
    'SI' ('NEG' ('TYPE' ENR1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'S_CADRE');
    SS1 = TAB1.'S_CADRE';
    'SI' ('NEG' ('TYPE' SS1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'LONGEUR_Y');
    LLY1 = TAB1.'LONGEUR_Y';
    'SI' ('NEG' ('TYPE' LLY1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'LONGEUR_Z');
    LLZ1 = TAB1.'LONGEUR_Z';
    'SI' ('NEG' ('TYPE' LLZ1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'YOUNG_ACIER');
    E_YACI1 = TAB1.'YOUNG_ACIER';
    'SI' ('NEG' ('TYPE' E_YACI1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'EPSI_BET');
    EPS_BET1 = TAB1.'EPSI_BET';
    'SI' ('NEG' ('TYPE' EPS_BET1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'EPSI_ACI');
    EPS_ACI1 = TAB1.'EPSI_ACI';
    'SI' ('NEG' ('TYPE' EPS_ACI1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
*
*
* Normalisation
  CC1 = 'ENTI'(FC1/100000);
*  CC1 = 0;
  'SI' (CC1 '>' 1);
    FC1 = FC1/1000;
    FS1 = FS1/1000;
    E_YACI1 = E_YACI1/1000;
  'FINSI';
*
* Calcul resistance Fcd et Fsd
  FCD = ((FC1)*(ALP1))/(GAMC);
  FSD = ((FS1))/(GAMS);
*
* Armature total longitudinale
  ASTT1 = 0.0;
  NN1 = 'DIME' PHI1;
  I = 1;
  'REPE' IND1 (NN1);
    ASTT1 = ASTT1 + ((((('EXTR' PHI1 I)/(1000))**(2.0))/(4.0))*(PI));
    I = I + 1;
  'FIN' IND1;
*
* calculs des parametres wsy wsz wwy wwz lz ly et xi
  ZZ_Y1 = BY1 - ((2.0)*(ENR1));
  ZZ_Z1 = BZ1 - ((2.0)*(ENR1));
  WSY1 = ((ASTT1)*(FSD))/(((BY1)*(BZ1))*(FCD));
  WSZ1 = ((ASTT1)*(FSD))/(((BY1)*(BZ1))*(FCD));
  WWY1 = ((ASWLY1)*(FSD))/(((BZ1)*(SS1))*(FCD));
  WWZ1 = ((ASWLZ1)*(FSD))/(((BY1)*(SS1))*(FCD));
  LY1 = (LLZ1)/(BY1);
  LZ1 = (LLY1)/(BZ1);
  XIY1 = (ZZ_Y1)/(BY1);
  XIZ1 = (ZZ_Z1)/(BZ1);
*
* test court ou long
  TEST_Y = (LY1 < (WSY1/WWY1));
  TEST_Z = (LZ1 < (WSZ1/WWZ1));
*
  'SI' (TEST_Y 'ET' TEST_Z);
*   -------------      Poteau Court  ---------------------------------
*    ((FCD)*((BZ1)*(BY1)))
    NN_LC1 = ((-1.0)*(((WSY1)*(1.0)*((FCD)*((BZ1)*(BY1))))  +   
              ((FCD)*((BZ1)*(BY1)))));
    NN_LT1 = ((1.0)*(((WSY1)*(1.0)*((FCD)*((BZ1)*(BY1))))));
    NN_LC1 = NN_LC1 - ((NN_LC1)*(1.E-4));
    NN_LT1 = NN_LT1 - ((NN_LT1)*(1.E-4));
*   nombre des pas pour les efforts N
    PAS1 = ((NN_LT1 - NN_LC1)/(NX1));
*
*   liste efforts N
    LL_NN1 = 'PROG' NN_LC1 PAS PAS1 NN_LT1;
*
*   boucle sur les efforts N
    NN1 = 'DIME' LL_NN1;
    I = 1;
    TAB_N1 = 'TABLE';
    TAB_VY1 = 'TABLE';
    TAB_VZ1 = 'TABLE';
*   liste des angles phi (coordonée polaire)
    LL_PHI = 'PROG' 0. PAS ((360.)/(4*NY1)) 360.;
    'REPE' IND1 (NN1);
*     position N
      TAB_N1 . I = EXTR LL_NN1 I;
      EF_NN1 = (TAB_N1 . I);
*     valeurs de demarage
      EF_VY1 = ((ABS(EF_NN1))*(1.E-3));
      EF_VZ1 = ((ABS(EF_NN1))*(1.E-3));
*
*     remplissage table
      TB1                     = 'TABLE';
      TB1.'TYPE'              = 'CHAINE' 'P_COURT';
      TB1.'NN'                = EF_NN1;
      TB1.'VY'                = EF_VY1;
      TB1.'VZ'                = 0.0;
      TB1.'MT'                = 0.0;
      TB1.'MY'                = 0.0;
      TB1.'MZ'                = 0.0;
      TB1.'BY'                = BY1;
      TB1.'BZ'                = BZ1;
      TB1.'FCD'               = FCD;
      TB1.'FSD'               = FSD;
      TB1.'WSY'               = WSY1;
      TB1.'WSZ'               = WSZ1;
      TB1.'WWY'               = WWY1;
      TB1.'WWZ'               = WWZ1;
      TB1.'LY'                = LY1;
      TB1.'LZ'                = LZ1;
      TB1.'XIY'               = XIY1;
      TB1.'XIZ'               = XIZ1;
*
*     calcul de g pou y
      G_VY1 = G_ULTIFR TB1;
*
      TB1.'VY'                = 0.0;
      TB1.'VZ'                = EF_VZ1;
*     calcul de g pou z
      G_VZ1 = G_ULTIFR TB1;
*
*     deduction des efforts Vylim et Vzlim pour N donné
      EF_VY2 = ((EF_VY1)/((1.0 - G_VY1)**(0.5)));
      EF_VZ2 = ((EF_VZ1)/((1.0 - G_VZ1)**(0.5)));
*     test
      TB1.'VY'                = EF_VY2;
      TB1.'VZ'                = 0.0;
      G_VY2 = G_ULTIFR TB1;
      TB1.'VY'                = 0.0;
      TB1.'VZ'                = EF_VZ2;
      G_VZ2 = G_ULTIFR TB1;
*
      'SI' (((ABS(G_VY2)) > TOL1) 'ET' ((ABS(G_VZ2)) > TOL1));
        'MESS' 'Error ....';
        'QUIT' FRCTRACE;        
      'FINSI';
*
*     list des effort Vy et Vz pour N donné
      LL_VY1 = EF_VY2*(COS(LL_PHI));
      LL_VZ1 = EF_VZ2*(SIN(LL_PHI));
      TAB_VY1. I = LL_VY1;
      TAB_VZ1. I = LL_VZ1;
*
      I = I + 1;
    'FIN' IND1;
*
*   initializzation maillage
    MAI1 = VIDE MAILLAGE;
    I = 1;
*   boucle sur les points selon N
    'REPE' IND1 (NN1 - 1);
      J = 1;
*   bouche sur les points theta
      NN2 = 'DIME' (TAB_VY1. I);
      'REPE' IND2 (NN2 - 1);
*       4 points par elements
        XX1 = 'EXTR' (TAB_VY1 . I) J;
        YY1 = 'EXTR' (TAB_VZ1 . I) J;
        ZZ1 = (TAB_N1 . I);
*
        XX2 = 'EXTR' (TAB_VY1 . I) (J + 1);
        YY2 = 'EXTR' (TAB_VZ1 . I) (J + 1);
        ZZ2 = (TAB_N1 . I);
*
        XX3 = 'EXTR' (TAB_VY1 . (I + 1)) (J + 1);
        YY3 = 'EXTR' (TAB_VZ1 . (I + 1)) (J + 1);
        ZZ3 = (TAB_N1 . (I + 1));
*
        XX4 = 'EXTR' (TAB_VY1 . (I + 1)) (J);
        YY4 = 'EXTR' (TAB_VZ1 . (I + 1)) (J);
        ZZ4 = (TAB_N1 . (I + 1));
*
*       points
        PP1 = XX1 YY1 ZZ1;
        PP2 = XX2 YY2 ZZ2;
        PP3 = XX3 YY3 ZZ3;
        PP4 = XX4 YY4 ZZ4;
*       element
        OPTI ELEM SEG2;
        L1 = D 1 PP1 PP2;
        L2 = D 1 PP2 PP3;
        L3 = D 1 PP3 PP4;
        L4 = D 1 PP4 PP1;
*
*       maillage
        OPTI ELEM QUA4;
        MAI1 = MAI1  'ET' ('DALL' L1 L2 L3 L4);
*
        J = J + 1;
      'FIN' IND2;
      I = I + 1;
    'FIN' IND1;
  'SINON';
    'SI' (TEST_Y 'OU' TEST_Z);
*
*   -------------      Poteau Mixte  ---------------------------------
*
*   cas mixte non implementé
    MESS 'PoT Mixte...';
    QUIT FRCTRACE;
*
*
*
    'SINON';
*
*   -------------      Poteau long  ---------------------------------
*
*   effort N de compression et de traction
    NN_LC1 = ((-1.0)*(((WSY1)*(1.0)*((FCD)*((BZ1)*(BY1))))  +   
              ((FCD)*((BZ1)*(BY1)))));
    NN_LT1 = ((1.0)*(((WSY1)*(1.0)*((FCD)*((BZ1)*(BY1))))));
    NN_LC1 = NN_LC1 - ((NN_LC1)*(1.E-4));
    NN_LT1 = NN_LT1 - ((NN_LT1)*(1.E-4));
*
*   pas pour la liste des N
    PAS1 = ((NN_LT1 - NN_LC1)/(NX1));
*
*   subdivision du domaine N
    LL_NN1 = 'PROG' NN_LC1 PAS PAS1 NN_LT1;
*
*   boucle pour chaque force N
    NN1 = 'DIME' LL_NN1;
    I = 1;
    TAB_N1 = 'TABLE';
    TAB_MY1 = 'TABLE';
    TAB_MZ1 = 'TABLE';
    LL_PHI = 'PROG' 0. PAS ((360.)/(4*NY1)) 360.;
*
    'REPE' IND1 (NN1);
      TAB_N1 . I = EXTR LL_NN1 I;
*     initialissation de l'effort N
      EF_NN1 = (TAB_N1 . I);
*     initialissation des moments y et z
      EF_MY1A = ((ABS(EF_NN1))*(1.E-3));
      EF_MY1B = ((ABS(EF_NN1))*(2.E-3));
      EF_MZ1A = ((ABS(EF_NN1))*(1.E-3));
      EF_MZ1B = ((ABS(EF_NN1))*(2.E-3));
*
*     preparation de la table pour G_ULTIFR
      TB1                     = TABLE;
      TB1.'TYPE'              = CHAINE 'P_LONG';
      TB1.'NN'                = EF_NN1;
      TB1.'VY'                = 0.0;
      TB1.'VZ'                = 0.0;
      TB1.'MT'                = 0.0;
      TB1.'MY'                = EF_MY1A;
      TB1.'MZ'                = 0.0;
      TB1.'BY'                = BY1;
      TB1.'BZ'                = BZ1;
      TB1.'FCD'               = FCD;
      TB1.'FSD'               = FSD;
      TB1.'PHI_LON'           = PHI1;
      TB1.'PHI_Y'             = PHIY1;
      TB1.'PHI_Z'             = PHIZ1;
      TB1.'EPSI_BET'          = EPS_BET1;
      TB1.'EPSI_ACI'          = EPS_ACI1;
      TB1.'YOUNG_ACIER'       = E_YACI1;
*     premiere calcul de g (My point 1)
      G_MY1 = G_ULTIFR TB1;
      TB1.'MY'                = EF_MY1B;
*     premiere calcul de g (My point 2)
      G_MY2 = G_ULTIFR TB1;
*     calcul de Mylim pour N donné
      RE_MY2P = (((EF_MY1A)**(1.5)) - ((EF_MY1B)**(1.5))/
                            (G_MY2 - G_MY1))**((1.0)/(1.5));
      EF_MY2P = ((G_MY1 + (((EF_MY1A)/(RE_MY2P))**(1.5)))**
                                       ((1.0)/(1.5)))*(RE_MY2P);
*
*     premiere calcul de g (Mz point 1)
      TB1.'MY'                = 0.0;
      TB1.'MZ'                = EF_MZ1A;
      G_MZ1 = G_ULTIFR TB1;
*
*     premiere calcul de g (Mz point 2)
      TB1.'MZ'                = EF_MZ1B;
      G_MZ2 = G_ULTIFR TB1;
*     calcul de Mzlim pour N donné
      RE_MZ2P = (((EF_MZ1A)**(1.5)) - ((EF_MZ1B)**(1.5))/
                            (G_MZ2 - G_MZ1))**((1.0)/(1.5));
      EF_MZ2P = ((G_MZ1 + (((EF_MZ1A)/(RE_MZ2P))**(1.5)))**
                                       ((1.0)/(1.5)))*(RE_MZ2P);
*
*     premiere calcul de g (My point 1) - negatif
      EF_MY1A = ((ABS(EF_NN1))*(-1.E-3));
      EF_MY1B = ((ABS(EF_NN1))*(-2.E-3));
      EF_MZ1A = ((ABS(EF_NN1))*(-1.E-3));
      EF_MZ1B = ((ABS(EF_NN1))*(-2.E-3));
      TB1.'MY'                = EF_MY1A;
      TB1.'MZ'                = 0.0;
      G_MY1 = G_ULTIFR TB1;
*     premiere calcul de g (My point 2) - negatif
      TB1.'MY'                = EF_MY1B;
      G_MY2 = G_ULTIFR TB1;
*     calcul de Mylim pour N donné - negatif
      RE_MY2N = (((ABS(EF_MY1A))**(1.5)) - ((ABS(EF_MY1B))**(1.5))/
                            (G_MY2 - G_MY1))**((1.0)/(1.5)); 
      RE_MY2N = ((RE_MY2N)*(-1.0));
      EF_MY2N = ((G_MY1 + (((EF_MY1A)/(RE_MY2N))**(1.5)))**
                                       ((1.0)/(1.5)))*(RE_MY2N);
*
*     premiere calcul de g (Mz point 1) - negatif
      TB1.'MY'                = 0.0;
      TB1.'MZ'                = EF_MZ1A;
      G_MZ1 = G_ULTIFR TB1;
*
*     premiere calcul de g (Mz point 2) - negatif
      TB1.'MZ'                = EF_MZ1B;
      G_MZ2 = G_ULTIFR TB1;
*     calcul de Mzlim pour N donné - negatif
      RE_MZ2N = (((ABS(EF_MZ1A))**(1.5)) - ((ABS(EF_MZ1B))**(1.5))/
                            (G_MZ2 - G_MZ1))**((1.0)/(1.5));
      RE_MZ2N = ((RE_MZ2N)*(-1.0));
      EF_MZ2N = ((G_MZ1 + (((EF_MZ1A)/(RE_MZ2N))**(1.5)))**
                                       ((1.0)/(1.5)))*(RE_MZ2N);
*
*     test
      TB1.'MY'                = EF_MY2P;
      TB1.'MZ'                = 0.0;
      G_MY2P = G_ULTIFR TB1;
      TB1.'MY'                = EF_MY2N;
      TB1.'MZ'                = 0.0;
      G_MY2N = G_ULTIFR TB1;
      TB1.'MY'                = 0.0;
      TB1.'MZ'                = EF_MZ2P;
      G_MZ2P = G_ULTIFR TB1;
      TB1.'MY'                = 0.0;
      TB1.'MZ'                = EF_MZ2N;
      G_MZ2N = G_ULTIFR TB1;
*
      'SI' (((ABS(G_MY2P)) > TOL1) 'ET' ((ABS(G_MY2N)) > TOL1) 'ET' 
            ((ABS(G_MZ2P)) > TOL1) 'ET' ((ABS(G_MZ2N)) > TOL1));
        'MESS' 'Error ....';
        'QUIT' FRCTRACE;        
      'FINSI';
*
*     semplissage des listes selon l'angle polaire
      LL_MY1 = 'PROG';
      LL_MZ1 = 'PROG';
      JJ1 = 1;
      'REPE' IND2 ('DIME' LL_PHI);
        VPHI1 = 'EXTR' LL_PHI JJ1;
        'SI' ((VPHI1 >EG 0.0) 'ET' (VPHI1 < 90.));
          LL_MY1 = LL_MY1 'ET' ('PROG' ((EF_MY2P)*(COS(VPHI1))));
          LL_MZ1 = LL_MZ1 'ET' ('PROG' ((EF_MZ2P)*(SIN(VPHI1))));
        'SINON';
          'SI' ((VPHI1 >EG 90.) 'ET' (VPHI1 < 180.));
            LL_MY1 = LL_MY1 'ET' ('PROG' ((ABS(EF_MY2N))*(COS(VPHI1))));
            LL_MZ1 = LL_MZ1 'ET' ('PROG' ((EF_MZ2P)*(SIN(VPHI1))));
          'SINON';
            'SI' ((VPHI1 >EG 180.) 'ET' (VPHI1 < 270.));
              LL_MY1 = LL_MY1 'ET' 
                              ('PROG' ((ABS(EF_MY2N))*(COS(VPHI1))));
              LL_MZ1 = LL_MZ1 'ET' 
                              ('PROG' ((ABS(EF_MZ2N))*(SIN(VPHI1))));
            'SINON';
              LL_MY1 = LL_MY1 'ET' ('PROG' ((EF_MY2P)*(COS(VPHI1))));
              LL_MZ1 = LL_MZ1 'ET' 
                              ('PROG' ((ABS(EF_MZ2N))*(SIN(VPHI1))));
            'FINSI';
          'FINSI';
        'FINSI';
        JJ1 = JJ1 + 1;
      'FIN' IND2;
      TAB_MY1. I = LL_MY1;
      TAB_MZ1. I = LL_MZ1;
*
      I = I + 1;
    'FIN' IND1;
*
*
*     contruction du maillage de la surface de capacité - 
*     element par element
      MAI1 = VIDE MAILLAGE;
      I = 1;
      'REPE' IND1 (NN1 - 1);
        J = 1;
        NN2 = 'DIME' (TAB_MY1. I);
        'REPE' IND2 (NN2 - 1);
          XX1 = 'EXTR' (TAB_MY1 . I) J;
          YY1 = 'EXTR' (TAB_MZ1 . I) J;
          ZZ1 = (TAB_N1 . I);
*
          XX2 = 'EXTR' (TAB_MY1 . I) (J + 1);
          YY2 = 'EXTR' (TAB_MZ1 . I) (J + 1);
          ZZ2 = (TAB_N1 . I);
*
          XX3 = 'EXTR' (TAB_MY1 . (I + 1)) (J + 1);
          YY3 = 'EXTR' (TAB_MZ1 . (I + 1)) (J + 1);
          ZZ3 = (TAB_N1 . (I + 1));
*
          XX4 = 'EXTR' (TAB_MY1 . (I + 1)) (J);
          YY4 = 'EXTR' (TAB_MZ1 . (I + 1)) (J);
          ZZ4 = (TAB_N1 . (I + 1));
*
          PP1 = XX1 YY1 ZZ1;
          PP2 = XX2 YY2 ZZ2;
          PP3 = XX3 YY3 ZZ3;
          PP4 = XX4 YY4 ZZ4;
          OPTI ELEM SEG2;
          L1 = D 1 PP1 PP2;
          L2 = D 1 PP2 PP3;
          L3 = D 1 PP3 PP4;
          L4 = D 1 PP4 PP1;
*
          OPTI ELEM QUA4;
          MAI1 = MAI1  'ET' ('DALL' L1 L2 L3 L4);
*
          J = J + 1;
        'FIN' IND2;
        I = I + 1;
      'FIN' IND1;
    'FINSI';
  'FINSI';
'FINSI';
*
*
* ------- Cas Poutre ---------------------------
'SI' (('EGA' TPY1 'POUTRE'));
* controle
  'SI' ('EXIST' TAB1 'NX');
    NX1 = TAB1.'NX';
    'SI' ('NEG' ('TYPE' NX1) 'ENTIER');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'NY');
    NY1 = TAB1.'NY';
    'SI' ('NEG' ('TYPE' NY1) 'ENTIER');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'FCK');
    FC1 = TAB1.'FCK';
    'SI' ('NEG' ('TYPE' FC1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' MRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' MRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'FSK');
    FS1 = TAB1.'FSK';
    'SI' ('NEG' ('TYPE' FS1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'GAMMA_C');
    GAMC = TAB1.'GAMMA_C';
    'SI' ('NEG' ('TYPE' GAMC) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'ALPA_C');
    ALP1 = TAB1.'ALPA_C';
    'SI' ('NEG' ('TYPE' ALP1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'GAMMA_S');
    GAMS = TAB1.'GAMMA_S';
    'SI' ('NEG' ('TYPE' GAMS) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'GAMMA_S');
    GAMS = TAB1.'GAMMA_S';
    'SI' ('NEG' ('TYPE' GAMS) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'PHI_LON');
    PHI1 = TAB1.'PHI_LON';
    'SI' ('NEG' ('TYPE' PHI1) 'LISTREEL');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'PHI_Y');
    PHIY1 = TAB1.'PHI_Y';
    'SI' ('NEG' ('TYPE' PHIY1) 'LISTREEL');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'PHI_Z');
    PHIZ1 = TAB1.'PHI_Z';
    'SI' ('NEG' ('TYPE' PHIZ1) 'LISTREEL');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'ASWL_Z');
    ASWLZ1 = TAB1.'ASWL_Z';
    'SI' ('NEG' ('TYPE' ASWLZ1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'BY');
    BY1 = TAB1.'BY';
    'SI' ('NEG' ('TYPE' BY1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'BZ');
    BZ1 = TAB1.'BZ';
    'SI' ('NEG' ('TYPE' BZ1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'ENROBAGE');
    ENR1 = TAB1.'ENROBAGE';
    'SI' ('NEG' ('TYPE' ENR1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'S_CADRE');
    SS1 = TAB1.'S_CADRE';
    'SI' ('NEG' ('TYPE' SS1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'LONGEUR_Y');
    LLY1 = TAB1.'LONGEUR_Y';
    'SI' ('NEG' ('TYPE' LLY1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'YOUNG_ACIER');
    E_YACI1 = TAB1.'YOUNG_ACIER';
    'SI' ('NEG' ('TYPE' E_YACI1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'EPSI_BET');
    EPS_BET1 = TAB1.'EPSI_BET';
    'SI' ('NEG' ('TYPE' EPS_BET1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
  'SI' ('EXIST' TAB1 'EPSI_ACI');
    EPS_ACI1 = TAB1.'EPSI_ACI';
    'SI' ('NEG' ('TYPE' EPS_ACI1) 'FLOTTANT');
      'MESS' 'Input Error ...';
      'QUIT' FRCTRACE;
    'FINSI';
  'SINON';
    'MESS' 'Input Error ...';
    'QUIT' FRCTRACE;
  'FINSI';
*
*
* Normalisation
  CC1 = 'ENTI'(FC1/100000);
*  CC1 = 0;
  'SI' (CC1 '>' 1);
    FC1 = FC1/1000;
    FS1 = FS1/1000;
    E_YACI1 = E_YACI1/1000;
  'FINSI';
*
* Calcul resistance Fcd et Fsd
  FCD = ((FC1)*(ALP1))/(GAMC);
  FSD = ((FS1))/(GAMS);
*
* Armature total longitudinale
  ASTT1 = 0.0;
  NN1 = 'DIME' PHI1;
  I = 1;
  'REPE' IND1 (NN1);
    ASTT1 = ASTT1 + ((((('EXTR' PHI1 I)/(1000))**(2.0))/(4.0))*(PI));
    I = I + 1;
  'FIN' IND1;
*
* calculs des parametres wsy wsz wwy wwz lz ly et xi
  ZZ_Z1 = BZ1 - ((2.0)*(ENR1));
  WSZ1 = ((ASTT1)*(FSD))/(((BY1)*(BZ1))*(FCD));
  WWZ1 = ((ASWLZ1)*(FSD))/(((BY1)*(SS1))*(FCD));
  LZ1 = (LLY1)/(BZ1);
  XIZ1 = (ZZ_Z1)/(BZ1);
*
* test court ou long
  TEST_Z = (LZ1 < (WSZ1/WWZ1));
*
  'SI' (TEST_Z);
*   -------------      Poutre Courte  ---------------------------------
*    ((FCD)*((BZ1)*(BY1)))
    NN_LC1 = ((-1.0)*(((WSZ1)*(1.0)*((FCD)*((BZ1)*(BY1))))  +   
              ((FCD)*((BZ1)*(BY1)))));
    NN_LT1 = ((1.0)*(((WSZ1)*(1.0)*((FCD)*((BZ1)*(BY1))))));
    NN_LC1 = NN_LC1 - ((NN_LC1)*(1.E-4));
    NN_LT1 = NN_LT1 - ((NN_LT1)*(1.E-4));
*   nombre des pas pour les efforts N
    PAS1 = ((NN_LT1 - NN_LC1)/(NX1));
*
    LL_NN1 = 'PROG' NN_LC1 PAS PAS1 NN_LT1;
*
*   liste efforts N
    NN1 = 'DIME' LL_NN1;
    I = 1;
    TAB_N1 = 'TABLE';
    TAB_VZ1 = 'TABLE';
*   liste des angles phi (coordonée polaire)
    LL_PHI = 'PROG' 0. PAS ((360.)/(4*NY1)) 360.;
    'REPE' IND1 (NN1);
*     position N
      TAB_N1 . I = EXTR LL_NN1 I;
*     valeurs de demarage
      EF_NN1 = (TAB_N1 . I);
      EF_VZ1 = ((ABS(EF_NN1))*(1.E-3));
*
      TB1                     = 'TABLE';
      TB1.'TYPE'              = 'CHAINE' 'PT_COURT';
      TB1.'NN'                = EF_NN1;
      TB1.'VY'                = 0.0;
      TB1.'VZ'                = EF_VZ1;
      TB1.'MT'                = 0.0;
      TB1.'MY'                = 0.0;
      TB1.'MZ'                = 0.0;
      TB1.'BY'                = BY1;
      TB1.'BZ'                = BZ1;
      TB1.'FCD'               = FCD;
      TB1.'FSD'               = FSD;
      TB1.'WSZ'               = WSZ1;
      TB1.'WWZ'               = WWZ1;
      TB1.'LZ'                = LZ1;
      TB1.'XIZ'               = XIZ1;
*
      TB11 = COPI TB1;
*     calcul de g pou z
      G_VZ1 = G_ULTIFR TB1;
*
*     deduction de l'effort Vzlim pour N donné
      EF_VZ2 = ((EF_VZ1)/((1.0 - G_VZ1)**(0.5)));
*     test
      TB1.'VY'                = 0.0;
      TB1.'VZ'                = EF_VZ2;
      G_VZ2 = G_ULTIFR TB1;
*
      'SI' (((ABS(G_VZ2)) > TOL1));
        'MESS' 'Error ....';
        'QUIT' FRCTRACE;        
      'FINSI';
*
*     list  Vz pour N donné
      LL_VZ1 = PROG EF_VZ2 ((-1.0)*(EF_VZ2));
      TAB_VZ1. I = LL_VZ1;
*
      I = I + 1;
    'FIN' IND1;
*
*   initializzation maillage
    MAI1 = VIDE MAILLAGE;
    I = 1;
*   boucle sur les points selon N
    'REPE' IND1 (NN1 - 1);
*
*     cordonée des points positifs et negatifs
      XX1 = 0.0;
      YY1 = 'EXTR' (TAB_VZ1 . I) 1;
      ZZ1 = (TAB_N1 . I);
*
      XX2 = 0.0;
      YY2 = 'EXTR' (TAB_VZ1 . (I + 1)) 1;
      ZZ2 = (TAB_N1 . (I + 1));
*
      XX3 = 0.0;
      YY3 = 'EXTR' (TAB_VZ1 . I) 2;
      ZZ3 = (TAB_N1 . I);
*
      XX4 = 0.0;
      YY4 = 'EXTR' (TAB_VZ1 . (I + 1)) 2;
      ZZ4 = (TAB_N1 . (I + 1));
*
*       points
      PP1 = XX1 YY1 ZZ1;
      PP2 = XX2 YY2 ZZ2;
      PP3 = XX3 YY3 ZZ3;
      PP4 = XX4 YY4 ZZ4;
*       element
      OPTI ELEM SEG2;
      L1 = D 1 PP1 PP2;
      L2 = D 1 PP3 PP4;
*
      MAI1 = MAI1  'ET' L1 'ET' L2;
*
      I = I + 1;
    'FIN' IND1;
  'SINON';
*
*
*   -------------      Poutre Longe  ---------------------------------
*
*   effort N de compression et de traction
    NN_LC1 = ((-1.0)*(((WSZ1)*(1.0)*((FCD)*((BZ1)*(BY1))))  +   
              ((FCD)*((BZ1)*(BY1)))));
    NN_LT1 = ((1.0)*(((WSZ1)*(1.0)*((FCD)*((BZ1)*(BY1))))));
    NN_LC1 = NN_LC1 - ((NN_LC1)*(1.E-4));
    NN_LT1 = NN_LT1 - ((NN_LT1)*(1.E-4));
*
*   pas pour la liste des N
    PAS1 = ((NN_LT1 - NN_LC1)/(NX1));
*
*   subdivision du domaine N
    LL_NN1 = 'PROG' NN_LC1 PAS PAS1 NN_LT1;
*
*   boucle pour chaque force N
    NN1 = 'DIME' LL_NN1;
    I = 1;
    TAB_N1 = 'TABLE';
    TAB_MY1 = 'TABLE';
*
    'REPE' IND1 (NN1);
*     initialissation de l'effort N
      TAB_N1 . I = EXTR LL_NN1 I;
      EF_NN1 = (TAB_N1 . I);
*     initialissation du moment y
      EF_MY1A = ((ABS(EF_NN1))*(1.E-3));
      EF_MY1B = ((ABS(EF_NN1))*(2.E-3));
*
      TB1                     = TABLE;
      TB1.'TYPE'              = CHAINE 'PT_LONG';
      TB1.'NN'                = EF_NN1;
      TB1.'VY'                = 0.0;
      TB1.'VZ'                = 0.0;
      TB1.'MT'                = 0.0;
      TB1.'MY'                = EF_MY1A;
      TB1.'MZ'                = 0.0;
      TB1.'BY'                = BY1;
      TB1.'BZ'                = BZ1;
      TB1.'FCD'               = FCD;
      TB1.'FSD'               = FSD;
      TB1.'PHI_LON'           = PHI1;
      TB1.'PHI_Y'             = PHIY1;
      TB1.'PHI_Z'             = PHIZ1;
      TB1.'EPSI_BET'          = EPS_BET1;
      TB1.'EPSI_ACI'          = EPS_ACI1;
      TB1.'YOUNG_ACIER'       = E_YACI1;
*     premiere calcul de g (My point 1)
      G_MY1 = G_ULTIFR TB1;
      TB1.'MY'                = EF_MY1B;
*     premiere calcul de g (My point 2)
      G_MY2 = G_ULTIFR TB1;
*     calcul de Mylim pour N donné
      RE_MY2P = (((EF_MY1A)**(1.5)) - ((EF_MY1B)**(1.5))/
                            (G_MY2 - G_MY1))**((1.0)/(1.5));
      EF_MY2P = ((G_MY1 + (((EF_MY1A)/(RE_MY2P))**(1.5)))**
                                       ((1.0)/(1.5)))*(RE_MY2P);
*
*
*     premiere calcul de g (My point 1) - negatif
      EF_MY1A = ((ABS(EF_NN1))*(-1.E-5));
      EF_MY1B = ((ABS(EF_NN1))*(-2.E-5));
      EF_MZ1A = ((ABS(EF_NN1))*(-1.E-5));
      EF_MZ1B = ((ABS(EF_NN1))*(-2.E-5));
      TB1.'MY'                = EF_MY1A;
      TB1.'MZ'                = 0.0;
      G_MY1 = G_ULTIFR TB1;
*     premiere calcul de g (My point 2) - negatif
      TB1.'MY'                = EF_MY1B;
      G_MY2 = G_ULTIFR TB1;
*     calcul de Mylim pour N donné - negatif
      RE_MY2N = (((ABS(EF_MY1A))**(1.5)) - ((ABS(EF_MY1B))**(1.5))/
                            (G_MY2 - G_MY1))**((1.0)/(1.5)); 
      RE_MY2N = ((RE_MY2N)*(-1.0));
      EF_MY2N = ((G_MY1 + (((EF_MY1A)/(RE_MY2N))**(1.5)))**
                                       ((1.0)/(1.5)))*(RE_MY2N);
*     test
      TB1.'MY'                = EF_MY2P;
      TB1.'MZ'                = 0.0;
      G_MY2P = G_ULTIFR TB1;
      TB1.'MY'                = EF_MY2N;
      TB1.'MZ'                = 0.0;
      G_MY2N = G_ULTIFR TB1;
*
      'SI' (((ABS(G_MY2P)) > TOL1) 'ET' ((ABS(G_MY2N)) > TOL1));
        'MESS' 'Error ....';
        'QUIT' FRCTRACE;        
      'FINSI';
*
      TAB_MY1. I = PROG EF_MY2P EF_MY2N;
*
      I = I + 1;
    'FIN' IND1;
*
*
*     contruction maillage
    MAI1 = VIDE MAILLAGE;
    I = 1;
    'REPE' IND1 (NN1 - 1);
*
      XX1 = 'EXTR' (TAB_MY1 . I) 1;      
      YY1 = 0.0;      
      ZZ1 = (TAB_N1 . I);
*
      XX2 = 'EXTR' (TAB_MY1 . (I + 1)) 1;      
      YY2 = 0.0;      
      ZZ2 = (TAB_N1 . (I + 1));
*
      XX3 = 'EXTR' (TAB_MY1 . (I)) 2;
      YY3 = 0.0;      
      ZZ3 = (TAB_N1 . (I));
*
      XX4 = 'EXTR' (TAB_MY1 . (I + 1)) 2;
      YY4 = 0.0;      
      ZZ4 = (TAB_N1 . (I + 1));
*
      PP1 = XX1 YY1 ZZ1;
      PP2 = XX2 YY2 ZZ2;
      PP3 = XX3 YY3 ZZ3;
      PP4 = XX4 YY4 ZZ4;
      OPTI ELEM SEG2;
      L1 = D 1 PP1 PP2;
      L2 = D 1 PP3 PP4;
*
      MAI1 = MAI1  'ET' L1 'ET' L2;
*
      I = I + 1;
    'FIN' IND1;
  'FINSI';
'FINSI';
*
*
ELIM 0.001 MAI1;
TT1 = 'TABLE';
TT1.'LIMITE' = MAI1;
*
* tracer l'enveloppe (optionelle)
*
* Control
'SI' ('EXIST' TAB1 'EFFORT_SEISME');
  CHL1 = TAB1.'EFFORT_SEISME';
  'SI' ('NEG' ('TYPE' CHL1) 'MCHAML');
    'MESS' 'Input Error ...';
    'QUIT' MRCTRACE;
  'FINSI';
'FINSI';
'SI' ('EXIST' TAB1 'EFFORT_STATIQUE');
  CHL2 = TAB1.'EFFORT_STATIQUE';
  'SI' ('NEG' ('TYPE' CHL2) 'MCHAML');
    'MESS' 'Input Error ...';
    'QUIT' MRCTRACE;
  'FINSI';
'FINSI';
*
'SI' ('EGA' ('TYPE' (CHL1)) 'MCHAML');
* 
*   extraire les contraintes (statiques)
  NN0 = 'EXTR' CHL2 'EFFX' 1 1 1;
  VY0 = 'EXTR' CHL2 'EFFY' 1 1 1;
  VZ0 = 'EXTR' CHL2 'EFFZ' 1 1 1;
  MT0 = 'EXTR' CHL2 'MOMX' 1 1 1;
  MY0 = 'EXTR' CHL2 'MOMY' 1 1 1;
  MZ0 = 'EXTR' CHL2 'MOMZ' 1 1 1;
* 
*   extraire les contraintes (sismiques)
*   plus covariances
  NNNN1 = 'EXTR' CHL1 'C11' 1 1 1;
  NNVY1 = 'EXTR' CHL1 'C12' 1 1 1;
  NNVZ1 = 'EXTR' CHL1 'C13' 1 1 1;
  NNMT1 = 'EXTR' CHL1 'C14' 1 1 1;
  NNMY1 = 'EXTR' CHL1 'C15' 1 1 1;
  NNMZ1 = 'EXTR' CHL1 'C16' 1 1 1;
  VYVY1 = 'EXTR' CHL1 'C22' 1 1 1;
  VYVZ1 = 'EXTR' CHL1 'C23' 1 1 1;
  VYMT1 = 'EXTR' CHL1 'C24' 1 1 1;
  VYMY1 = 'EXTR' CHL1 'C25' 1 1 1;
  VYMZ1 = 'EXTR' CHL1 'C26' 1 1 1;
  VZVZ1 = 'EXTR' CHL1 'C33' 1 1 1;
  VZMT1 = 'EXTR' CHL1 'C34' 1 1 1;
  VZMY1 = 'EXTR' CHL1 'C35' 1 1 1;
  VZMZ1 = 'EXTR' CHL1 'C36' 1 1 1;
  MTMT1 = 'EXTR' CHL1 'C44' 1 1 1;
  MTMY1 = 'EXTR' CHL1 'C45' 1 1 1;
  MTMZ1 = 'EXTR' CHL1 'C46' 1 1 1;
  MYMY1 = 'EXTR' CHL1 'C55' 1 1 1;
  MYMZ1 = 'EXTR' CHL1 'C56' 1 1 1;
  MZMZ1 = 'EXTR' CHL1 'C66' 1 1 1;
*
*   scaling
  SI (CC1 > 1);
    NN0 = NN0/1000;
    VY0 = VY0/1000;
    VZ0 = VZ0/1000;
    MT0 = MT0/1000;
    MY0 = MY0/1000;
    MZ0 = MZ0/1000;
*
    NNNN1 = ((NNNN1)/((1000)**(2.0)));
    NNVY1 = ((NNVY1)/((1000)**(2.0)));
    NNVZ1 = ((NNVZ1)/((1000)**(2.0)));
    NNMT1 = ((NNMT1)/((1000)**(2.0)));
    NNMY1 = ((NNMY1)/((1000)**(2.0)));
    NNMZ1 = ((NNMZ1)/((1000)**(2.0)));
    VYVY1 = ((VYVY1)/((1000)**(2.0)));
    VYVZ1 = ((VYVZ1)/((1000)**(2.0)));
    VYMT1 = ((VYMT1)/((1000)**(2.0)));
    VYMY1 = ((VYMY1)/((1000)**(2.0)));
    VYMZ1 = ((VYMZ1)/((1000)**(2.0)));
    VZVZ1 = ((VZVZ1)/((1000)**(2.0)));
    VZMT1 = ((VZMT1)/((1000)**(2.0)));
    VZMY1 = ((VZMY1)/((1000)**(2.0)));
    VZMZ1 = ((VZMZ1)/((1000)**(2.0)));
    MTMT1 = ((MTMT1)/((1000)**(2.0)));
    MTMY1 = ((MTMY1)/((1000)**(2.0)));
    MTMZ1 = ((MTMZ1)/((1000)**(2.0)));
    MYMY1 = ((MYMY1)/((1000)**(2.0)));
    MYMZ1 = ((MYMZ1)/((1000)**(2.0)));
    MZMZ1 = ((MZMZ1)/((1000)**(2.0)));
  FINSI;
*   calcul des valeurs et vecteurs propres
  MAI1 = 0. 0. 0.;
*
  'SI' (('EGA' TPY1 'POTEAU'));
*   choix des efforts selon les cas
    'SI' (TEST_Y 'ET' TEST_Z);
      N11N11E = VYVY1;
      N11N22E = VYVZ1;
      N11N12E = NNVY1;
      N22N22E = VZVZ1;
      N22N12E = NNVZ1;
      N12N12E = NNNN1;
      N110E = VY0;
      N220E = VZ0;
      N120E = NN0;
    'SINON';
      'SI' (TEST_Y 'OU' TEST_Z);
        'MESS' 'Pot_Mixte';
        'QUIT' FRCTRACE;
      'SINON';
      N11N11E = MYMY1;
      N11N22E = MYMZ1;
      N11N12E = NNMY1;
      N22N22E = MZMZ1;
      N22N12E = NNMZ1;
      N12N12E = NNNN1;
      N110E = MY0;
      N220E = MZ0;
      N120E = NN0;
      'FINSI';
    'FINSI';
  'SINON';
    'SI' (('EGA' TPY1 'POUTRE'));
      'SI' (TEST_Z);
        N11N11E = VZVZ1;
        N11N22E = NNVZ1;
        N22N22E = NNNN1;
        N110E = VZ0;
        N220E = NN0;
      'SINON';
        N11N11E = MYMY1;
        N11N22E = NNMY1;
        N22N22E = NNNN1;
        N110E = MY0;
        N220E = NN0;
      'FINSI';
    'FINSI';
  'FINSI';
*
*------------ Cas Poteau -----------------------------
*
*
  'SI' (('EGA' TPY1 'POTEAU'));
*   calcul des valeurs propres
    MATXE = 'VIDE' 'RIGIDITE'/'RIGIDITE';
    MATXE = MATXE 'ET' ('MANU' 'RIGIDITE' MAI1 ('MOTS' 'UX' 'UY' 'UZ')
      ('PROG'  N11N11E N11N22E N11N12E
               N11N22E N22N22E N22N12E
               N11N12E N22N12E N12N12E));
*
    NORMATXE = 
      (((N11N11E)**(2.0)) + ((N11N22E)**(2.0)) + ((N11N12E)**(2.0)) +
       ((N11N22E)**(2.0)) + ((N22N22E)**(2.0)) + ((N22N12E)**(2.0)) +
       ((N11N12E)**(2.0)) + ((N22N12E)**(2.0)) + ((N12N12E)**(2.0)))
                                                           **(0.5);
*   cas de la norme null
   'SI' (NORMATXE 'EGA' 0.0);
     NORMATXE = 1.0;
   'FINSI';
*   Matrice M egal à l'identité
    XIDE1 = ('MASS' 'UX' MAI1 1.0) 'ET' (MASS 'UY' MAI1 1.0)
      'ET' ('MASS' 'UZ' MAI1 1.0);
*
    OPTI EPSI LINEAIRE;
    EIGE = 'VIBR' 'INTERVALLE' 0. 20000. 'BASSE' 3 (MATXE/NORMATXE)
                                           XIDE1 'IMPR' 'MULT';
*
*   post traintement pour determiner les valuers propres et 
*   les vecteurs propres
    'SI' ('EXIST' (EIGE.MODES) 1);
      LAM1E = ((EIGE.MODES. 1 .FREQUENCE)*((2.0)*(PI)))**(2.0);
      NORVEC1E = 
           ((('EXTR' (EIGE.MODES. 1 .DEFORMEE_MODALE) MAI1 'UX')**(2))
          + (('EXTR' (EIGE.MODES. 1 .DEFORMEE_MODALE) MAI1 'UY')**(2))
          + (('EXTR' (EIGE.MODES. 1 .DEFORMEE_MODALE) MAI1 'UZ')**(2)))
                                                           **(0.5);
      VECT1E = (EIGE.MODES. 1 .DEFORMEE_MODALE)/(NORVEC1E);
    'SINON';
      LAM1E = 0.0;
      NORVEC1E = 0.0;
      VECT1E = MANU CHPO MAI1 3 'UX' 0.0 'UY' 0.0 'UZ' 0.0;
    'FINSI';
    'SI' ('EXIST' (EIGE.MODES) 2);
      LAM2E = ((EIGE.MODES. 2 .FREQUENCE)*((2.0)*(PI)))**(2.0);
      NORVEC2E = 
           ((('EXTR' (EIGE.MODES. 2 .DEFORMEE_MODALE) MAI1 'UX')**(2))
          + (('EXTR' (EIGE.MODES. 2 .DEFORMEE_MODALE) MAI1 'UY')**(2))
          + (('EXTR' (EIGE.MODES. 2 .DEFORMEE_MODALE) MAI1 'UZ')**(2)))
                                                             **(0.5);
      VECT2E = (EIGE.MODES. 2 .DEFORMEE_MODALE)/(NORVEC2E);
    'SINON';
      LAM2E = 0.0;
      NORVEC2E = 0.0;
      VECT2E = MANU CHPO MAI1 3 'UX' 0.0 'UY' 0.0 'UZ' 0.0;
    'FINSI';
    'SI' ('EXIST' (EIGE.MODES) 3);
      LAM3E = ((EIGE.MODES. 3 .FREQUENCE)*((2.0)*(PI)))**(2.0);
      NORVEC3E = 
           ((('EXTR' (EIGE.MODES. 3 .DEFORMEE_MODALE) MAI1 'UX')**(2))
          + (('EXTR' (EIGE.MODES. 3 .DEFORMEE_MODALE) MAI1 'UY')**(2))
          + (('EXTR' (EIGE.MODES. 3 .DEFORMEE_MODALE) MAI1 'UZ')**(2)))
                                                             **(0.5);
      VECT3E = (EIGE.MODES. 3 .DEFORMEE_MODALE)/(NORVEC3E);
    'SINON';
      LAM3E = 0.0;
      NORVEC3E = 0.0;
      VECT3E = MANU CHPO MAI1 3 'UX' 0.0 'UY' 0.0 'UZ' 0.0;
    'FINSI';
*
*   scaling
    LAM1E = ((NORMATXE)*(LAM1E));
    LAM2E = ((NORMATXE)*(LAM2E));
    LAM3E = ((NORMATXE)*(LAM3E));
*
*   Autovaleurs 
    LL1E = (LAM1E)**(0.5);
    LL2E = (LAM2E)**(0.5);
    LL3E = (LAM3E)**(0.5);
*
*   Autovecteur
    VECT1EX = 'EXTR' VECT1E 'UX' MAI1;
    VECT1EY = 'EXTR' VECT1E 'UY' MAI1;
    VECT1EZ = 'EXTR' VECT1E 'UZ' MAI1;
    VECT2EX = 'EXTR' VECT2E 'UX' MAI1;
    VECT2EY = 'EXTR' VECT2E 'UY' MAI1;
    VECT2EZ = 'EXTR' VECT2E 'UZ' MAI1;
    VECT3EX = 'EXTR' VECT3E 'UX' MAI1;
    VECT3EY = 'EXTR' VECT3E 'UY' MAI1;
    VECT3EZ = 'EXTR' VECT3E 'UZ' MAI1;
*
*   definition du maillage pour l'enveloppe
    MAI2E = 'VIDE' MAILLAGE;
    ND1 = 8;
    ND2 = 8;
    LL_FHI1 = 'PROG' 0. 'PAS' (90./ND1) 90.;
    LL_FHI2 = 'PROG' 0. 'PAS' (89./ND2) 89.;
    II1 = 1;
    JJ1 = 2;
*
*   boucle sur les points (on va definir la surface sur 8 quadrantes)
*   cordonée polaire fhi1 (plan xy) entre 0 pi/2
*   cordonée polaire fhi2 (azimuth) entre 0 pi/2
    'REPE' IND1 (ND1*ND2);
*
*   quadrant 1 fhi1 = [0 pi/2] fhi2 = [0 pi/2]
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1));
      VAL_FHI2 = ('EXTR' LL_FHI2 (JJ1 - 1));
      X1_1EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y1_1EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z1_1EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1 + 1));
      VAL_FHI2 = ('EXTR' LL_FHI2 (JJ1 - 1));
      X2_1EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y2_1EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z2_1EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1 + 1));
      VAL_FHI2 = ('EXTR' LL_FHI2 (JJ1));
      X3_1EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y3_1EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z3_1EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1));
      VAL_FHI2 = ('EXTR' LL_FHI2 (JJ1));
      X4_1EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y4_1EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z4_1EL =  ((LL3E)*(SIN(VAL_FHI2)));
      X1_1E = 
     ((X1_1EL)*(VECT1EX)) + ((Y1_1EL)*(VECT2EX)) + ((Z1_1EL)*(VECT3EX));
      Y1_1E = 
     ((X1_1EL)*(VECT1EY)) + ((Y1_1EL)*(VECT2EY)) + ((Z1_1EL)*(VECT3EY));
      Z1_1E = 
     ((X1_1EL)*(VECT1EZ)) + ((Y1_1EL)*(VECT2EZ)) + ((Z1_1EL)*(VECT3EZ));
      X2_1E = 
     ((X2_1EL)*(VECT1EX)) + ((Y2_1EL)*(VECT2EX)) + ((Z2_1EL)*(VECT3EX));
      Y2_1E = 
     ((X2_1EL)*(VECT1EY)) + ((Y2_1EL)*(VECT2EY)) + ((Z2_1EL)*(VECT3EY));
      Z2_1E = 
     ((X2_1EL)*(VECT1EZ)) + ((Y2_1EL)*(VECT2EZ)) + ((Z2_1EL)*(VECT3EZ));
      X3_1E = 
     ((X3_1EL)*(VECT1EX)) + ((Y3_1EL)*(VECT2EX)) + ((Z3_1EL)*(VECT3EX));
      Y3_1E = 
     ((X3_1EL)*(VECT1EY)) + ((Y3_1EL)*(VECT2EY)) + ((Z3_1EL)*(VECT3EY));
      Z3_1E = 
     ((X3_1EL)*(VECT1EZ)) + ((Y3_1EL)*(VECT2EZ)) + ((Z3_1EL)*(VECT3EZ));
      X4_1E = 
     ((X4_1EL)*(VECT1EX)) + ((Y4_1EL)*(VECT2EX)) + ((Z4_1EL)*(VECT3EX));
      Y4_1E = 
     ((X4_1EL)*(VECT1EY)) + ((Y4_1EL)*(VECT2EY)) + ((Z4_1EL)*(VECT3EY));
      Z4_1E = 
     ((X4_1EL)*(VECT1EZ)) + ((Y4_1EL)*(VECT2EZ)) + ((Z4_1EL)*(VECT3EZ));
*
*   quadrant 2 fhi1 = [pi/2 pi] fhi2 = [0 pi/2]
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1)) + ((180.0)/(2.0));
      VAL_FHI2 = ('EXTR' LL_FHI2 (JJ1 - 1));
      X1_2EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y1_2EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z1_2EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = (EXTR LL_FHI1 (II1 + 1)) + ((180.0)/(2.0));
      VAL_FHI2 = (EXTR LL_FHI2 (JJ1 - 1));
      X2_2EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y2_2EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z2_2EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = (EXTR LL_FHI1 (II1 + 1)) + ((180.0)/(2.0));
      VAL_FHI2 = (EXTR LL_FHI2 (JJ1));
      X3_2EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y3_2EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z3_2EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = (EXTR LL_FHI1 (II1)) + ((180.0)/(2.0));
      VAL_FHI2 = (EXTR LL_FHI2 (JJ1));
      X4_2EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y4_2EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z4_2EL =  ((LL3E)*(SIN(VAL_FHI2)));
      X1_2E = 
     ((X1_2EL)*(VECT1EX)) + ((Y1_2EL)*(VECT2EX)) + ((Z1_2EL)*(VECT3EX));
      Y1_2E = 
     ((X1_2EL)*(VECT1EY)) + ((Y1_2EL)*(VECT2EY)) + ((Z1_2EL)*(VECT3EY));
      Z1_2E = 
     ((X1_2EL)*(VECT1EZ)) + ((Y1_2EL)*(VECT2EZ)) + ((Z1_2EL)*(VECT3EZ));
      X2_2E = 
     ((X2_2EL)*(VECT1EX)) + ((Y2_2EL)*(VECT2EX)) + ((Z2_2EL)*(VECT3EX));
      Y2_2E = 
     ((X2_2EL)*(VECT1EY)) + ((Y2_2EL)*(VECT2EY)) + ((Z2_2EL)*(VECT3EY));
      Z2_2E = 
     ((X2_2EL)*(VECT1EZ)) + ((Y2_2EL)*(VECT2EZ)) + ((Z2_2EL)*(VECT3EZ));
      X3_2E = 
     ((X3_2EL)*(VECT1EX)) + ((Y3_2EL)*(VECT2EX)) + ((Z3_2EL)*(VECT3EX));
      Y3_2E = 
     ((X3_2EL)*(VECT1EY)) + ((Y3_2EL)*(VECT2EY)) + ((Z3_2EL)*(VECT3EY));
      Z3_2E = 
     ((X3_2EL)*(VECT1EZ)) + ((Y3_2EL)*(VECT2EZ)) + ((Z3_2EL)*(VECT3EZ));
      X4_2E = 
     ((X4_2EL)*(VECT1EX)) + ((Y4_2EL)*(VECT2EX)) + ((Z4_2EL)*(VECT3EX));
      Y4_2E = 
     ((X4_2EL)*(VECT1EY)) + ((Y4_2EL)*(VECT2EY)) + ((Z4_2EL)*(VECT3EY));
      Z4_2E = 
     ((X4_2EL)*(VECT1EZ)) + ((Y4_2EL)*(VECT2EZ)) + ((Z4_2EL)*(VECT3EZ));
*
*   quadrant 3 fhi1 = [pi 3pi/2] fhi2 = [0 pi/2]
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1)) + ((180.0)/(1.0));
      VAL_FHI2 = ('EXTR' LL_FHI2 (JJ1 - 1));
      X1_3EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y1_3EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z1_3EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1 + 1)) + ((180.0)/(1.0));
      VAL_FHI2 = ('EXTR' LL_FHI2 (JJ1 - 1));
      X2_3EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y2_3EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z2_3EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1 + 1)) + ((180.0)/(1.0));
      VAL_FHI2 = ('EXTR' LL_FHI2 (JJ1));
      X3_3EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y3_3EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z3_3EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1)) + ((180.0)/(1.0));
      VAL_FHI2 = ('EXTR' LL_FHI2 (JJ1));
      X4_3EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y4_3EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z4_3EL =  ((LL3E)*(SIN(VAL_FHI2)));
      X1_3E = 
     ((X1_3EL)*(VECT1EX)) + ((Y1_3EL)*(VECT2EX)) + ((Z1_3EL)*(VECT3EX));
      Y1_3E = 
     ((X1_3EL)*(VECT1EY)) + ((Y1_3EL)*(VECT2EY)) + ((Z1_3EL)*(VECT3EY));
      Z1_3E = 
     ((X1_3EL)*(VECT1EZ)) + ((Y1_3EL)*(VECT2EZ)) + ((Z1_3EL)*(VECT3EZ));
      X2_3E = 
     ((X2_3EL)*(VECT1EX)) + ((Y2_3EL)*(VECT2EX)) + ((Z2_3EL)*(VECT3EX));
      Y2_3E = 
     ((X2_3EL)*(VECT1EY)) + ((Y2_3EL)*(VECT2EY)) + ((Z2_3EL)*(VECT3EY));
      Z2_3E = 
     ((X2_3EL)*(VECT1EZ)) + ((Y2_3EL)*(VECT2EZ)) + ((Z2_3EL)*(VECT3EZ));
      X3_3E = 
     ((X3_3EL)*(VECT1EX)) + ((Y3_3EL)*(VECT2EX)) + ((Z3_3EL)*(VECT3EX));
      Y3_3E = 
     ((X3_3EL)*(VECT1EY)) + ((Y3_3EL)*(VECT2EY)) + ((Z3_3EL)*(VECT3EY));
      Z3_3E = 
     ((X3_3EL)*(VECT1EZ)) + ((Y3_3EL)*(VECT2EZ)) + ((Z3_3EL)*(VECT3EZ));
      X4_3E = 
     ((X4_3EL)*(VECT1EX)) + ((Y4_3EL)*(VECT2EX)) + ((Z4_3EL)*(VECT3EX));
      Y4_3E = 
     ((X4_3EL)*(VECT1EY)) + ((Y4_3EL)*(VECT2EY)) + ((Z4_3EL)*(VECT3EY));
      Z4_3E = 
     ((X4_3EL)*(VECT1EZ)) + ((Y4_3EL)*(VECT2EZ)) + ((Z4_3EL)*(VECT3EZ));
*
*   quadrant 4 fhi1 = [3pi/2 2pi] fhi2 = [0 pi/2]
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1)) + (((3.0)*(180.0))/(2.0));
      VAL_FHI2 = ('EXTR' LL_FHI2 (JJ1 - 1));
      X1_4EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y1_4EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z1_4EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1 + 1)) + (((3.0)*(180.0))/(2.0));
      VAL_FHI2 = ('EXTR' LL_FHI2 (JJ1 - 1));
      X2_4EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y2_4EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z2_4EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1 + 1)) + (((3.0)*(180.0))/(2.0));
      VAL_FHI2 = ('EXTR' LL_FHI2 (JJ1));
      X3_4EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y3_4EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z3_4EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1)) + (((3.0)*(180.0))/(2.0));
      VAL_FHI2 = ('EXTR' LL_FHI2 (JJ1));
      X4_4EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y4_4EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z4_4EL =  ((LL3E)*(SIN(VAL_FHI2)));
      X1_4E = 
     ((X1_4EL)*(VECT1EX)) + ((Y1_4EL)*(VECT2EX)) + ((Z1_4EL)*(VECT3EX));
      Y1_4E = 
     ((X1_4EL)*(VECT1EY)) + ((Y1_4EL)*(VECT2EY)) + ((Z1_4EL)*(VECT3EY));
      Z1_4E = 
     ((X1_4EL)*(VECT1EZ)) + ((Y1_4EL)*(VECT2EZ)) + ((Z1_4EL)*(VECT3EZ));
      X2_4E = 
     ((X2_4EL)*(VECT1EX)) + ((Y2_4EL)*(VECT2EX)) + ((Z2_4EL)*(VECT3EX));
      Y2_4E = 
     ((X2_4EL)*(VECT1EY)) + ((Y2_4EL)*(VECT2EY)) + ((Z2_4EL)*(VECT3EY));
      Z2_4E = 
     ((X2_4EL)*(VECT1EZ)) + ((Y2_4EL)*(VECT2EZ)) + ((Z2_4EL)*(VECT3EZ));
      X3_4E = 
     ((X3_4EL)*(VECT1EX)) + ((Y3_4EL)*(VECT2EX)) + ((Z3_4EL)*(VECT3EX));
      Y3_4E = 
     ((X3_4EL)*(VECT1EY)) + ((Y3_4EL)*(VECT2EY)) + ((Z3_4EL)*(VECT3EY));
      Z3_4E = 
     ((X3_4EL)*(VECT1EZ)) + ((Y3_4EL)*(VECT2EZ)) + ((Z3_4EL)*(VECT3EZ));
      X4_4E = 
     ((X4_4EL)*(VECT1EX)) + ((Y4_4EL)*(VECT2EX)) + ((Z4_4EL)*(VECT3EX));
      Y4_4E = 
     ((X4_4EL)*(VECT1EY)) + ((Y4_4EL)*(VECT2EY)) + ((Z4_4EL)*(VECT3EY));
      Z4_4E = 
     ((X4_4EL)*(VECT1EZ)) + ((Y4_4EL)*(VECT2EZ)) + ((Z4_4EL)*(VECT3EZ));
*
*   quadrant 5 fhi1 = [0 pi/2] fhi2 = [-pi/2 0]
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1));
      VAL_FHI2 =  (-1.0)*('EXTR' LL_FHI2 (JJ1 - 1));
      X1_5EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y1_5EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z1_5EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1 + 1));
      VAL_FHI2 =  (-1.0)*('EXTR' LL_FHI2 (JJ1 - 1));
      X2_5EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y2_5EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z2_5EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1 + 1));
      VAL_FHI2 =  (-1.0)*('EXTR' LL_FHI2 (JJ1));
      X3_5EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y3_5EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z3_5EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1));
      VAL_FHI2 =  (-1.0)*('EXTR' LL_FHI2 (JJ1));
      X4_5EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y4_5EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z4_5EL =  ((LL3E)*(SIN(VAL_FHI2)));
      X1_5E = 
     ((X1_5EL)*(VECT1EX)) + ((Y1_5EL)*(VECT2EX)) + ((Z1_5EL)*(VECT3EX));
      Y1_5E = 
     ((X1_5EL)*(VECT1EY)) + ((Y1_5EL)*(VECT2EY)) + ((Z1_5EL)*(VECT3EY));
      Z1_5E = 
     ((X1_5EL)*(VECT1EZ)) + ((Y1_5EL)*(VECT2EZ)) + ((Z1_5EL)*(VECT3EZ));
      X2_5E = 
     ((X2_5EL)*(VECT1EX)) + ((Y2_5EL)*(VECT2EX)) + ((Z2_5EL)*(VECT3EX));
      Y2_5E = 
     ((X2_5EL)*(VECT1EY)) + ((Y2_5EL)*(VECT2EY)) + ((Z2_5EL)*(VECT3EY));
      Z2_5E = 
     ((X2_5EL)*(VECT1EZ)) + ((Y2_5EL)*(VECT2EZ)) + ((Z2_5EL)*(VECT3EZ));
      X3_5E = 
     ((X3_5EL)*(VECT1EX)) + ((Y3_5EL)*(VECT2EX)) + ((Z3_5EL)*(VECT3EX));
      Y3_5E = 
     ((X3_5EL)*(VECT1EY)) + ((Y3_5EL)*(VECT2EY)) + ((Z3_5EL)*(VECT3EY));
      Z3_5E = 
     ((X3_5EL)*(VECT1EZ)) + ((Y3_5EL)*(VECT2EZ)) + ((Z3_5EL)*(VECT3EZ));
      X4_5E = 
     ((X4_5EL)*(VECT1EX)) + ((Y4_5EL)*(VECT2EX)) + ((Z4_5EL)*(VECT3EX));
      Y4_5E = 
     ((X4_5EL)*(VECT1EY)) + ((Y4_5EL)*(VECT2EY)) + ((Z4_5EL)*(VECT3EY));
      Z4_5E = 
     ((X4_5EL)*(VECT1EZ)) + ((Y4_5EL)*(VECT2EZ)) + ((Z4_5EL)*(VECT3EZ));
*
*   quadrant 6 fhi1 = [pi/2 pi] fhi2 = [-pi/2 0]
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1)) + ((180.0)/(2.0));
      VAL_FHI2 = (-1.0)*('EXTR' LL_FHI2 (JJ1 - 1));
      X1_6EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y1_6EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z1_6EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1 + 1))  + ((180.0)/(2.0));
      VAL_FHI2 =  (-1.0)*('EXTR' LL_FHI2 (JJ1 - 1));
      X2_6EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y2_6EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z2_6EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1 + 1))  + ((180.0)/(2.0));
      VAL_FHI2 =  (-1.0)*('EXTR' LL_FHI2 (JJ1));
      X3_6EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y3_6EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z3_6EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1)) + ((180.0)/(2.0));
      VAL_FHI2 =  (-1.0)*('EXTR' LL_FHI2 (JJ1));
      X4_6EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y4_6EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z4_6EL =  ((LL3E)*(SIN(VAL_FHI2)));
      X1_6E = 
     ((X1_6EL)*(VECT1EX)) + ((Y1_6EL)*(VECT2EX)) + ((Z1_6EL)*(VECT3EX));
      Y1_6E = 
     ((X1_6EL)*(VECT1EY)) + ((Y1_6EL)*(VECT2EY)) + ((Z1_6EL)*(VECT3EY));
      Z1_6E = 
     ((X1_6EL)*(VECT1EZ)) + ((Y1_6EL)*(VECT2EZ)) + ((Z1_6EL)*(VECT3EZ));
      X2_6E = 
     ((X2_6EL)*(VECT1EX)) + ((Y2_6EL)*(VECT2EX)) + ((Z2_6EL)*(VECT3EX));
      Y2_6E = 
     ((X2_6EL)*(VECT1EY)) + ((Y2_6EL)*(VECT2EY)) + ((Z2_6EL)*(VECT3EY));
      Z2_6E = 
     ((X2_6EL)*(VECT1EZ)) + ((Y2_6EL)*(VECT2EZ)) + ((Z2_6EL)*(VECT3EZ));
      X3_6E = 
     ((X3_6EL)*(VECT1EX)) + ((Y3_6EL)*(VECT2EX)) + ((Z3_6EL)*(VECT3EX));
      Y3_6E = 
     ((X3_6EL)*(VECT1EY)) + ((Y3_6EL)*(VECT2EY)) + ((Z3_6EL)*(VECT3EY));
      Z3_6E = 
     ((X3_6EL)*(VECT1EZ)) + ((Y3_6EL)*(VECT2EZ)) + ((Z3_6EL)*(VECT3EZ));
      X4_6E = 
     ((X4_6EL)*(VECT1EX)) + ((Y4_6EL)*(VECT2EX)) + ((Z4_6EL)*(VECT3EX));
      Y4_6E = 
     ((X4_6EL)*(VECT1EY)) + ((Y4_6EL)*(VECT2EY)) + ((Z4_6EL)*(VECT3EY));
      Z4_6E = 
     ((X4_6EL)*(VECT1EZ)) + ((Y4_6EL)*(VECT2EZ)) + ((Z4_6EL)*(VECT3EZ));
*
*   quadrant 7 fhi1 = [pi 3pi/2] fhi2 = [-pi/2 0]
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1)) + ((180.0)/(1.0));
      VAL_FHI2 =  (-1.0)*('EXTR' LL_FHI2 (JJ1 - 1));
      X1_7EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y1_7EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z1_7EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1 + 1)) + ((180.0)/(1.0));
      VAL_FHI2 =  (-1.0)*('EXTR' LL_FHI2 (JJ1 - 1));
      X2_7EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y2_7EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z2_7EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1 + 1)) + ((180.0)/(1.0));
      VAL_FHI2 =  (-1.0)*('EXTR' LL_FHI2 (JJ1));
      X3_7EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y3_7EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z3_7EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1)) + ((180.0)/(1.0));
      VAL_FHI2 =  (-1.0)*('EXTR' LL_FHI2 (JJ1));
      X4_7EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y4_7EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z4_7EL =  ((LL3E)*(SIN(VAL_FHI2)));
      X1_7E = 
     ((X1_7EL)*(VECT1EX)) + ((Y1_7EL)*(VECT2EX)) + ((Z1_7EL)*(VECT3EX));
      Y1_7E = 
     ((X1_7EL)*(VECT1EY)) + ((Y1_7EL)*(VECT2EY)) + ((Z1_7EL)*(VECT3EY));
      Z1_7E = 
     ((X1_7EL)*(VECT1EZ)) + ((Y1_7EL)*(VECT2EZ)) + ((Z1_7EL)*(VECT3EZ));
      X2_7E = 
     ((X2_7EL)*(VECT1EX)) + ((Y2_7EL)*(VECT2EX)) + ((Z2_7EL)*(VECT3EX));
      Y2_7E = 
     ((X2_7EL)*(VECT1EY)) + ((Y2_7EL)*(VECT2EY)) + ((Z2_7EL)*(VECT3EY));
      Z2_7E = 
     ((X2_7EL)*(VECT1EZ)) + ((Y2_7EL)*(VECT2EZ)) + ((Z2_7EL)*(VECT3EZ));
      X3_7E = 
     ((X3_7EL)*(VECT1EX)) + ((Y3_7EL)*(VECT2EX)) + ((Z3_7EL)*(VECT3EX));
      Y3_7E = 
     ((X3_7EL)*(VECT1EY)) + ((Y3_7EL)*(VECT2EY)) + ((Z3_7EL)*(VECT3EY));
      Z3_7E = 
     ((X3_7EL)*(VECT1EZ)) + ((Y3_7EL)*(VECT2EZ)) + ((Z3_7EL)*(VECT3EZ));
      X4_7E = 
     ((X4_7EL)*(VECT1EX)) + ((Y4_7EL)*(VECT2EX)) + ((Z4_7EL)*(VECT3EX));
      Y4_7E = 
     ((X4_7EL)*(VECT1EY)) + ((Y4_7EL)*(VECT2EY)) + ((Z4_7EL)*(VECT3EY));
      Z4_7E = 
     ((X4_7EL)*(VECT1EZ)) + ((Y4_7EL)*(VECT2EZ)) + ((Z4_7EL)*(VECT3EZ));
*
*   quadrant 8 fhi1 = [3pi/2 2pi] fhi2 = [-pi/2 0]
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1)) + (((3.0)*(180.0))/(2.0));
      VAL_FHI2 =  (-1.0)*('EXTR' LL_FHI2 (JJ1 - 1));
      X1_8EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y1_8EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z1_8EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1 + 1)) + (((3.0)*(180.0))/(2.0));
      VAL_FHI2 =  (-1.0)*('EXTR' LL_FHI2 (JJ1 - 1));
      X2_8EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y2_8EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z2_8EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1 + 1)) + (((3.0)*(180.0))/(2.0));
      VAL_FHI2 =  (-1.0)*('EXTR' LL_FHI2 (JJ1));
      X3_8EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y3_8EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z3_8EL =  ((LL3E)*(SIN(VAL_FHI2)));
      VAL_FHI1 = ('EXTR' LL_FHI1 (II1)) + (((3.0)*(180.0))/(2.0));
      VAL_FHI2 =  (-1.0)*('EXTR' LL_FHI2 (JJ1));
      X4_8EL = (((LL1E)*(COS(VAL_FHI1)))*(COS(VAL_FHI2)));
      Y4_8EL = (((LL2E)*(SIN(VAL_FHI1)))*(COS(VAL_FHI2)));
      Z4_8EL =  ((LL3E)*(SIN(VAL_FHI2)));
      X1_8E = 
     ((X1_8EL)*(VECT1EX)) + ((Y1_8EL)*(VECT2EX)) + ((Z1_8EL)*(VECT3EX));
      Y1_8E = 
     ((X1_8EL)*(VECT1EY)) + ((Y1_8EL)*(VECT2EY)) + ((Z1_8EL)*(VECT3EY));
      Z1_8E = 
     ((X1_8EL)*(VECT1EZ)) + ((Y1_8EL)*(VECT2EZ)) + ((Z1_8EL)*(VECT3EZ));
      X2_8E = 
     ((X2_8EL)*(VECT1EX)) + ((Y2_8EL)*(VECT2EX)) + ((Z2_8EL)*(VECT3EX));
      Y2_8E = 
     ((X2_8EL)*(VECT1EY)) + ((Y2_8EL)*(VECT2EY)) + ((Z2_8EL)*(VECT3EY));
      Z2_8E = 
     ((X2_8EL)*(VECT1EZ)) + ((Y2_8EL)*(VECT2EZ)) + ((Z2_8EL)*(VECT3EZ));
      X3_8E = 
     ((X3_8EL)*(VECT1EX)) + ((Y3_8EL)*(VECT2EX)) + ((Z3_8EL)*(VECT3EX));
      Y3_8E = 
     ((X3_8EL)*(VECT1EY)) + ((Y3_8EL)*(VECT2EY)) + ((Z3_8EL)*(VECT3EY));
      Z3_8E = 
     ((X3_8EL)*(VECT1EZ)) + ((Y3_8EL)*(VECT2EZ)) + ((Z3_8EL)*(VECT3EZ));
      X4_8E = 
     ((X4_8EL)*(VECT1EX)) + ((Y4_8EL)*(VECT2EX)) + ((Z4_8EL)*(VECT3EX));
      Y4_8E = 
     ((X4_8EL)*(VECT1EY)) + ((Y4_8EL)*(VECT2EY)) + ((Z4_8EL)*(VECT3EY));
      Z4_8E = 
     ((X4_8EL)*(VECT1EZ)) + ((Y4_8EL)*(VECT2EZ)) + ((Z4_8EL)*(VECT3EZ));
*
*
*     definition points
      P1_1E = (X1_1E + N110E) (Y1_1E + N220E) (Z1_1E + N120E);
      P2_1E = (X2_1E + N110E) (Y2_1E + N220E) (Z2_1E + N120E);
      P3_1E = (X3_1E + N110E) (Y3_1E + N220E) (Z3_1E + N120E);
      P4_1E = (X4_1E + N110E) (Y4_1E + N220E) (Z4_1E + N120E);
*
      P1_2E = (X1_2E + N110E) (Y1_2E + N220E) (Z1_2E + N120E);
      P2_2E = (X2_2E + N110E) (Y2_2E + N220E) (Z2_2E + N120E);
      P3_2E = (X3_2E + N110E) (Y3_2E + N220E) (Z3_2E + N120E);
      P4_2E = (X4_2E + N110E) (Y4_2E + N220E) (Z4_2E + N120E);
*
      P1_3E = (X1_3E + N110E) (Y1_3E + N220E) (Z1_3E + N120E);
      P2_3E = (X2_3E + N110E) (Y2_3E + N220E) (Z2_3E + N120E);
      P3_3E = (X3_3E + N110E) (Y3_3E + N220E) (Z3_3E + N120E);
      P4_3E = (X4_3E + N110E) (Y4_3E + N220E) (Z4_3E + N120E);
*
      P1_4E = (X1_4E + N110E) (Y1_4E + N220E) (Z1_4E + N120E);
      P2_4E = (X2_4E + N110E) (Y2_4E + N220E) (Z2_4E + N120E);
      P3_4E = (X3_4E + N110E) (Y3_4E + N220E) (Z3_4E + N120E);
      P4_4E = (X4_4E + N110E) (Y4_4E + N220E) (Z4_4E + N120E);
*
      P1_5E = (X1_5E + N110E) (Y1_5E + N220E) (Z1_5E + N120E);
      P2_5E = (X2_5E + N110E) (Y2_5E + N220E) (Z2_5E + N120E);
      P3_5E = (X3_5E + N110E) (Y3_5E + N220E) (Z3_5E + N120E);
      P4_5E = (X4_5E + N110E) (Y4_5E + N220E) (Z4_5E + N120E);
*
      P1_6E = (X1_6E + N110E) (Y1_6E + N220E) (Z1_6E + N120E);
      P2_6E = (X2_6E + N110E) (Y2_6E + N220E) (Z2_6E + N120E);
      P3_6E = (X3_6E + N110E) (Y3_6E + N220E) (Z3_6E + N120E);
      P4_6E = (X4_6E + N110E) (Y4_6E + N220E) (Z4_6E + N120E);
*
      P1_7E = (X1_7E + N110E) (Y1_7E + N220E) (Z1_7E + N120E);
      P2_7E = (X2_7E + N110E) (Y2_7E + N220E) (Z2_7E + N120E);
      P3_7E = (X3_7E + N110E) (Y3_7E + N220E) (Z3_7E + N120E);
      P4_7E = (X4_7E + N110E) (Y4_7E + N220E) (Z4_7E + N120E);
*
      P1_8E = (X1_8E + N110E) (Y1_8E + N220E) (Z1_8E + N120E);
      P2_8E = (X2_8E + N110E) (Y2_8E + N220E) (Z2_8E + N120E);
      P3_8E = (X3_8E + N110E) (Y3_8E + N220E) (Z3_8E + N120E);
      P4_8E = (X4_8E + N110E) (Y4_8E + N220E) (Z4_8E + N120E);
*
*     definitions des lignes
      OPTI ELEM SEG2;
      L1_1E = 'DROIT' 1 P1_1E P2_1E;
      L2_1E = 'DROIT' 1 P2_1E P3_1E;
      L3_1E = 'DROIT' 1 P3_1E P4_1E;
      L4_1E = 'DROIT' 1 P4_1E P1_1E;
*
      L1_2E = 'DROIT' 1 P1_2E P2_2E;
      L2_2E = 'DROIT' 1 P2_2E P3_2E;
      L3_2E = 'DROIT' 1 P3_2E P4_2E;
      L4_2E = 'DROIT' 1 P4_2E P1_2E;
*
      L1_3E = 'DROIT' 1 P1_3E P2_3E;
      L2_3E = 'DROIT' 1 P2_3E P3_3E;
      L3_3E = 'DROIT' 1 P3_3E P4_3E;
      L4_3E = 'DROIT' 1 P4_3E P1_3E;
*
      L1_4E = 'DROIT' 1 P1_4E P2_4E;
      L2_4E = 'DROIT' 1 P2_4E P3_4E;
      L3_4E = 'DROIT' 1 P3_4E P4_4E;
      L4_4E = 'DROIT' 1 P4_4E P1_4E;
*
      L1_5E = 'DROIT' 1 P1_5E P2_5E;
      L2_5E = 'DROIT' 1 P2_5E P3_5E;
      L3_5E = 'DROIT' 1 P3_5E P4_5E;
      L4_5E = 'DROIT' 1 P4_5E P1_5E;
*
      L1_6E = 'DROIT' 1 P1_6E P2_6E;
      L2_6E = 'DROIT' 1 P2_6E P3_6E;
      L3_6E = 'DROIT' 1 P3_6E P4_6E;
      L4_6E = 'DROIT' 1 P4_6E P1_6E;
*
      L1_7E = 'DROIT' 1 P1_7E P2_7E;
      L2_7E = 'DROIT' 1 P2_7E P3_7E;
      L3_7E = 'DROIT' 1 P3_7E P4_7E;
      L4_7E = 'DROIT' 1 P4_7E P1_7E;
*
      L1_8E = 'DROIT' 1 P1_8E P2_8E;
      L2_8E = 'DROIT' 1 P2_8E P3_8E;
      L3_8E = 'DROIT' 1 P3_8E P4_8E;
      L4_8E = 'DROIT' 1 P4_8E P1_8E;
*
*     definition des elements
      OPTI ELEM QUA4;
      ELE1_1E = 'DALL' L1_1E L2_1E L3_1E L4_1E;
      ELE1_2E = 'DALL' L1_2E L2_2E L3_2E L4_2E;
      ELE1_3E = 'DALL' L1_3E L2_3E L3_3E L4_3E;
      ELE1_4E = 'DALL' L1_4E L2_4E L3_4E L4_4E;
      ELE1_5E = 'DALL' L1_5E L2_5E L3_5E L4_5E;
      ELE1_6E = 'DALL' L1_6E L2_6E L3_6E L4_6E;
      ELE1_7E = 'DALL' L1_7E L2_7E L3_7E L4_7E;
      ELE1_8E = 'DALL' L1_8E L2_8E L3_8E L4_8E;
*
*     update maillage
      MAI2E = MAI2E 'ET' ELE1_1E 'ET' ELE1_2E 'ET' ELE1_3E 'ET' ELE1_4E
                    'ET' ELE1_5E 'ET' ELE1_6E 'ET' ELE1_7E 'ET' ELE1_8E;
*
      'SI' (II1 'EGA' ND1);
        II1 = 1;
        JJ1 = JJ1 + 1;
      'SINON';
        II1 = II1 + 1;
      'FINSI';
    'FIN' IND1;
    'ELIM' 0.001 MAI2E;
*
    TT1.'ELLIPSOIDE' = MAI2E;
*
*   definition maillage pour l'enveloppe rectangulaire
    MAI3E = 'VIDE' 'MAILLAGE';
*
*   definition des points
    PPS1E = (((-1.0)*((N11N11E )**(0.5))) + N110E)
            (((-1.0)*((N22N22E )**(0.5))) + N220E)
            (((-1.0)*((N12N12E )**(0.5))) + N120E);
    PPS2E = (((1.0)*((N11N11E )**(0.5))) + N110E)
            (((-1.0)*((N22N22E )**(0.5))) + N220E)
            (((-1.0)*((N12N12E )**(0.5))) + N120E);
    PPS3E = (((1.0)*((N11N11E )**(0.5))) + N110E)
            (((1.0)*((N22N22E )**(0.5))) + N220E)
            (((-1.0)*((N12N12E )**(0.5))) + N120E);
    PPS4E = (((-1.0)*((N11N11E )**(0.5))) + N110E)
            (((1.0)*((N22N22E )**(0.5))) + N220E)
            (((-1.0)*((N12N12E )**(0.5))) + N120E);
    PPS5E = (((-1.0)*((N11N11E )**(0.5))) + N110E)
            (((-1.0)*((N22N22E )**(0.5))) + N220E)
            (((1.0)*((N12N12E )**(0.5))) + N120E);
    PPS6E = (((1.0)*((N11N11E )**(0.5))) + N110E)
            (((-1.0)*((N22N22E )**(0.5))) + N220E)
            (((1.0)*((N12N12E )**(0.5))) + N120E);
    PPS7E = (((1.0)*((N11N11E )**(0.5))) + N110E)
            (((1.0)*((N22N22E )**(0.5))) + N220E)
            (((1.0)*((N12N12E )**(0.5))) + N120E);
    PPS8E = (((-1.0)*((N11N11E )**(0.5))) + N110E)
            (((1.0)*((N22N22E )**(0.5))) + N220E)
            (((1.0)*((N12N12E )**(0.5))) + N120E);
*
*   definition des lignes
    OPTI ELEM SEG2;
    LLS1E = 'DROIT' 8 PPS1E PPS2E;
    LLS2E = 'DROIT' 8 PPS2E PPS3E;
    LLS3E = 'DROIT' 8 PPS3E PPS4E;
    LLS4E = 'DROIT' 8 PPS4E PPS1E;
    LLS5E = 'DROIT' 8 PPS5E PPS6E;
    LLS6E = 'DROIT' 8 PPS6E PPS7E;
    LLS7E = 'DROIT' 8 PPS7E PPS8E;
    LLS8E = 'DROIT' 8 PPS8E PPS5E;
    LLS9E = 'DROIT' 8 PPS1E PPS5E;
    LLS10E = 'DROIT' 8 PPS2E PPS6E;
    LLS11E = 'DROIT' 8 PPS3E PPS7E;
    LLS12E = 'DROIT' 8 PPS4E PPS8E;
*
*   definition des elements
    OPTI ELEM QUA4;
    SSU1E = 'DALL' LLS1E LLS2E LLS3E LLS4E;
    SSU2E = 'DALL' LLS5E LLS6E LLS7E LLS8E;
    SSU3E = 'DALL' LLS1E LLS10E ('INVE' LLS5E) ('INVE' LLS9E);
    SSU4E = 'DALL' LLS2E LLS11E ('INVE' LLS6E) ('INVE' LLS10E);
    SSU5E = 'DALL' LLS3E LLS12E ('INVE' LLS7E) ('INVE' LLS11E);
    SSU6E = 'DALL' LLS4E LLS9E ('INVE' LLS8E) ('INVE' LLS12E);
*
*   definition des elements
    MAI3E = MAI3E ET (SSU1E 'ET' SSU2E 'ET' SSU3E 'ET' SSU4E 'ET' 
                      SSU5E 'ET' SSU6E);
*
    TT1.'RECTANGLE' = MAI3E;
*
  'FINSI';
*
*
*------------ Cas Poutre -----------------------------
*
*
  'SI' (('EGA' TPY1 'POUTRE'));
*   calcul des valeurs propres
    'SI' (TEST_Z);
      MATXE = 'VIDE' 'RIGIDITE'/'RIGIDITE';
      MATXE = MATXE 'ET' ('MANU' 'RIGIDITE' MAI1 ('MOTS' 'UY' 'UZ')
        ('PROG'  N11N11E N11N22E 
                 N11N22E N22N22E));
      NORMATXE = 
        (((N11N11E)**(2.0)) + ((N11N22E)**(2.0)) +
         ((N11N22E)**(2.0)) + ((N22N22E)**(2.0)))**(0.5);
*   cas de la norme null
       'SI' (NORMATXE 'EGA' 0.0);
         NORMATXE = 1.0;
       'FINSI';
*
      XIDE1 = ('MASS' 'UY' MAI1 1.0) 'ET' (MASS 'UZ' MAI1 1.0);
*
      OPTI EPSI LINEAIRE;
      EIGE = 'VIBR' 'INTERVALLE' 0. 20000. 'BASSE' 2 (MATXE/NORMATXE)
                                             XIDE1 'IMPR' 'MULT';
*
*   post traintement pour determiner les valuers propres et 
*   les vecteurs propres
      'SI' ('EXIST' (EIGE.MODES) 1);
        LAM1E = ((EIGE.MODES. 1 .FREQUENCE)*((2.0)*(PI)))**(2.0);
        NORVEC1E = 
           ((('EXTR' (EIGE.MODES. 1 .DEFORMEE_MODALE) MAI1 'UY')**(2))
          + (('EXTR' (EIGE.MODES. 1 .DEFORMEE_MODALE) MAI1 'UZ')**(2)))
                                                             **(0.5);
        VECT1E = (EIGE.MODES. 1 .DEFORMEE_MODALE)/(NORVEC1E);
      'SINON';
        LAM1E = 0.0;
        NORVEC1E = 0.0;
        VECT1E = MANU CHPO MAI1 2 'UY' 0.0 'UZ' 0.0;
      'FINSI';
      'SI' ('EXIST' (EIGE.MODES) 2);
        LAM2E = ((EIGE.MODES. 2 .FREQUENCE)*((2.0)*(PI)))**(2.0);
        NORVEC2E = 
           ((('EXTR' (EIGE.MODES. 2 .DEFORMEE_MODALE) MAI1 'UY')**(2))
          + (('EXTR' (EIGE.MODES. 2 .DEFORMEE_MODALE) MAI1 'UZ')**(2)))
                                                               **(0.5);
        VECT2E = (EIGE.MODES. 2 .DEFORMEE_MODALE)/(NORVEC2E);
      'SINON';
        LAM2E = 0.0;
        NORVEC2E = 0.0;
        VECT2E = MANU CHPO MAI1 2 'UY' 0.0 'UZ' 0.0;
      'FINSI';
*
*   scaling
      LAM1E = ((NORMATXE)*(LAM1E));
      LAM2E = ((NORMATXE)*(LAM2E));
*
*   Autovaleurs 
      LL1E = (LAM1E)**(0.5);
      LL2E = (LAM2E)**(0.5);
*
*   Autovecteur 
      VECT1EX = 'EXTR' VECT1E 'UX' MAI1;
      VECT1EY = 'EXTR' VECT1E 'UY' MAI1;
      VECT1EZ = 'EXTR' VECT1E 'UZ' MAI1;
      VECT2EX = 'EXTR' VECT2E 'UX' MAI1;
      VECT2EY = 'EXTR' VECT2E 'UY' MAI1;
      VECT2EZ = 'EXTR' VECT2E 'UZ' MAI1;
*
*   definition du maillage pour l'enveloppe
      MAI2E = 'VIDE' MAILLAGE;
      ND1 = 32;
      LL_FHI1 = 'PROG' 0. 'PAS' (360./ND1) 360.;
      II1 = 1;
*
*   boucle sur les points (on va definir la surface sur 8 quadrantes)
*   cordonée polaire fhi1 (plan xy) entre 0 pi/2
*   cordonée polaire fhi2 (azimuth) entre 0 pi/2
      'REPE' IND1 (ND1);
*
*   quadrant 1 fhi1 = [0 pi/2] fhi2 = [0 pi/2]
        VAL_FHI1 = ('EXTR' LL_FHI1 (II1));
        X1_1EL = 0.0;
        Y1_1EL = ((LL1E)*(COS(VAL_FHI1)));
        Z1_1EL = ((LL2E)*(SIN(VAL_FHI1)));
*
        VAL_FHI1 = ('EXTR' LL_FHI1 (II1 + 1));
        X2_1EL = 0.0;
        Y2_1EL = ((LL1E)*(COS(VAL_FHI1)));
        Z2_1EL = ((LL2E)*(SIN(VAL_FHI1)));
*
        X1_1E =0.0;
        Y1_1E = ((X1_1EL)*(VECT1EY)) + 
                ((Y1_1EL)*(VECT1EY)) + ((Z1_1EL)*(VECT2EY));
        Z1_1E = ((X1_1EL)*(VECT1EZ)) + 
                ((Y1_1EL)*(VECT1EZ)) + ((Z1_1EL)*(VECT2EZ));
*
        X2_1E =0.0;
        Y2_1E = ((X2_1EL)*(VECT1EY)) + 
                ((Y2_1EL)*(VECT1EY)) + ((Z2_1EL)*(VECT2EY));
        Z2_1E = ((X2_1EL)*(VECT1EZ)) + 
                ((Y2_1EL)*(VECT1EZ)) + ((Z2_1EL)*(VECT2EZ));
*
*
*     definition points
        P1_1E = (X1_1E) (Y1_1E + N110E) (Z1_1E + N220E);
        P2_1E = (X1_1E) (Y2_1E + N110E) (Z2_1E + N220E);
*
*     definitions des lignes
        OPTI ELEM SEG2;
        L1_1E = 'DROIT' 1 P1_1E P2_1E;
*
*     update maillage
        MAI2E = MAI2E 'ET' L1_1E;
*
        II1 = II1 + 1;
      'FIN' IND1;
      'ELIM' 0.001 MAI2E;
*
      TT1.'ELLIPSOIDE' = MAI2E;
*
*   definition maillage pour l'enveloppe rectangulaire
      MAI3E = 'VIDE' 'MAILLAGE';
*
*   definition des points
      PPS1E = 0.0
              (((-1.0)*((N11N11E )**(0.5))) + N110E)
              (((-1.0)*((N22N22E )**(0.5))) + N220E);
      PPS2E = 0.0
              (((1.0)*((N11N11E )**(0.5))) + N110E)
              (((-1.0)*((N22N22E )**(0.5))) + N220E);
      PPS3E = 0.0
              (((1.0)*((N11N11E )**(0.5))) + N110E)
              (((1.0)*((N22N22E )**(0.5))) + N220E);
      PPS4E = 0.0
              (((-1.0)*((N11N11E )**(0.5))) + N110E)
              (((1.0)*((N22N22E )**(0.5))) + N220E);
*
*   definition des lignes
      OPTI ELEM SEG2;
      LLS1E = 'DROIT' 8 PPS1E PPS2E;
      LLS2E = 'DROIT' 8 PPS2E PPS3E;
      LLS3E = 'DROIT' 8 PPS3E PPS4E;
      LLS4E = 'DROIT' 8 PPS4E PPS1E;
*
*   definition des elements
      MAI3E = MAI3E 'ET' LLS1E 'ET' LLS2E 'ET' LLS3E 'ET' LLS4E;
*
      TT1.'RECTANGLE' = MAI3E;
    'SINON';
*   calcul des valeurs propres
      MATXE = 'VIDE' 'RIGIDITE'/'RIGIDITE';
      MATXE = MATXE 'ET' ('MANU' 'RIGIDITE' MAI1 ('MOTS' 'UX' 'UZ')
        ('PROG'  N11N11E N11N22E 
                 N11N22E N22N22E));
      NORMATXE = 
        (((N11N11E)**(2.0)) + ((N11N22E)**(2.0)) +
         ((N11N22E)**(2.0)) + ((N22N22E)**(2.0)))**(0.5);
*   cas de la norme null
       'SI' (NORMATXE 'EGA' 0.0);
         NORMATXE = 1.0;
       'FINSI';
*   Matrice M egal à l'identité
      XIDE1 = ('MASS' 'UX' MAI1 1.0) 'ET' (MASS 'UZ' MAI1 1.0);
*
*   post traintement pour determiner les valuers propres et 
*   les vecteurs propres
      OPTI EPSI LINEAIRE;
      EIGE = 'VIBR' 'INTERVALLE' 0. 20000. 'BASSE' 2 (MATXE/NORMATXE)
                                             XIDE1 'IMPR' 'MULT';
*
      'SI' ('EXIST' (EIGE.MODES) 1);
        LAM1E = ((EIGE.MODES. 1 .FREQUENCE)*((2.0)*(PI)))**(2.0);
        NORVEC1E = 
           ((('EXTR' (EIGE.MODES. 1 .DEFORMEE_MODALE) MAI1 'UX')**(2))
          + (('EXTR' (EIGE.MODES. 1 .DEFORMEE_MODALE) MAI1 'UZ')**(2)))
                                                             **(0.5);
        VECT1E = (EIGE.MODES. 1 .DEFORMEE_MODALE)/(NORVEC1E);
      'SINON';
        LAM1E = 0.0;
        NORVEC1E = 0.0;
        VECT1E = MANU CHPO MAI1 2 'UX' 0.0 'UZ' 0.0;
      'FINSI';
      'SI' ('EXIST' (EIGE.MODES) 2);
        LAM2E = ((EIGE.MODES. 2 .FREQUENCE)*((2.0)*(PI)))**(2.0);
        NORVEC2E = 
           ((('EXTR' (EIGE.MODES. 2 .DEFORMEE_MODALE) MAI1 'UX')**(2))
          + (('EXTR' (EIGE.MODES. 2 .DEFORMEE_MODALE) MAI1 'UZ')**(2)))
                                                               **(0.5);
        VECT2E = (EIGE.MODES. 2 .DEFORMEE_MODALE)/(NORVEC2E);
      'SINON';
        LAM2E = 0.0;
        NORVEC2E = 0.0;
        VECT2E = MANU CHPO MAI1 2 'UX' 0.0 'UZ' 0.0;
      'FINSI';
*
*   scaling
      LAM1E = ((NORMATXE)*(LAM1E));
      LAM2E = ((NORMATXE)*(LAM2E));
*
*   Autovaleurs
      LL1E = (LAM1E)**(0.5);
      LL2E = (LAM2E)**(0.5);
*
*   Autovecteur
      VECT1EX = 'EXTR' VECT1E 'UX' MAI1;
      VECT1EY = 'EXTR' VECT1E 'UY' MAI1;
      VECT1EZ = 'EXTR' VECT1E 'UZ' MAI1;
      VECT2EX = 'EXTR' VECT2E 'UX' MAI1;
      VECT2EY = 'EXTR' VECT2E 'UY' MAI1;
      VECT2EZ = 'EXTR' VECT2E 'UZ' MAI1;
*
*   definition du maillage pour l'enveloppe
      MAI2E = 'VIDE' MAILLAGE;
      ND1 = 32;
      LL_FHI1 = 'PROG' 0. 'PAS' (360./ND1) 360.;
      II1 = 1;
*
*   boucle sur les points (on va definir la surface sur 8 quadrantes)
*   cordonée polaire fhi1 (plan xy) entre 0 pi/2
*   cordonée polaire fhi2 (azimuth) entre 0 pi/2
      'REPE' IND1 (ND1);
*
*   quadrant 1 fhi1 = [0 pi/2] fhi2 = [0 pi/2]
        VAL_FHI1 = ('EXTR' LL_FHI1 (II1));
        Y1_1EL = 0.0;
        X1_1EL = ((LL1E)*(COS(VAL_FHI1)));
        Z1_1EL = ((LL2E)*(SIN(VAL_FHI1)));
*
        VAL_FHI1 = ('EXTR' LL_FHI1 (II1 + 1));
        Y2_1EL = 0.0;
        X2_1EL = ((LL1E)*(COS(VAL_FHI1)));
        Z2_1EL = ((LL2E)*(SIN(VAL_FHI1)));
*
        Y1_1E =0.0;
        X1_1E = ((X1_1EL)*(VECT1EX)) + 
                ((Y1_1EL)*(VECT1EX)) + ((Z1_1EL)*(VECT2EX));
        Z1_1E = ((X1_1EL)*(VECT1EZ)) + 
                ((Y1_1EL)*(VECT1EZ)) + ((Z1_1EL)*(VECT2EZ));
*
        Y2_1E =0.0;
        X2_1E = ((X2_1EL)*(VECT1EX)) + 
                ((Y2_1EL)*(VECT1EX)) + ((Z2_1EL)*(VECT2EX));
        Z2_1E = ((X2_1EL)*(VECT1EZ)) + 
                ((Y2_1EL)*(VECT1EZ)) + ((Z2_1EL)*(VECT2EZ));
*
*
*     definition points
        P1_1E = (X1_1E + N110E) (Y1_1E) (Z1_1E + N220E);
        P2_1E = (X2_1E + N110E) (Y2_1E) (Z2_1E + N220E);
*
*     definitions des lignes
        OPTI ELEM SEG2;
        L1_1E = 'DROIT' 1 P1_1E P2_1E;
*
*     update maillage
        MAI2E = MAI2E 'ET' L1_1E;
*
        II1 = II1 + 1;
      'FIN' IND1;
      'ELIM' 0.001 MAI2E;
*
      TT1.'ELLIPSOIDE' = MAI2E;
*
*   definition maillage pour l'enveloppe rectangulaire
      MAI3E = 'VIDE' 'MAILLAGE';
*
*   definition des points
      PPS1E = (((-1.0)*((N11N11E )**(0.5))) + N110E)
              0.0
              (((-1.0)*((N22N22E )**(0.5))) + N220E);
      PPS2E = (((1.0)*((N11N11E )**(0.5))) + N110E)
              0.0
              (((-1.0)*((N22N22E )**(0.5))) + N220E);
      PPS3E = (((1.0)*((N11N11E )**(0.5))) + N110E)
              0.0
              (((1.0)*((N22N22E )**(0.5))) + N220E);
      PPS4E = (((-1.0)*((N11N11E )**(0.5))) + N110E)
              0.0
              (((1.0)*((N22N22E )**(0.5))) + N220E);
*
*   definition des lignes
      OPTI ELEM SEG2;
      LLS1E = 'DROIT' 8 PPS1E PPS2E;
      LLS2E = 'DROIT' 8 PPS2E PPS3E;
      LLS3E = 'DROIT' 8 PPS3E PPS4E;
      LLS4E = 'DROIT' 8 PPS4E PPS1E;
*
*   definition des elements
      MAI3E = MAI3E 'ET' LLS1E 'ET' LLS2E 'ET' LLS3E 'ET' LLS4E;
*
      TT1.'RECTANGLE' = MAI3E;
    'FINSI';
*
  'FINSI';
'FINSI';
*
*---------------------------------------------------------
FINPROC TT1;


